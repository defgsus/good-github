# [<](2021-03-26.md) 2021-03-27 [>](2021-03-28.md)

2,077,150 events, 1,182,354 push events, 1,683,151 commit messages, 107,369,605 characters


## [OdSazib/halcyon_kernel_sdm660@0a11c9f5f9...](https://github.com/OdSazib/halcyon_kernel_sdm660/commit/0a11c9f5f9c6ba3cb8f55f8d137a6ee3eed482cd)
##### 2021-03-27 04:34:39 by Michal Hocko

proc: oom: drop bogus task_lock and mm check

Series "Handle oom bypass more gracefully", V5

The following 10 patches should put some order to very rare cases of mm
shared between processes and make the paths which bypass the oom killer
oom reapable and therefore much more reliable finally.  Even though mm
shared outside of thread group is rare (either vforked tasks for a short
period, use_mm by kernel threads or exotic thread model of
clone(CLONE_VM) without CLONE_SIGHAND) it is better to cover them.  Not
only it makes the current oom killer logic quite hard to follow and
reason about it can lead to weird corner cases.  E.g.  it is possible to
select an oom victim which shares the mm with unkillable process or
bypass the oom killer even when other processes sharing the mm are still
alive and other weird cases.

Patch 1 drops bogus task_lock and mm check from oom_{score_}adj_write.
This can be considered a bug fix with a low impact as nobody has noticed
for years.

Patch 2 drops sighand lock because it is not needed anymore as pointed
by Oleg.

Patch 3 is a clean up of oom_score_adj handling and a preparatory work
for later patches.

Patch 4 enforces oom_adj_score to be consistent between processes
sharing the mm to behave consistently with the regular thread groups.
This can be considered a user visible behavior change because one thread
group updating oom_score_adj will affect others which share the same mm
via clone(CLONE_VM).  I argue that this should be acceptable because we
already have the same behavior for threads in the same thread group and
sharing the mm without signal struct is just a different model of
threading.  This is probably the most controversial part of the series,
I would like to find some consensus here.  There were some suggestions
to hook some counter/oom_score_adj into the mm_struct but I feel that
this is not necessary right now and we can rely on proc handler +
oom_kill_process to DTRT.  I can be convinced otherwise but I strongly
think that whatever we do the userspace has to have a way to see the
current oom priority as consistently as possible.

Patch 5 makes sure that no vforked task is selected if it is sharing the
mm with oom unkillable task.

Patch 6 ensures that all user tasks sharing the mm are killed which in
turn makes sure that all oom victims are oom reapable.

Patch 7 guarantees that task_will_free_mem will always imply reapable
bypass of the oom killer.

Patch 8 is new in this version and it addresses an issue pointed out by
0-day OOM report where an oom victim was reaped several times.

Patch 9 puts an upper bound on how many times oom_reaper tries to reap a
task and hides it from the oom killer to move on when no progress can be
made.  This will give an upper bound to how long an oom_reapable task
can block the oom killer from selecting another victim if the oom_reaper
is not able to reap the victim.

Patch 10 tries to plug the (hopefully) last hole when we can still lock
up when the oom victim is shared with oom unkillable tasks (kthreads and
global init).  We just try to be best effort in that case and rather
fallback to kill something else than risk a lockup.

This patch (of 10):

Both oom_adj_write and oom_score_adj_write are using task_lock, check for
task->mm and fail if it is NULL.  This is not needed because the
oom_score_adj is per signal struct so we do not need mm at all.  The code
has been introduced by 3d5992d2ac7d ("oom: add per-mm oom disable count")
but we do not do per-mm oom disable since c9f01245b6a7 ("oom: remove
oom_disable_count").

The task->mm check is even not correct because the current thread might
have exited but the thread group might be still alive - e.g.  thread group
leader would lead that echo $VAL > /proc/pid/oom_score_adj would always
fail with EINVAL while /proc/pid/task/$other_tid/oom_score_adj would
succeed.  This is unexpected at best.

Remove the lock along with the check to fix the unexpected behavior and
also because there is not real need for the lock in the first place.

Link: http://lkml.kernel.org/r/1466426628-15074-2-git-send-email-mhocko@kernel.org
Signed-off-by: Michal Hocko <mhocko@suse.com>
Reviewed-by: Vladimir Davydov <vdavydov@virtuozzo.com>
Acked-by: Oleg Nesterov <oleg@redhat.com>
Cc: David Rientjes <rientjes@google.com>
Cc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Change-Id: Id5b29755e8dbc70fc104263e207bb54de5eeb6ee

---
## [SmArtKar/tgstation@7b52daef41...](https://github.com/SmArtKar/tgstation/commit/7b52daef41ff7b771cc84aedcdebba82679e684e)
##### 2021-03-27 10:42:43 by LemonInTheDark

Makes stations more airtight (#57535)

I've gone through delta, meta, and icebox and added some choice windoors, changed some areas around, added some more doors, and changed some other miscellaneous things.

I'll list the full changes in drop downs, for both our sakes

Delta:
<details>
Splits the central hallway into fore and aft central hallways

Adds the spaces that jut out of medbay and sci into the central hallway, rather then having them be a part of
medbay and sci

Adds medbay access locked windoors to the back desk of the medbay reception area

Adds airlocks to both the upper and lower parts of the main hallway
</details>

Meta:
<details>
Gives the storage wing another set of firelocks, and two fire alarms. It didn't have any alarms in the first place, so hopefully this helps things

Adds the spaces that jut out of medbay and sci into the central hallway, rather then having them be a part of
medbay and sci

Replaces a small bit of the science area with nanite lab, to prevent a breach near xenobio causing fire alarms
at the front of sci

Adds a windoor in front of the ORM to block air

Adds a wall behind a smart fridge in chemistry
</details>

Icebox:
<details>
Added airlocks between arrivals and the port hallway, and the escape hallway and the starboard hallway

Added a windoor between the kitchen and the bar
</details>

## Why It's Good For The Game

Cuts delta's main hallway in half, with the goal of reducing fire alarm strain. Some thoughts on this would be nice, I don't want to make everything else that uses areas worse just because fire alarms are dumb, and I'm worried that's what I've ended up doing here.

I've also added the portions of medbay/sci that jut out into the main hallway into the main hallway, I think? I could make these into lobby areas, but I'm not sure if that's appropriate or not.

Adds a few windoors and airlocks to better section off portions of the station, this should reduce the amount of mass gas spreading that can occur.

My goal here is to reduce the amount of uninteresting gas movement and make firelocks less hellish when there's a breach

---
## [mrakgr/The-Spiral-Language@20cde936d0...](https://github.com/mrakgr/The-Spiral-Language/commit/20cde936d07c8c89cb7a238aa24e81a0e81c963f)
##### 2021-03-27 17:40:28 by Marko GrdiniÄ‡

"2pm. Done with breakfast. Let me chill a bit and then I'll do the chores.

2:25pm. It is time for chores.

After that, I'll find a way to integrate the UI I made with the Leduc game.

It is time to finally get on with it.

3:10pm. Done with chores. Let me get this thing started. I'll leave fun for later.

```
open kivy
open lithe

union msg =
    | Clicked

type state (a : * -> * -> *) (b : * -> * -> *) = {
    p1 : nodes.player_funs a leduc.card leduc.action f64
    p2 : nodes.player_funs b leduc.card leduc.action f64
    text : string
    }

inl model (s : state _ _) = function
    | Clicked =>
        open nodes
        inl Empty = player {probSelf=to_log_prob 1; observations=Nil; state=agent.stateless()} |> dyn
        inl r = leduc.game (nodes.cps.nodes_2p (s.p1, s.p2)) ((Empty,Empty),dyn id)
        inl ts = $"f\"Reward for player one is {!r}.\\n\"" : string
        {s with text#=fun t => $"!t + !ts"}

inl view dispatch (state : rx.observable (state _ _)) =
    inl (~+) x = +state x
    boxlayout [
        -orientation Vertical
        children [
            scrollview [
                -do_scroll_x false
                -do_scroll_y true
                children [
                    label [
                        -size_hint_y None
                        @on_texture_size (fun (l,(_,v)) => $"!l.height = !v")
                        +text fun {text} => text
                        ]
                    ]
                ]
            boxlayout [
                -orientation Horizontal
                -size_hint_y (Some: 0.2)
                children [
                    button [
                        -text "Start Game."
                        @on_press (fun _ => dispatch Clicked)
                        ]
                    ]
                ]
            ]
        ]

inl main () =
    inl app = appm.create()
    inl p1 = agent.neural_random.create()
    inl p2 = agent.uniform_random.create()
    inl text = ""
    inl _ = rx.subscribe (loop {p1 p2 text} model view) (appm.root app)
    appm.run app
```

This is what I had last time. Let me try running it.

...I really need a command to run things automatically. Switching to the terminal only to run the damn script is incredibly inefficient.

Let me leave this for later. For now let me just do it the usual way.

...Ran it. It still works of course. Now think me.

```
inl model (s : state _ _) = function
    | Clicked =>
        open nodes
        inl Empty = player {probSelf=to_log_prob 1; observations=Nil; state=agent.stateless()} |> dyn
        inl r = leduc.game (nodes.cps.nodes_2p (s.p1, s.p2)) ((Empty,Empty),dyn id)
        inl ts = $"f\"Reward for player one is {!r}.\\n\"" : string
        {s with text#=fun t => $"!t + !ts"}
```

The next goal is human vs random player. Once I am able to do that, I'll close a lot of the gap with that 2016 poker app that I did.

```
open nodes
open leduc

let show_card = function
    | King => "King"
    | Queen => "Queen"
    | Jack => "Jack"

let rec show_trace l =
    inl ar : rarray string = r64.empty
    listm.fold (fun is_first => function
        | Observation: x =>
            inl o = show_card x
            r64.add ar $"f'Observed {!o}.'"
            true
        | Action: x =>
            inl p = if is_first then "Player One" else "Player Two"
            inl a = match x with Fold => "folds" | Call => "calls" | Raise => "raises"
            r64.add ar $"f'{!p} {!a}.'"
            not is_first
        ) true l |> ignore
    r64.join' "\n" ar

open nodes
inl create dispatch = player_funs {
    action = fun (player p : player replay card action) opp_prob dist next =>
        dispatch (p.observations, dist, fun x => next (x,p.state))
    terminal = fun (player {observations probSelf state=(replay rep)}) (reward: probOpp:) =>
        r64.add rep {observations reward probOpp probSelf=exp_log_prob probSelf}
    }
```

I did this last time in `human.spi`. Now it is time for the next step.

```
    action = fun (player p : player replay card action) opp_prob dist next =>
        dispatch (p.observations, dist, fun x => next (x,p.state))
```

Expecting the dispatch to return the log prob of the human player makes no sense.

```
    action = fun (player p : player replay card action) opp_prob dist next =>
        dispatch (p.observations, dist, fun x => next ((log_prob 0, x),p.state))
```

```
nominal player_funs (p : * -> * -> *) o a r = {
    action : player p o a -> log_prob -> array a -> ((log_prob * a) * p o a -> r) -> r
    terminal : player p o a -> (Reward: f64 probOpp: f64) -> ()
    }
```

What is this probOpp here. Should it not be log_prob?

```
    terminal = fun (player {observations probSelf state=(replay rep)}) (reward: probOpp:) =>
        r64.add rep {observations reward probOpp probSelf=exp_log_prob probSelf}
```

Ah, it is fine.

```
open nodes
inl create dispatch = player_funs {
    action = fun (player p : player replay card action) opp_prob dist next =>
        dispatch (show_trace p.observations, dist, fun x => next ((log_prob 0,x),p.state))
    terminal = fun (player {observations probSelf state=(replay rep)}) (reward: probOpp:) =>
        r64.add rep {observations reward probOpp probSelf=exp_log_prob probSelf}
    }
```

For the initial step, let me just focus on showing the trace and the actions. I'll leave the table aside for the time being.

3:30pm. The most important thing to do here is to icebreak connecting the front and the backend.

I've hesitated far too long on this. It should have been done 3 weeks ago. It is time to overcome the block.

Let me make the player.

```
    Button:
        text: 'Start Game'
        font_size: sp(50)
        size_hint_y: 0.15
```

Needed to add the start game button to the sketch.

```
    Button:
        id: btn_call
        font_size: sp(60)
        text: 'Call'
    Button:
        id: btn_fold
        font_size: sp(60)
        text: 'Fold'
    Button:
        id: btn_raise
        font_size: sp(60)
        text: 'Raise'
        disabled: True
```

Let me put the revevant ids where they should be.

Let me just experiment with this a little bit. Let me print the ids.

```
on_press: print(root.ids)
```

This just gives me btn_start. Let me fold the actions inside then.

```
{'btn_call': <WeakProxy to <kivy.uix.button.Button object at 0x00000239B05C2C10>>, 'btn_fold': <WeakProxy to <kivy.uix.button.Button object at 0x00000239B05C2F20>>, 'btn_raise': <WeakProxy to <kivy.uix.button.Button object at 0x00000239B060B270>>, 'btn_start': <WeakProxy to <kivy.uix.button.Button object at 0x00000239B06360B0>>}
```

Great, now I have all of these.

But is not that easy.

...No this is not going for me.

Forget this. Let me try rewriting the UI in Spiral. I am having difficulty conceptualizing how to connect the UI in a high level fashion. I need the Elm pattern after all.

Let me make this my next goal.

3:45pm. Focus me. Let me do all that I need in turn.

```py
root = Builder.load_string('''
<Table@FloatLayout>:
    canvas:
        Line:
            width: 2
            rectangle: self.x, self.y, self.width, self.height
    Stack: # Stack
        id: my_stack
        canvas:
            Line:
                rectangle: self.x, self.y, self.width, self.height
        text: 'Stack: ' + str(self.chips)
        x: root.x + root.width * 0.075
        y: root.y + root.height * 0.075
        font_size: sp(30)
        size_hint: None, None
        size: self.texture_size
```

This is the first bit of it.

```
        text: 'Stack: ' + str(self.chips)
        x: root.x + root.width * 0.075
        y: root.y + root.height * 0.075
```

Just this would take a lot of effort to do.

I'd have to do on_x and on_width to set the x here as I want.

Aghhhhhh...

4pm. Let me take a short break here. This is not working.

5:25pm. I spent time in bed to think about it.

```
inl size_hint_x (v : option f64) x =
    inl x = toWidget x
    match v with
    | Some: v => $"!x.size_hint_x = !v"
    | None => $"!x.size_hint_x = None"
inl size_hint_y (v : option f64) x =
    inl x = toWidget x
    match v with
    | Some: v => $"!x.size_hint_y = !v"
    | None => $"!x.size_hint_y = None"
```

```
                    label [
                        -size_hint_y None
                        @on_texture_size (fun (l,(_,v)) => $"!l.height = !v")
                        +text fun {text} => text
                        ]
```

Yeah, this is wrong.

When I wrote `@on_texture_size (fun (l,(_,v)) => $"!l.height = !v")` I found it disturbing, and this was a throwback to the 2016 of doing apps.

This is not right. What would have made sense if for `texture_size` to be an observable, and then I'd just set `height` to that.

Let me check out Avalonia again. I want to see how properties work in it.

https://avaloniaui.net/blog/2015-02-16-avalonia-properties

Hmmm, it is actually nicer in Python.

https://avaloniaui.net/docs/binding/attached-properties

Yeah, it is no wonder I wasn't interested in this last time.

https://svelte.dev/

Imagine if the Kivy mini-language was on the level of Svelte. What would I do then?

5:40pm. Properties are a good idea if you imagine them to be a ref cell for an observable. Setting the property would publish the observable as a replay_one...no wait that is wrong.

Setting the observable is done during the creation. It is immutable.

Then reading the property would just get that observable.

5:40pm. I am going to master properties and the Kivy language.

Or rather, I already know everything there is to know about them and I just need to get comfortable.

Right now, there is a war going on in my mind, I am pitting Kivy vs Rx. What I need to do is off source Rx.

5:45pm. Let me open a new project. I'll get rid of Rx and Lithe.

5:50pm.

```
packages: |core-
modules:
    types-
    r64
    serialization/
        dense/
            array
        sparse/
            int
    utils-
    torch/
        utils-
    sampling
    nodes/
        utils-
        cps
        main-
    leduc
    agent/
        utils-
        uniform_random
        neural_random
        human
    cps_test
    main
```

This is `ui_leduc2`. Yes, I looked down on Python way too much. Quickly iterating the UI, and mutating the top-level properties from the backend is the ideal style.

Rx could be competitive here, but I want to play along with the library rather than fight against it. I will gain nothing if I put in the extra effort of bringing in observables here.

For setting up the UI, it is the same situation as drawing with Processing - a better type system would do jack shit to help. Instead what I need to do is minimize the interop friction.

If I had to do UIs in JS, I would just do the frontend in Svelte, and then do the backend in Spiral or whatever else, and connect the two.

6pm. 2021 is the year of farewells. To my old ambitions. To my old techniques. To my old effort and grudges.

The path I am on allows no compromises.

To do more, I first must learn to do less. Before I can beat the amateurs, I first must learn to be an amateur.

6:35pm. Let me stop here. I've been thinking the whole day about this. I think I've done this enough to reach a resolution.

Everything that Svelte does, or what those Kivy properties do, Rx can do as well, but it should be my second choice, not the first. Not unless I can help it."

---
## [Buildstarted/linksfordevs@e30d793b60...](https://github.com/Buildstarted/linksfordevs/commit/e30d793b6011f4b8e8e131c963012cd49f846a24)
##### 2021-03-27 19:15:47 by Ben Dornis

Updating: 3/27/2021 6:00:00 PM

 1. Added: Top 5 Questions I Get About VS Code - VS Code Settings Q and A
    (https://www.youtube.com/watch?v=Cp6F5q7I8S0)
 2. Added: Mentorship vs. Sponsorship + Storytelling - Computer Stuff They Didn't Teach You #21
    (https://www.youtube.com/watch?v=8HE5LJwAv1k)
 3. Added: Should You Learn VIM as a Developer?
    (https://www.youtube.com/watch?v=RNan7JhtXkU)
 4. Added: Build a Harry Potter API with Node.js, Express.js, and Dynamo DB
    (https://www.youtube.com/watch?v=JPQPPLQnyB4)
 5. Added: Are there Secret Microsoft APIs in Windows 10?
    (https://www.youtube.com/watch?v=RrfRbPRZ8MY)
 6. Added: That time Bill Gates had a house party...
    (https://www.youtube.com/watch?v=RBFdLwbzmB8)
 7. Added: We asked a Retired Microsoft Windows Engineer 100 Questions!  Why oh Why?  Find out!
    (https://www.youtube.com/watch?v=Cp1DD5Cva8o)
 8. Added: Davepl: Writing Your Own Operating System
    (https://www.youtube.com/watch?v=5eMtBhfoGhs)
 9. Added: Azure Static Web Apps, Website, GitHub, SSL & hosting FREE! Computer Stuff They Didn't Teach You #20
    (https://www.youtube.com/watch?v=lqvYAI74w64)
10. Added: Blazor WebAssembly : Creating Chat Application Using SignalR - EP24
    (https://www.youtube.com/watch?v=5VSUX6w5P8g)
11. Added: Intro to Graphics 10 - Curves (Part 2)
    (https://www.youtube.com/watch?v=l9dCeeq3X1E)
12. Added: Manage FreeRTOS tasks - Suspend, Delay, Resume, Delete (ESP32 + Arduino series)
    (https://www.youtube.com/watch?v=jJaGRCgDo9s)
13. Added: The Day Microsoft Campus Crashed - Bedlam at Microsoft!
    (https://www.youtube.com/watch?v=pBmuY6qFMPQ)
14. Added: Is Gatsby a Backend Framework?!?!
    (https://www.youtube.com/watch?v=jKYUtz0OjIE)
15. Added: Hello, Windows!  RetroCoding "Hello World" for Windows with Dave
    (https://www.youtube.com/watch?v=JlZe2JwrJqM)
16. Added: Watch as I build my YouTube Subscriber Counter!
    (https://www.youtube.com/watch?v=9VvHJIeN9v0)
17. Added: Keep WiFi Connection Alive with FreeRTOS Task (ESP32 + Arduino series)
    (https://www.youtube.com/watch?v=YSGPcm-qxDA)
18. Added: Solid - A Better Web (Simply Explained)
    (https://www.youtube.com/watch?v=qWVTjMsv7AE)
19. Added: How I Bombed My First Technical Interview
    (https://www.youtube.com/watch?v=tMt_zVQpdJA)
20. Added: Best Features and Benefits of the Jamstack with Colby Fayock
    (https://www.youtube.com/watch?v=OHqouNcZPG4)
21. Added: Authentication with Nextjs, Fauna, and Auth0 - Nextjs Crash Course Part 2
    (https://www.youtube.com/watch?v=wusz7X1a3sQ)
22. Added: Setting up Cardano Relays using Kubernetes/microk8s
    (https://blog.dantup.com/2021/03/cardano-relays-using-kubernetes/)
23. Added: Hello, Assembly!  Retrocoding the World's Smallest Windows App in x86 ASM
    (https://www.youtube.com/watch?v=b0zxIfJJLAY)
24. Added: Do Microsoft Devs Secretly Use Linux?
    (https://www.youtube.com/watch?v=brxngH5EnRA)
25. Added: .NET GC Internals - 05. Sweep phase
    (https://www.youtube.com/watch?v=rrHT21ALJDE)
26. Added: Blazor WebAssembly : Lazy-loading Assemblies - EP22
    (https://www.youtube.com/watch?v=e_22VhPQJj0)
27. Added: What is FreeRTOS? (ESP32 + Arduino series)
    (https://www.youtube.com/watch?v=kP-pP6FEu8I)
28. Added: Intro to Graphics 07 - GPU Pipeline
    (https://www.youtube.com/watch?v=UzlnprHSbUw)
29. Added: Dave's Garage Livestream - Linux vs Windows Secrets plus more!
    (https://www.youtube.com/watch?v=5KHE6qTH9Gk)
30. Added: Black to the Future - Bryce Sharp
    (https://www.youtube.com/watch?v=JMLcAgMb6xI)
31. Added: Davepl: Windows Source Code Leak and the Task Manager Code
    (https://www.youtube.com/watch?v=r7H5IwbSIOg)
32. Added: Microsoft Weddings and Marriages  #Shorts
    (https://www.youtube.com/watch?v=bRUPKjEIYBM)
33. Added: Blazor WebAssembly : Deploy to IIS - EP23
    (https://www.youtube.com/watch?v=vV0zn91OZfc)
34. Added: Linux vs Windows Round  1: Open Source vs Proprietary - From a Retired Microsoft Dev
    (https://www.youtube.com/watch?v=a9ZADRy5W0c)
35. Added: Software Drag Racing:  C++ vs C# vs Python - Which Will Win?
    (https://www.youtube.com/watch?v=D3h62rgewZM)
36. Added: Davepl: Windows "Pinball" Easter Egg and Cheats
    (https://www.youtube.com/watch?v=EvCgpRs5BtA)
37. Added: Davepl: The Microsoft Employee Review Stack Ranking System
    (https://www.youtube.com/watch?v=wZfFIDXpVzQ)
38. Added: .NET GC Internals - 06. Compact phase
    (https://www.youtube.com/watch?v=ubNCZkl5I1U)
39. Added: Blazor WebAssembly : Virtualize Component - EP20
    (https://www.youtube.com/watch?v=UtmAlX6U29k)
40. Added: Davepl: Who Decides New Windows Features?
    (https://www.youtube.com/watch?v=F735bNdA3gc)
41. Added: .NET GC Internals - 07. Allocations
    (https://www.youtube.com/watch?v=oZWG-5P8O6k)
42. Added: Black to the Future - Angie Jones
    (https://www.youtube.com/watch?v=CH2AhBG_KcY)
43. Added: Intro to Graphics 09 - Curves (Part 1)
    (https://www.youtube.com/watch?v=6jjLSkp0Y7I)
44. Added: JavaScript Automated Testing with Jest - The What, Why, and How with Alba Silvente
    (https://www.youtube.com/watch?v=UukCbeW-IPc)
45. Added: How to Multitask with FreeRTOS (ESP32 + Arduino series)
    (https://www.youtube.com/watch?v=WQGAs9MwXno)
46. Added: .NET GC Internals - 08. Generations
    (https://www.youtube.com/watch?v=K3uaXipc1xQ)
47. Added: How I Automated the Boring with JavaScript, Cloudflare Workers, and Airtable
    (https://www.youtube.com/watch?v=tFQ2kbiu1K4)
48. Added: Blazor WebAssembly : JavaScript Isolation - EP21
    (https://www.youtube.com/watch?v=tbNgLNZnNWM)
49. Added: WSL2, Visual Studio Code, Windows 10, Ubuntu/Linux + more - Computer Stuff They Didn't Teach You #19
    (https://www.youtube.com/watch?v=Owrk9UxnMdI)
50. Added: Blazor WebAssembly - Downloading Files : EP19
    (https://www.youtube.com/watch?v=qUbbtcZZqaI)
51. Added: 5 Tips For Crushing Your Developer Interviews
    (https://www.youtube.com/watch?v=OCon6U10jlI)
52. Added: The Path to Becoming a Software Developer with Mary Baker
    (https://www.youtube.com/watch?v=Z2y1uGIopTc)
53. Added: The Hottest New Tech in Web Development with Scott Tolinski
    (https://www.youtube.com/watch?v=5oWjyiEU-YA)
54. Added: Intro to Graphics 08 - WebGL
    (https://www.youtube.com/watch?v=je_PhVKJYng)
55. Added: Davepl: Microsoft Company Meetings of the 1990s
    (https://www.youtube.com/watch?v=e4hofq1xC0E)
56. Added: Designer AND Developer -  Amy Dutton Can Do It All!
    (https://www.youtube.com/watch?v=GEqbVdfqXCY)
57. Added: What is the Cloud? Soft and Fluffy Edition - Computer Stuff They Didn't Teach You #10
    (https://www.youtube.com/watch?v=BO6jvQ88ICQ)
58. Added: Linux vs Windows Round 0: A Microsoft Dev Builds the Linux Kernel
    (https://www.youtube.com/watch?v=a6uR-iGVh7k)
59. Added: Quokka.js VS Code Extension - The Fastest Way to Test JavaScript
    (https://www.youtube.com/watch?v=yeZa4QsX38w)

Generation took: 00:12:04.6481324
 Maintenance update - cleaning up homepage and feed

---
## [flibber-hk/HollowKnight.RandomizerMod@56a9a733cf...](https://github.com/flibber-hk/HollowKnight.RandomizerMod/commit/56a9a733cf3f7d8b4cdee3ccd3d2d820f9a849b2)
##### 2021-03-27 20:58:41 by flibber-hk

Fix cursed bug with lifeblood rando

The altobjectname property affects Shape of Unn and Defender's Crest if you do not pick them up when they first spawn

---

# [<](2021-03-26.md) 2021-03-27 [>](2021-03-28.md)

