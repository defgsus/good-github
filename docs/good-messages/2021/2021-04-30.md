# [<](2021-04-29.md) 2021-04-30 [>](2021-05-01.md)

4,259,828 events, 1,367,449 push events, 2,165,183 commit messages, 168,062,343 characters


## [rdparker/nix-doom-emacs@874f689f75...](https://github.com/rdparker/nix-doom-emacs/commit/874f689f75584a5fbef579ab51884a5104e870d0)
##### 2021-04-30 00:27:06 by github-actions[bot]

test/doom.d/init.el: Updating from hlissner/doom-emacs - 437c33a8

### Changes for test/doom.d/init.el

```diff
--- 
+++ 
@@ -111,7 +111,8 @@
 
        :lang
        ;;agda              ; types of types of types of types...
-       ;;cc                ; C/C++/Obj-C madness
+       ;;beancount         ; mind the GAAP
+       ;;cc                ; C > C++ == 1
        ;;clojure           ; java with a lisp
        ;;common-lisp       ; if you've seen one lisp, you've seen them all
        ;;coq               ; proofs-as-programs
@@ -124,6 +125,7 @@
        emacs-lisp        ; drown in parentheses
        ;;erlang            ; an elegant language for a more civilized age
        ;;ess               ; emacs speaks statistics
+       ;;factor
        ;;faust             ; dsp, but you get to keep your soul
        ;;fsharp            ; ML stands for Microsoft's Language
        ;;fstar             ; (dependent) types and (monadic) effects and Z3
@@ -138,9 +140,8 @@
        ;;julia             ; a better, faster MATLAB
        ;;kotlin            ; a better, slicker Java(Script)
        ;;latex             ; writing papers in Emacs has never been so fun
-       ;;lean
-       ;;factor
-       ;;ledger            ; an accounting system in Emacs
+       ;;lean              ; for folks with too much to prove
+       ;;ledger            ; be audit you can be
        ;;lua               ; one-based indices? one-based indices
        markdown          ; writing docs for people to ignore
        ;;nim               ; python + lisp at the speed of c
@@ -159,7 +160,7 @@
        ;;(ruby +rails)     ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
        ;;rust              ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
        ;;scala             ; java, but good
-       ;;scheme            ; a fully conniving family of lisps
+       ;;(scheme +guile)   ; a fully conniving family of lisps
        sh                ; she sells {ba,z,fi}sh shells on the C xor
        ;;sml
        ;;solidity          ; do you need a blockchain? No.
@@ -167,6 +168,7 @@
        ;;terra             ; Earth and Moon in alignment for performance.
        ;;web               ; the tubes
        ;;yaml              ; JSON, but readable
+       ;;zig               ; C, but simpler
 
        :email
        ;;(mu4e +gmail)

```

---
## [TenteEEEE/S3Sampler@2eaf927520...](https://github.com/TenteEEEE/S3Sampler/commit/2eaf9275201d8c305d0ba4ab6930b7e1bb8f84ab)
##### 2021-04-30 01:20:17 by TenteEEEE

updated: 20210430. New:ESAI - Caffeine Kitty by abcbadq, Warak - REANIMATE by cerret & Nolanimations, fallen shepherd - ENDYMION by Soba`s & Artjoms, Igorrr - Absolute Psalm by FatBeanzoop, BlackY - ULT!MATE END by Helloiamdaan & RocKz, Camellia - Light It Up by cat_using_a_toaster, Schwank and Tanger - Emanation by Jaack, Kanaria - Envy Baby by CoolingCloset & Nolanimations, DJ Genki - LOVE SPICE LIKE U!!! by altrewin, DJ Genki - Toymatic Parade by cerret, Lektrique x Sam Lamar - Black Magic by A Jhintleman, DJ Myosuke - Collapse Of Ego by Helloiamdaan, P*Light - Nirvana by abcbadq, AJR - Bang! by BrightKnight, ikaruga_nex - HellFire by abcbadq & Timbo, USAO - USAO ULTIMATE HYPER MEGA MIX by Edmard, ReeK - Weeaboo Spookfest by Schwank, USAO - Last Kingdom by Uninstaller, Lapix - Labyrinth by Shappy & Checkthepan, Camellia - GHOST by Foxy vs. Narwhal, Camellia - Dyscontrolled Galaxy by That_Narwhal

---
## [techytoes/cockroach@f2c2f2e3db...](https://github.com/techytoes/cockroach/commit/f2c2f2e3dbbb52ff08fd30d4c533695c491103d8)
##### 2021-04-30 03:11:59 by craig[bot]

Merge #64060

64060: kvserver: fix delaying of splits with uninitialized followers r=erikgrinaker a=tbg

Bursts of splits (i.e. a sequence of splits for which each split splits
the right-hand side of a prior split) can cause issues. This is because
splitting a range in which a replica needs a snapshot results in two
ranges in which a replica needs a snapshot where additionally there
needs to be a sequencing between the two snapshots (one cannot apply
a snapshot for the post-split replica until the pre-split replica has
moved out of the way). The result of a long burst of splits such as
occurring in RESTORE and IMPORT operations is then an overload of the
snapshot queue with lots of wasted work, unavailable followers with
operations hanging on them, and general mayhem in the logs. Since
bulk operations also write a lot of data to the raft logs, log
truncations then create an additional snapshot burden; in short,
everything will be unhappy for a few hours and the cluster may
effectively be unavailable.

This isn't news to us and in fact was a big problem "back in 2018".
When we first started to understand the issue, we introduced a mechanism
that would delay splits (#32594) with the desired effect of ensuring
that, all followers had caught up to ~all of the previous splits.
This helped, but didn't explain why we were seeing snapshots in the
first place.

Investigating more, we realized that snapshots were sometimes spuriously
requested by an uninitialized replica on the right-hand side which was
contacted by another member of the right-hand side that had already been
initialized by the split executing on the left-hand side; this snapshot
was almost always unnecessary since the local left-hand side would
usually initialize the right-hand side moments later.  To address this,
in #32594 we started unconditionally dropping the first ~seconds worth
of requests to an uninitialized range, and the mechanism was improved in
 #32782 and will now only do this if a local neighboring replica is
expected to perform the split soon.

With all this in place, you would've expected us to have all bases
covered but it turns out that we are still running into issues prior
to this PR.

Concretely, whenever the aforementioned mechanism drops a message from
the leader (a MsgApp), the leader will only contact the replica every
second until it responds. It responds when it has been initialized via
its left neighbor's splits and the leader reaches out again, i.e.  an
average of ~500ms after being initialized. However, by that time, it is
itself already at the bottom of a long chain of splits, and the 500ms
delay is delaying how long it takes for the rest of the chain to get
initialized.  Since the delay compounds on each link of the chain, the
depth of the chain effectively determines the total delay experienced at
the end. This would eventually exceed the patience of the mechanism that
would suppress the snapshots, and snapshots would be requested. We would
descend into madness similar to that experienced in the absence of the
mechanism in the first place.

The mechanism in #32594 could have helped here, but unfortunately it
did not, as it routinely missed the fact that followers were not
initialized yet. This is because during a split burst, the replica
orchestrating the split was typically only created an instant before,
and its raft group hadn't properly transitioned to leader status yet.
This meant that in effect it wasn't delaying the splits at all.

This commit adjusts the logic to delay splits to avoid this problem.
While clamoring for leadership, the delay is upheld. Once collapsed
into a definite state, the existing logic pretty much did the right
thing, as it waited for the right-hand side to be in initialized.

Closes #61396.

cc @cockroachdb/kv

Release note (bug fix): Fixed a scenario in which a rapid sequence
of splits could trigger a storm of Raft snapshots. This would be
accompanied by log messages of the form "would have dropped incoming
MsgApp, but allowing due to ..." and tended to occur as part of
RESTORE/IMPORT operations.


Co-authored-by: Tobias Grieger <tobias.b.grieger@gmail.com>

---
## [SpenceKonde/megaTinyCore@9180c05214...](https://github.com/SpenceKonde/megaTinyCore/commit/9180c052147143bdc33ff745974707560a74571e)
##### 2021-04-30 06:11:19 by Spence Konde

Whoever wrote this original code should be ashamed (#400)

This was code from a case where I was told that the official core fixed this bug already, There's a huge problem with wire, you need to get the fix in before the next release (which I was in the process of releasing) with Wire. Okay, well, the official core is going to work without a hitch, I guess I'll go grab it. And there was a problem. what I wound up getting wasn't complete and was even worse, so I had to do another emergency release to fix it.....

Having had a deep dive into how the fuck you're supposed to calculate the baud value to use, It looks to me like they didn't even TRY or THINK at any point in the process of writing that code. And, well, when you don't try to do it right and do a bunch of stuff in silly and/or naïve ways the result, you get crap.

Can you test this code out and see if it actually works? I don't want to do another release that shits on Wire,  but I also don't have a dedicated wire test rig - I should have one for tinyAVR and Dx both... But  I should have a lot of things that I won't have time to build any time soon.

---
## [Cassandrameeleus/Wiccanworld@54da0faf20...](https://github.com/Cassandrameeleus/Wiccanworld/commit/54da0faf2063defd07259266da9bc1929ce4d91b)
##### 2021-04-30 07:29:34 by Cassandrameeleus

Create Pasiphae.FUNDING.yml

SELENE was the Titan goddess of the moon. Hekaté was the Goddess of Witchcraft & magic & Pasiphaê was also an early Creten moon Goddess. 

Pasiphaê (aka: Cassandra) was the 1st MOON GODDESS. She was married to Minotaur & bore a son, (half man and half BULL) Taurus. 
Pasiphaê, Hekaté and Seleně (also known as CASSANDRA) ALL were MOON GODDESSES. 

The Seven Sisters are revered throughout the world as a beacon of light and creation for humanity. Many cultures have celebrated these celestial star beings including the Greek, Irish, Celts and the Japanese. Also the Mayans, Aztecs, Sioux, Kiowanees and the Cherokees. The Seven Sisters are celebrated all over the world! This small star cluster is revered and holds great mystery and power & is located in the rear-end of Taurus even though Plaides tries to claim the girls. No naked eye can see all 7 stars but to the highly trained eye such as mine, I'm able to see 5 of them quite clearly. The 7 sisters intelligence reflects itself into human form to help raise the vibration of humanity and accelerate consciousness in all, Nurturing the Mother principle in the whole womb of creation. 
The seven sisters are reflecting data in the form of light streams into this digital tool to catalyze a deep collective awakening and a higher understanding of the unified field. The gifts that are activated by the frequencies of the seven sisters are Creativity, Pineal gland awakening, access to the Akashic Records, time travel, inter dimensional viewing, precognition, telepathy, Excentuating the 6th sense and empathic clairvoyance. Also, Quantum Teleportation, traveling through the Astral planes and more! 

References:
Starsinger/seven7sisters prophecy
www.quantumfrequencytechnologies.com
 
@hekate_pasiphae_selene (Instagram)
Www.facebook.com/anysoldiersgirl 
⋆Cassandra Meeleus-Jansen 
(520)369-6240  
1365 W. Grant Rd. 
Tucson, AZ 85745 - 1407
Cassandrameeleus@gmail.com 
Meeleusjansenmommy@yahoo.com
@hekate_pasiphae_selene (Instagram)
Www.facebook.com/anysoldiersgirl 
Bide the Wiccan law ye must, in perfect love and perfect trust. 
8 words the Rede fulfill, 
and ye harm none, 
DO AS YE WILL. 
WHAT YOU PUT FORTH COMES BACK TO THEE
so ever mind the RULE OF THREE.
Follow this with mind & heart, 
Merry ye meet & merry ye part. SELENE was the Titan goddess of the moon. Hekaté was the Goddess of Witchcraft & magic & Pasiphaê was also an early Creten moon Goddess. 

Pasiphaê (aka: Cassandra) was the 1st MOON GODDESS. She was married to Minotaur & bore a son, (half man and half BULL) Taurus. 
Pasiphaê, Hekaté and Seleně (also known as CASSANDRA) ALL were MOON GODDESSES.

---
## [Codecademy/client-modules@c4643db64d...](https://github.com/Codecademy/client-modules/commit/c4643db64d3684319f8d5fc6f68d05197ec1f61e)
##### 2021-04-30 13:03:28 by Aaron Robb

feat(Buttons): ColorModes + Props + Refactor + Refs Oh My! [GM-211] [REACH-856] [GM-192]

* Buttons now use `ButtonBase` to match with `Anchor`.
* Removes extra tagged templates to reduce Emotion Label spam and reduces internal style overhead.
* Button Colors are now serialized as variables inside of the base component depending on which mode they are.
* Buttons will now default to the current ColorMode if they have not been passed a prop.
* Also fixes a prop forwarding bug with CTAButton where inner component was not getting props forwarded.
* Adds all button types to the ColorMode example (small and large).
* Buttons now will use the current mode in context unless specified otherwise. Since all dark mode buttons are specifically configured this way there should be no changes to ANY existing button colors.
* Buttons now come with a few system props to make life easier including spacing layout and positioning. See prop reference here https://gamut.codecademy.com/storybook/?path=/docs/foundations-system-props--layout. Please note that these will cause issues with behavior if used incorrectly. Changes to display and padding may break button styles in some cases.
* All Buttons now accept a ref!

---
## [pytorch/pytorch@662c794b80...](https://github.com/pytorch/pytorch/commit/662c794b806c638ab8e1f8b3f9ebed477dbed8aa)
##### 2021-04-30 18:22:32 by Brian Hirsh

Update on "[codegen] split out backend-specific information from NativeFunction in the model"

Data model change in the codegen, which splits backend-specific information out of `NativeFunction`

### Overview
Currently in the codegen, native_functions.yaml has backend-specific information about each operator that is encoded directly into the data model, in the `NativeFunction` object. That's reasonable, since the native_functions.yaml is the source of truth for information about an operator, and the data model encodes that information into types.

Now that external backends can use the codegen though, that information is technically incomplete/inaccurate. In another PR, I tried patching the information on the `NativeFunction` object with the additional external information, by updating the `dispatch` entry to contain the external backend kernel name and dispatch key.

Instead, this PR tries to split out that information. The `NativeFunction` class contains all information about an operator from native_functions.yaml that it backend-independent and is known never to change regardless of what extra information backends provide. We also build up a backend "index", which is basically a mapping from [backend] -> [backend-specific-metadata]. Reading in external backend metadata just involves updating that index with the new backend.

There were a few places where `NativeFunction` used the dispatch table directly, that I encoded as properties directly on the NativeFunction object (e.g. `is_abstract`). They were mostly around whether or not the operator has a composite kernel, which isn't something that's going to change for any external backends.

This has two advantages:
- We can more easily re-use the existing logic in `native_function.py` and `register_dispatch_key.py` for both native and external backends, since they both involve a NativeFunction + a particular backend index
- The data in the data model will be the same regardless of how the codegen is run. Running the codegen with a new external backend doesn't change the data inside of NativeFunction or an existing backend index. It just adds a new index for that backend.

An alternative to this split would be to augment the NativeFunction objects with external backend information at the time that we create them. So the external codegen could read both native_functions.yaml and the external backend's yaml at the same time, and construct a NativeObject with a full dispatch table (including the XLA entry), and the correct setting of structured (taking into account both yamls). One disadvantage to this approach is that NativeFunction objects now contain different stuff depending on how you ran the codegen, and you have to make sure that any changes to the codegen can properly handle all the different variants.

### Data Model Changes
Removed 3 classes, which are used by the external codegen:
- ExternalBackendFunction
- ExternalBackendFunctionsGroup
- ExternalBackendMetadata

And added two new ones:
- BackendIndex
- BackendMetadata

`BackendIndex` contains any info that's specific to that backend, plus a mapping from operator names to backend specific metadata about the operator. One example of backend-specific info that's not operator-dependent is the fact that XLA prefers to implement functional kernels instead of out kernels (and so when they eventually mark an op as structured, they're going to mark the functional op and not the out op).

`BackendMetadata` contains info specific to an (operator, backend) pair. Right now, that's just (a) the name of the kernel, and (b) whether or not that operator is structured.


### Questions
I wanted to get this PR up earlier so I could get feedback, but there are a few things I want to call out:


**Dealing with `structured`.**
This PR separates out the notion of `structured` into two bits of information:
- Does [operator] have a meta() function. This is backend-agnostic, and is represented by the `structured` property on `NativeFunction`, same as before. This is used, e.g., to decide what signatures to add to `MetaFunctions.h`.
- Does [operator, backend] have an impl() function. This is backend dependent; even though technically all in-tree backends are forced to write impl() functions for an operator when we port the op to structured in native_functions.yaml, out-of-tree backends can decide to opt in independently. This is represented as a property on `BackendMetadata`. This is used in most other cases, e.g. in `RegisterDispatchKey` when we're deciding whether or not to gen a structured or unstructured wrapper.

I also baked `is_structured_dispatch_key` directly into each BackendIndex. So for operators marked "structured" in native_functions.yaml, their corresponding CPU/CUDA BackendIndex entries will be marked structured, and all others (except for potentially external backends) will not.

I ended up trying to deal with `structured` in this change since it's technically backend dependent (XLA can opt kernels into structured separately from in-tree ops), but that may have been too ambitious: it's technically not relevant until we actually add support for structured external kernels. If it's not clear that this is the right path for dealing with structured and we want to push that off, I'm fine with backing out the bits of this PR that make `structured` backend-dependent.


**Localizing the fact that external backends follow Dispatcher convention.**
Another thing that's sort of backend specific that I didn't totally address in this PR is the fact the fact that in-tree backends follow the Native API while external backends follow the Dispatcher API. I painted over that in `native_functions.py` by adding a helper, `kernel_signature`, that takes in a native function and gives you the "correct" signature for the specified backend- NativeSignature for in-tree backends, and DispatcherSignature for out-of-tree backends. In order to make that fully useable though, we'll need `NativeSignature` and `DispatcherSignature` to have matching interfaces. I didn't bother with that in this PR, which is why `gen_external_aten_fallbacks.py` still has a bunch of direct references to the dispatcher API. Thinking of adding it in a later PR but wanted to see if anyone has other opinions.


**Thoughts on the `BackendIndex` / `BackendMetadata` breakdown.**
One thing that's annoying right now is that to query for various pieces of metadata, you call helper functions like `backend_index.structured(f)`, which queries that particular backend and tells you if that specific NativeFunctionGroup is structured for that backend. It has to return an `Optional[bool]` though, since you have to handle the case where that operator doesn't have a kernel for that backend at all. So users of those helpers end up with a bunch of optionals that they need to unpack, even if they know at some point that the result isn't None. I think it would be easier instead to just store the NativeFunction object as a field directly on the BackendMetadata. Curious if there are any other opinions on a better way to model it though.





[ghstack-poisoned]

---
## [Admer456/Nail-Crescent@224f61eee3...](https://github.com/Admer456/Nail-Crescent/commit/224f61eee369e4bbdc03c04d17fd5d14fe020c7b)
##### 2021-04-30 18:38:20 by WatIsDeze

Fixed that ugly bug, I seriously hate touching msg.cpp..... FUCK YOU MSG.

---
## [MansurovB-source/ITMO-System-Software@5f8b125802...](https://github.com/MansurovB-source/ITMO-System-Software/commit/5f8b125802e3e313ede4c61f5eef5cc394f16880)
##### 2021-04-30 18:41:37 by Behruz Mansurov

almost implemented " cp"
1) "cp" - not to the end
2) "copy" (the function that is used in "cp" to copy files and directories) - almost implemented
3) "read_file_data" (the function that is used in "copy" to read data from files and directories) - almost implemented
4) "init_chunk_data" (if non-resident attribute) - data read is not implemented (must be implemented)

Conclusion: Today I worked very hard and fucked my brain, I hope that tomorrow I will finish this shit.

Thanks for your attention

---
## [Paturages/mbs3@4fe9a2710b...](https://github.com/Paturages/mbs3/commit/4fe9a2710b3e2c590d35b3eef4e0f118432fee5f)
##### 2021-04-30 21:22:08 by Paturages

my god this is the worst pile of shit I've written in a fucking while

---

# [<](2021-04-29.md) 2021-04-30 [>](2021-05-01.md)

