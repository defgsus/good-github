# [<](2021-06-07.md) 2021-06-08 [>](2021-06-09.md)

4,114,803 events, 1,458,760 push events, 2,375,755 commit messages, 179,685,897 characters


## [mikabe1805/englishhhhh@46cdf95aa3...](https://github.com/mikabe1805/englishhhhh/commit/46cdf95aa3c1a4e841c717529bd062f8021e777c)
##### 2021-06-08 03:14:16 by maria roberts

ke: well obviously she wants someone who has never danced here take both of my kids place

h: no the kids wanna dance, brooke said she-

a: do you guys hear that? NO YOU SAID-

ke: did you just sit here and say that my daughter looks miserable so maybe we should put kalani in her place

a: no i never said that

ke: yes you most certainly did

a: NO I DIDNT DINGBAT, LISTEN, I SAID ‘brooke is your mother ke: GET YOUR FINGER OUT OF MY FACE speaking for you or do you want to be here?’

abby tries to eat kelly’s finger, kelly slaps abby

h: girls out the room. GIRLS OUT THE ROOM. OUT THE ROOM GIRLS OUT OF THE ROOM

c: oh my gawd

ke: get off of me

h: OUT THE ROOM

ke: GET AWAY FROM ME

h: OUT THE ROOM. GIRLS OUT OF THE ROOM RIGHT NOW

ke: who do you think you are?

h: GIRLS OUT OF THE ROOM

a: you are nuts

h: ALL OF YOU, OUT OF THE ROOM

ke: no you are nuts

a: youre nuts

h: NOW, OUT OF THE ROOM. MADDIE YOU TOO, ALL OF YOU OUT OF THE ROOM. NO ALL OF YOU

a: she’s crazy

ke: NO IM NOT CRAZY YOURE EATING MY FACE

h barreling through abby: gotta get out of the room. gotta get out the room. no absolutely not

a: call the police, RIGHT NOW

ke: go ahead. you were comin at me

hin the background: all of you

---
## [guohao117/vim-dracula@869f70a760...](https://github.com/guohao117/vim-dracula/commit/869f70a7603b77cdb2f63983dd286f3f61b7a966)
##### 2021-06-08 05:35:42 by D. Ben Knoble

change SpecialKey to DraculaPink (vim only) (#252)

Related: #192, #210, #248

Also #247 is about `NonText`, which needs investigating.

Issues: `:digraphs`, special keys in `:map` output, and certain parts of
`'listchars'` are "subtle" and hard to read (esp. w/ `cursorline` over
them). Also, vim uses `SpecialKey` for them (instead of `Whitespace` for
`'listchars'` and `SpecialKey` elsewhere, like NeoVim).

Fix: make `SpecialKey` more like special keys (the highlight in vimscript
for, e.g., `map <Space> :echo "hello"<CR>`). This has the side effect of
making digraphs more visible. It also makes certain `'listchars'` pink,
which may be annoying. But there is no way currently to separate the two
in vim.

Rationale: It matches with the special keys in maps. The fact that vim
uses it elsewhere may simply be "wrong" and need changed.

If you don't like it: well, as usual, you can use an autocommand to use
whatever colors you want (`:help dracula-customization`).

---
## [PowerfulBacon/BeeStation-Hornet-Bacons-Fork@1405821172...](https://github.com/PowerfulBacon/BeeStation-Hornet-Bacons-Fork/commit/1405821172a86f948711881af641b9d384719ab2)
##### 2021-06-08 08:51:12 by bluezorua

adds a new clown mask, the madman, a madness combat reference (#4356)

* funni reference

* fixes bug

* oh fuck oh shit im stupid

---
## [ejohn17/COSC-322-Amazons-Chess@7ed141007e...](https://github.com/ejohn17/COSC-322-Amazons-Chess/commit/7ed141007eb31ec80177deb699b94c24e5fd2aa4)
##### 2021-06-08 13:18:14 by GrandTheftWalrus

Did a whole shitload of piss

Well I didn't technically do that much but it definitely took like 8 hours. I fixed the god damn 3 problem, which was caused by mutation errors. For some reason using Arrays.copyOf() wouldn't fix the problem. No idea why. But anyway, writing my own .copyOf() fixed it, somehow. The MCTS actually runs and makes decisions, but the decisions are still random due to the simulation method always returning the same result. It does this whether it's my simulation method or the one Nick wrote, for some reason, except Nick's always returns 0 and mine always returns either 1 or -1 depending on which team the AI is on. So, we'll have to fix that and then we might have a functioning AI.

---
## [kernel-patches/bpf@53247540fc...](https://github.com/kernel-patches/bpf/commit/53247540fc3f8655471a2d9989b8c67630d94c8d)
##### 2021-06-08 20:15:24 by Maciej Żenczykowski

bpf: do not change gso_size during bpf_skb_change_proto()

This is technically a backwards incompatible change in behaviour,
but I'm going to argue that it is very unlikely to break things,
and likely to fix *far* more then it breaks.

In no particular order, various reasons follow:

(a) I've long had a bug assigned to myself to debug a super rare kernel
crash on Android Pixel phones which can (per stacktrace) be traced back
to bpf clat ipv6 to ipv4 protocol conversion causing some sort of ugly
failure much later on during transmit deep in the GSO engine, AFAICT
precisely because of this change to gso_size, though I've never been able
to manually reproduce it.
I believe it may be related to the particular network offload support
of attached usb ethernet dongle being used for tethering off of an
IPv6-only cellular connection.  The reason might be we end up with more
segments than max permitted, or with a gso packet with only one segment...
(either way we break some assumption and hit a BUG_ON)

(b) There is no check that the gso_size is > 20 when reducing it by 20,
so we might end up with a negative (or underflowing) gso_size or
a gso_size of 0.  This can't possibly be good.
Indeed this is probably somehow exploitable (or at least can result
in a kernel crash) by delivering crafted packets and perhaps triggering
an infinite loop or a divide by zero...
As a reminder: gso_size (mss) is related to mtu, but not directly
derived from it: gso_size/mss may be significantly smaller then
one would get by deriving from local mtu.  And on some nics (which
do loose mtu checking on receive, it may even potentially be larger,
for example my work pc with 1500 mtu can receive 1520 byte frames
[and sometimes does due to bugs in a vendor plat46 implementation]).
Indeed even just going from 21 to 1 is potentially problematic because
it increases the number of segments by a factor of 21 (think DoS,
or some other crash due to too many segments).

(c) It's always safe to not increase the gso_size, because it doesn't
result in the max packet size increasing.  So the skb_increase_gso_size()
call was always unnecessary for correctness (and outright undesirable, see
later).  As such the only part which is potentially dangerous (ie. could
cause backwards compatibility issues) is the removal of the
skb_decrease_gso_size() call.

(d) If the packets are ultimately destined to the local device, then
there is absolutely no benefit to playing around with gso_size.
It only matters if the packets will egress the device.  ie. we're
either forwarding, or transmitting from the device.

(e) This logic only triggers for packets which are GSO.  It does not
trigger for skbs which are not GSO.  It will not convert a non-GSO mtu
sized packet into a GSO packet (and you don't even know what the mtu is,
so you can't even fix it).  As such your transmit path must *already* be
able to handle an mtu 20 bytes larger then your receive path (for ipv4
to ipv6 translation) - and indeed 28 bytes larger due to ipv4 fragments.
Thus removing the skb_decrease_gso_size() call doesn't actually increase
the size of the packets your transmit side must be able to handle.
ie. to handle non-GSO max-mtu packets, the ipv4/ipv6 device/route mtus
must already be set correctly.  Since for example with an ipv4 egress mtu
of 1500, ipv4 to ipv6 translation will already build 1520 byte ipv6 frames,
so you need a 1520 byte device mtu.  This means if your ipv6 device's
egress mtu is 1280, your ipv4 route must be 1260 (and actually 1252,
because of the need to handle fragments).  This is to handle normal non-GSO
packets.  Thus the reduction is simply not needed for GSO packets,
because when they're correctly built, they will already be the right size.

(f) TSO/GSO should be able to exactly undo GRO: the number of packets
(TCP segments) should not be modified, so that TCP's mss counting works
correctly (this matters for congestion control).
If protocol conversion changes the gso_size, then the number of TCP segments
may increase or decrease.  Packet loss after protocol conversion can result
in partial loss of mss segments that the sender sent.  How's the sending
TCP stack going to react to receiving ACKs/SACKs in the middle of the
segments it sent?

(g) skb_{decrease,increase}_gso_size() are already no-ops for GSO_BY_FRAGS
case (besides triggering WARN_ON_ONCE). This means you already cannot
guarantee that gso_size (and thus resulting packet mtu) is changed.
ie. you must assume it won't be changed.

(h) changing gso_size is outright buggy for UDP GSO packets, where framing
matters (I believe that's also the case for SCTP, but it's already excluded
by [g]).  So the only remaining case is TCP, which also doesn't want it
(see [f]).

(i) see also the reasoning on the previous attempt at fixing this
(commit fa7b83bf3b156c767f3e4a25bbf3817b08f3ff8e) which shows
that the current behaviour causes TCP packet loss:

  In the forwarding path GRO -> BPF 6 to 4 -> GSO for TCP traffic, the
  coalesced packet payload can be > MSS, but < MSS + 20.

  bpf_skb_proto_6_to_4() will upgrade the MSS and it can be > the payload
  length. After then tcp_gso_segment checks for the payload length if it
  is <= MSS. The condition is causing the packet to be dropped.

  tcp_gso_segment():
    [...]
    mss = skb_shinfo(skb)->gso_size;
    if (unlikely(skb->len <= mss)) goto out;
    [...]

Thus changing the gso_size is simply a very bad idea.
Increasing is unnecessary and buggy, and decreasing can go negative.

Cc: Dongseok Yi <dseok.yi@samsung.com>
Cc: Daniel Borkmann <daniel@iogearbox.net>
Cc: Willem de Bruijn <willemb@google.com>
Fixes: 6578171a7ff0 ("bpf: add bpf_skb_change_proto helper")
Signed-off-by: Maciej Żenczykowski <maze@google.com>

---

# [<](2021-06-07.md) 2021-06-08 [>](2021-06-09.md)

