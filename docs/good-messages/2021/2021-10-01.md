# [<](2021-09-30.md) 2021-10-01 [>](2021-10-02.md)

3,192,086 events, 1,623,537 push events, 2,543,076 commit messages, 200,402,855 characters


## [Grimoors/UPGMA-PhylogeneticTree](https://github.com/Grimoors/UPGMA-PhylogeneticTree)@[12748322d2...](https://github.com/Grimoors/UPGMA-PhylogeneticTree/commit/12748322d2da666fd99c7840e33a2d6b3834843a)
#### Friday 2021-10-01 00:30:01 by Vivek Mathur

Completed the Project and Uploaded all files.

Good night... I mean morning, its 6 am IST , now... I havent slept... been working on this from 10 pm yesterday... :/ Gn lads and thanks for watchin remember to like comment and scrubscribe.

---
## [crawl/crawl](https://github.com/crawl/crawl)@[070a2a64fb...](https://github.com/crawl/crawl/commit/070a2a64fb29b2c910b5e7a89e561f090fa03f63)
#### Friday 2021-10-01 00:46:20 by Kate

Allow demons and holies to be feared/berserked

As part of an effort to reduce the number of effects that are restricted
to natural monsters only, to increase some of the distinctions between
undead/demonic/nonliving holinesses, and to allow some more flavourful
interactions.

Lore-wise, demons and holies are supposed to be of similar stock aside from
their god alignment, so are grouped together here. They're also established
to be like living creatures in a number of ways - they're generally
intelligent, can be poisoned, and have souls, so it feels appropriate for
them to feel emotions in some way and be able to go berserk and be feared.
(Importantly this also allows the zealot's sword to send divine allies
berserk, for any TSO worshippers who happen to find it.)

---
## [xolqz/copypasta-data](https://github.com/xolqz/copypasta-data)@[813feb24d0...](https://github.com/xolqz/copypasta-data/commit/813feb24d09916a22ea91873b210830605ac9c84)
#### Friday 2021-10-01 02:54:40 by xolqz

Delete reddit.txt

this shit ass i will come to ur house and break ur shins with a wind pipe u nasty white american, burger king diet fruit rioting head ass nigga ur body built like a four seat car u nasty bitch. love u :3

---
## [asbestoslawyer/asbestoslawyer.github.io](https://github.com/asbestoslawyer/asbestoslawyer.github.io)@[ba3c0cf091...](https://github.com/asbestoslawyer/asbestoslawyer.github.io/commit/ba3c0cf09182c3491e2db3fe758fbd065449768e)
#### Friday 2021-10-01 06:41:11 by asbestoslawyer

Mesothelioma Cancer Info: Asbestos Lawsuits Unquestionably the Top Tutorial As Regards to Asbestos
Even though asbestos lawsuits appreciated a lot of reputation through the ancient greek language and also Roman times it misplaced the position like a miraculous materials right up until the economic Trend During the industrial Wave individuals recognized the astonishing qualities associated with Asbestos lawsuits that made it a great insulator for your motors and heating system components within structures and also boats Thus it s not shock which asbestos lawsuits is indeed notable within traditional properties

The particular dangers of this kind of mineral are not understood for many years As a result this was adopted in countless components during the finest expanding amount of time in historical past the economic trend It s found these days within fine old buildings railways as well as cement Working with asbestos lawsuits exposed hundreds of thousands associated with individuals to airborne asbestos lawsuits It absolutely was originally difficult to identify wherever this disease came from due to the latency period Because of this those who have been subjected early in their life couldn t link the breathing in associated with asbestos lawsuits dust for their injuries The particular latency produced 20 and also occasionally fifty-year breaks from the amount of exposure to analysis This produced many problems in understanding explanation for mesothelioma This was not right up until insurance providers ceased insuring people who caused asbestos lawsuits which there was clearly a greater understanding of the sources of mesothelioma This kind of resulted in additional study into the risks of asbestos lawsuits

Within the building industry asbestos lawsuit was essentially an appreciated material through floor to be able to top prior to doctors as well as scientists realized the actual risks of these components Building workers plumbers electrical engineers as well as other construction-related workers additional asbestos lawsuits to be able to vinyl fabric flooring countertops padding fireplace doorways roofing tar residue roof covering ceramic tile as well as a great many other the different parts of constructing

Regrettably it absolutely was not before overdue 1950s in which doctors discovered the actual primary tie in between asbestos lawsuits and mesothelioma a deadly cancer that assaults the many designs with the body-lung coronary heart belly as well as testicles Additionally studies have additionally offered back links regarding asbestos lawsuits coverage and lung neck esophageal intestinal colorectal and also elimination cancers Thus once asbestos lawsuits has been banned in the nineteen-eighties many individuals experienced currently tried this carcinogen

Normal water along with asbestos lawsuits inside it allows you to especially prone to cancers relating to the particular mouth neck and digestive system This fabric can get into normal water whenever water-transporting products made up of asbestos lawsuits decay as time passes Specifically old drinking water mains had been usually built regarding asbestos lawsuits as well as bare concrete Through time the actual bare concrete actually starts to break up and release asbestos lawsuits into the water supply

asbestos lawsuitsis could be the expression used for the medical problem that one could get when inhaling asbestos lawsuits fibers Other ailments that could occur due to weighty contact with asbestos lawsuits fibers tend to be and also contracting any lung cancer Due to wellbeing outcomes of asbestos lawsuits the and usage of asbestos lawsuits products happen to be prohibited in Quarterly report in 1991 however ordinance about asbestos lawsuits removing and also government did not commence right up until 2006

asbestos lawsuits had been popular throughout the 60′s as well as seventies as well as a lot of the homes all of us are living have got asbestos lawsuits parts You can find asbestos lawsuits that contains components inside roofer shingles ceilings as well as ground ceramic tiles paper items and also cement products Some of these components might not present any kind of danger for your wellness whatsoever yet as soon as these types of improvements supplies tend to be broken an individual are more inclined prone to being infected along with asbestos lawsuits because the fibres turn out to be airborne and may even likely be taken in simply by the folks residing in the household

For many years asbestos lawsuits used to be the fabric of preference in building regarding structures It is a significant rugged and durable materials that was used to create structures upwards until about 1972-1975 Exactly why it s still dangerous right now is actually specifically as a result of release within air when more mature buildings tend to be ripped down buildings that covered this to begin with Should you bear in mind individuals prefab homes through previously additionally they used to include asbestos lawsuits Really these were known as asbestos lawsuits homes while they included this vitamin very much

Executive and custodial staff confront numerous dangers at work however most of these tend to be obvious as well as somewhat clear Mechanised power and substance risks are all regularly tackled and given typical upkeep agendas asbestos lawsuits nonetheless could be the silent killer and it is usually present without notice or even individuals knowledge of the reputation Signs of asbestos lawsuits coverage aren t instant and could take actually years to be able to appear yet when current they can be dangerous Here is why

Appropriate asbestos lawsuits awareness instruction may be the obligation of each business that properties staff It does not take very long to produce people alert to the possibility hazards as well as wise shields in this area An oz regarding prevention is still really worth a pound associated with cure

Check out our site about atlanta asbestos lawsuits to get more know-how when it comes to about mesothelioma asbestos lawsuits atlanta asbestos lawsuits asbestos attorney lawyer Mesothelioma western asbestos settlement trust in general

---
## [ryeenii/t80sz](https://github.com/ryeenii/t80sz)@[1cd772ba2c...](https://github.com/ryeenii/t80sz/commit/1cd772ba2c35651e16b82722482148734e114ecb)
#### Friday 2021-10-01 06:53:50 by ryeenii

webpack sucks

fuck webpack, all my homies hate webpack

---
## [Aashutoshbro/Hacktoberfest-2021](https://github.com/Aashutoshbro/Hacktoberfest-2021)@[2faaf94d40...](https://github.com/Aashutoshbro/Hacktoberfest-2021/commit/2faaf94d4023528e5f846f0d3bc54b84e9b1f8a4)
#### Friday 2021-10-01 08:10:34 by Aashutosh Sapkota

Create con_cat.js

concatenation using simple array technique, my lovely brothers and sisters names

---
## [neekless/nickel_kernel_wahoo](https://github.com/neekless/nickel_kernel_wahoo)@[615c7f7adf...](https://github.com/neekless/nickel_kernel_wahoo/commit/615c7f7adf2ba5c45108a0335f745ee9e7242cc4)
#### Friday 2021-10-01 11:10:25 by Paul E. McKenney

srcu: Parallelize callback handling

Peter Zijlstra proposed using SRCU to reduce mmap_sem contention [1,2],
however, there are workloads that could result in a high volume of
concurrent invocations of call_srcu(), which with current SRCU would
result in excessive lock contention on the srcu_struct structure's
->queue_lock, which protects SRCU's callback lists.  This commit therefore
moves SRCU to per-CPU callback lists, thus greatly reducing contention.

Because a given SRCU instance no longer has a single centralized callback
list, starting grace periods and invoking callbacks are both more complex
than in the single-list Classic SRCU implementation.  Starting grace
periods and handling callbacks are now handled using an srcu_node tree
that is in some ways similar to the rcu_node trees used by RCU-bh,
RCU-preempt, and RCU-sched (for example, the srcu_node tree shape is
controlled by exactly the same Kconfig options and boot parameters that
control the shape of the rcu_node tree).

In addition, the old per-CPU srcu_array structure is now named srcu_data
and contains an rcu_segcblist structure named ->srcu_cblist for its
callbacks (and a spinlock to protect this).  The srcu_struct gets
an srcu_gp_seq that is used to associate callback segments with the
corresponding completion-time grace-period number.  These completion-time
grace-period numbers are propagated up the srcu_node tree so that the
grace-period workqueue handler can determine whether additional grace
periods are needed on the one hand and where to look for callbacks that
are ready to be invoked.

The srcu_barrier() function must now wait on all instances of the per-CPU
->srcu_cblist.  Because each ->srcu_cblist is protected by ->lock,
srcu_barrier() can remotely add the needed callbacks.  In theory,
it could also remotely start grace periods, but in practice doing so
is complex and racy.  And interestingly enough, it is never necessary
for srcu_barrier() to start a grace period because srcu_barrier() only
enqueues a callback when a callback is already present--and it turns out
that a grace period has to have already been started for this pre-existing
callback.  Furthermore, it is only the callback that srcu_barrier()
needs to wait on, not any particular grace period.  Therefore, a new
rcu_segcblist_entrain() function enqueues the srcu_barrier() function's
callback into the same segment occupied by the last pre-existing callback
in the list.  The special case where all the pre-existing callbacks are
on a different list (because they are in the process of being invoked)
is handled by enqueuing srcu_barrier()'s callback into the RCU_DONE_TAIL
segment, relying on the done-callbacks check that takes place after all
callbacks are inovked.

Note that the readers use the same algorithm as before.  Note that there
is a separate srcu_idx that tells the readers what counter to increment.
This unfortunately cannot be combined with srcu_gp_seq because they
need to be incremented at different times.

This commit introduces some ugly #ifdefs in rcutorture.  These will go
away when I feel good enough about Tree SRCU to ditch Classic SRCU.

Some crude performance comparisons, courtesy of a quickly hacked rcuperf
asynchronous-grace-period capability:

			Callback Queuing Overhead
			-------------------------
	# CPUS		Classic SRCU	Tree SRCU
	------          ------------    ---------
	     2              0.349 us     0.342 us
	    16             31.66  us     0.4   us
	    41             ---------     0.417 us

The times are the 90th percentiles, a statistic that was chosen to reject
the overheads of the occasional srcu_barrier() call needed to avoid OOMing
the test machine.  The rcuperf test hangs when running Classic SRCU at 41
CPUs, hence the line of dashes.  Despite the hacks to both the rcuperf code
and that statistics, this is a convincing demonstration of Tree SRCU's
performance and scalability advantages.

[1] https://lwn.net/Articles/309030/
[2] https://patchwork.kernel.org/patch/5108281/

Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
[ paulmck: Fix initialization if synchronize_srcu_expedited() called first. ]
(cherry picked from commit da915ad5cf25b5f5d358dd3670c3378d8ae8c03e)

neekless: adapt

 Conflicts:
	include/linux/rcu_segcblist.h
	kernel/rcu/tree.c

---
## [freedesktop/drm-misc](https://github.com/freedesktop/drm-misc)@[4bb2d367a5...](https://github.com/freedesktop/drm-misc/commit/4bb2d367a5a2807185a04949ae922d247f650576)
#### Friday 2021-10-01 13:56:09 by Simon Ser

drm/lease: allow empty leases

This can be used to create a separate DRM file description, thus
creating a new GEM handle namespace.

My use-case is wlroots. The library splits responsibilities between
separate components: the GBM allocator creates buffers, the GLES2
renderer uses EGL to import them and render to them, the DRM
backend imports the buffers and displays them. wlroots has a
modular architecture, and any of these components can be swapped
and replaced with something else. For instance, the pipeline can
be set up so that the DRM dumb buffer allocator is used instead of
GBM and the Pixman renderer is used instead of GLES2. Library users
can also replace any of these components with their own custom one.

DMA-BUFs are used to pass buffer references across components. We
could use GEM handles instead, but this would result in pain if
multiple GPUs are in use: wlroots copies buffers across GPUs as
needed. Importing a GEM handle created on one GPU into a completely
different GPU will blow up (fail at best, mix unrelated buffers
otherwise).

Everything is fine if all components use Mesa. However, this isn't
always desirable. For instance when running with DRM dumb buffers
and the Pixman software renderer it's unfortunate to depend on GBM
in the DRM backend just to turn DMA-BUFs into FB IDs. GBM loads
Mesa drivers to perform an action which has nothing driver-specific.
Additionally, drivers will fail the import if the 3D engine can't
use the imported buffer, for instance amdgpu will refuse to import
DRM dumb buffers [1]. We might also want to be running with a Vulkan
renderer and a Vulkan allocator in the future, and GBM wouldn't be
welcome in this setup.

To address this, GBM can be side-stepped in the DRM backend, and
can be replaced with drmPrimeFDToHandle calls. However because of
GEM handle reference counting issues, care must be taken to avoid
double-closing the same GEM handle. In particular, it's not
possible to share a DRM FD with GBM or EGL and perform some
drmPrimeFDToHandle calls manually.

So wlroots needs to re-open the DRM FD to create a new GEM handle
namespace. However there's no guarantee that the file-system
permissions will be set up so that the primary FD can be opened
by the compsoitor. On modern systems seatd or logind is a privileged
process responsible for doing this, and other processes aren't
expected to do it. For historical reasons systemd still allows
physically logged in users to open primary DRM nodes, but this
doesn't work on non-systemd setups and it's desirable to lock
them down at some point.

Some might suggest to open the render node instead of re-opening
the primary node. However some systems don't have a render node
at all (e.g. no GPU, or a split render/display SoC).

Solutions to this issue have been discussed in [2]. One solution
would be to open the magic /proc/self/fd/<fd> file, but it's a
Linux-specific hack (wlroots supports BSDs too). Another solution
is to add support for re-opening a DRM primary node to seatd/logind,
but they don't support it now and really haven't been designed for
this (logind would need to grow a completely new API, because it
assumes unique dev_t IDs). Also this seems like pushing down a
kernel limitation to user-space a bit too hard.

Another solution is to allow creating empty DRM leases. The lessee
FD would have its own GEM handle namespace, so wouldn't conflict
wth GBM/EGL. It would have the master bit set, but would be able
to manage zero resources. wlroots doesn't intend to share this FD
with any other process.

All in all IMHO that seems like a pretty reasonable solution to the
issue at hand.

Note, I've discussed with Jonas Ådahl and Mutter plans to adopt a
similar design in the future.

Example usage in wlroots is available at [3]. IGT test available
at [4].

[1]: https://github.com/swaywm/wlroots/issues/2916
[2]: https://gitlab.freedesktop.org/mesa/drm/-/merge_requests/110
[3]: https://github.com/swaywm/wlroots/pull/3158
[4]: https://patchwork.freedesktop.org/series/94323/

Signed-off-by: Simon Ser <contact@emersion.fr>
Cc: Daniel Vetter <daniel.vetter@ffwll.ch>
Cc: Daniel Stone <daniels@collabora.com>
Cc: Pekka Paalanen <pekka.paalanen@collabora.co.uk>
Cc: Michel Dänzer <michel@daenzer.net>
Cc: Emil Velikov <emil.l.velikov@gmail.com>
Cc: Keith Packard <keithp@keithp.com>
Cc: Boris Brezillon <boris.brezillon@collabora.com>
Cc: Dave Airlie <airlied@redhat.com>
Acked-by: Pekka Paalanen <pekka.paalanen@collabora.com>
Reviewed-by: Daniel Stone <daniels@collabora.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20210903130000.1590-2-contact@emersion.fr

---
## [mrakgr/The-Spiral-Language](https://github.com/mrakgr/The-Spiral-Language)@[43b130ba18...](https://github.com/mrakgr/The-Spiral-Language/commit/43b130ba1836b616143c4d939e59f6567b737fc2)
#### Friday 2021-10-01 16:44:23 by Marko Grdinić

"9:45am. I had time to think about it over the night, and I think I am going to cut off Zenna after all. That stupid prank he pulled with reducing the quoted rate is a huge gaffe that humiliated me greatly. The whole negotiation process is completely messed up and I felt tilted the entire day.

This is happening because I am clinging to my old path so desperately instead of cutting it off decisively. Forget this shit. Right now the Internet is down so I can't check my email, but even if he offers me my minimum, I am going to walk away from this deal.

Let me reset the router.

When he pulled that stunt yesterday, I should have terminated the relationship out of principle. I'll do my own PPL on AI chips when the appropriate time comes.

9:55am. When I log back in I wonder what I will find?

* Will he have replied at all? If not, when will I hear from him? Tomorrow, next week, or in two weeks? How long should I wait?
* Will he try lowballing me again? Does he actually think that 2.5k is an appropriate price?
* Or will meet my asking price? What should I do in that case?

I had trouble sleeping last night because of this. He left me hanging for 3 weeks, took 5 days to reply to my email, and now I have to deal with this bullshit.

...Let me move to the slow connection. Agh, why is this happening?

10am. Got the cable right. I am online. Let me check the email. I am deading to see what I will find after my 3 outbursts yesterday. This is the opposite of how a business relationship should start.

Got a reply. He says he will consider it and get back to me. This makes my decision today really easy.

///

After thinking about it over the night, I've realized that I am not interested in pursuing the position nor working with you anymore. I should have replied this on principle after you moved rates 10x, which is a huge gaffe as an employer that you should strive to never make in the future. I am 95% sure to respond this way even if you had met my asking price today.

Let me just justify myself here so I do not look like a total moron for taking the 25k per month rate seriously for a full day.

My actual range for full time work would be 5-12k per month. Below 5k I would not accept, and above 12k I would never expect to get an offer. This is inline with the remote job ads you see posted online. Contract work would have a premium. For the sake of the following example, let me assume the premium is a generous 50%. Then the range would be 7.5-18. So an offer of 25k would still be closer (25/18) than the 10x lower offer (7.5/2.5) to my range.

When I saw your message originally I thought you might have added an extra zero by mistake, but then you seemed so certain that I'd be happy to accept which served to fuel my doubt in that hypothesis.

> Information on Julia's IR - https://docs.julialang.org/en/v1/devdocs/ssair/
> Nonstandard / contextual execution - https://github.com/JuliaLabs/Cassette.jl
> Tutorial on Type inference through abstract interpretation -  https://aviatesk.github.io/posts/data-flow-problem/
> Partial Evaluation and Abstract Interpretation (Mjolnir) - https://mikeinnes.github.io/2020/07/29/mjolnir.html

And you posted these links, suggesting that I should master this. Well, that is fine, but do you really expect a pro programmer to do this on 2.5k per month? So this served to further move my conjecture that the actual offer is 25k as unlikely as it seems. I actually expected that you would move it down after sanity kicked in, but not all the way to 2.5k.

Mastering Julia internals, macrology, PPLs and so on....you get it - this a difficult subject that would require me months of full time effort at the minimum. I could take an ASP.NET and SQL course, study them for half a week and be eligible for a range of jobs that start at 5k. No need to master deep aspects of a powerful, but difficult to use language like Julia. I just have to swallow my pride and be a code monkey.

Since 2015 I've consistently been programming for 6.5 years straight, and this episode is a good sign that I should stop clinging to my old path so desperately and take a break from programming to do that game (which is mostly a novel.) After that I'll return and take the usual path as a programmer of getting a low paid (5k/month) job, and using the experience to land me higher paid ones. I'll work on a PPL on AI chips when the appropriate time comes at my own leisure. No need to rush this.

Good luck in your research, and thank you for introing me to the book by Jaynes, I liked the perspective that prob theory is an extension of logic to handle uncertainty.

///

What is this style of negotiation where the other party is left waiting for days? I have better things to do with my time than negotiate one day at a time.

Thread closed. I do not like guessing so much what the other party is thinking. He should learn to be more punctual and up front in the future.

10:45am. Now let me move on with my life. The next is the PL sub review.

///

In September, though I should have been in job hunt mode, strangely enough, I spent most of the time studying Julia for the sake of probabilistic programming languages. I applied for an academic research engineering position at the end of August which was posted on this very sub. This was a mistake as the job fell through for the reason that the employer quoted a very high monthly rate and then corrected it down by 10x to half my minimum range the next day causing me a lot of whiplash. I'll be avoiding Julia research positions in the future.

Only bad things are happening due to the path I've chosen, so I am going to stop clinging so desperately to it and go the code monkey route of getting a 5k/month job and using that experience to iteratively get me something better. I am going to have to be decisive about this when the time comes. C#, Typescript, Python style backend jobs are the kind of plentiful wage slavery opportunities that I'll have to swallow my pride for and embrace.

Though I'll do that after doing some creative projects first. Who knows how long that will take. Hopefully forever.

--- Julia

I bad-mouthed it in the past on two separate occasions, but now that I've studied it closely, I can see its good and bad points more clearly. It is the kind of language whose good points are also its bad points. Julia is the kind of language which knows the virtue of power, but not the joy of slavery, so in the end it does not undestand power.

Good:

* Multiple dispatch.
* Macros. (Arguably.)
* Dynamic typing.

Bad:

* Multiple dispatch, macros, dynamic typing.

Julia is the best numerical computation language in the world. But as a general purpose language, it would have been better if it had been more restrained. For example, some of the PPL libraries like `Turing.jl` are close to impenetrable due to their use of macros. For most Julia code that would be of interest to me, I can't actually start up the debugger and step through it just to get a sense of even its control flow, like I could in most other languages.

I've heard that its compilation times can be bad, but I was surprised at how bad they are in some cases. When I installed `RDatasets.jl` for a `Plots.jl` example, just the precompilation took 62 minutes! I think I spent over 2h waiting in total. This killed my momentum for the day. And there wasn't a progress bar telling me how long the process would take so I was in the dark the entire time on how much time remains. I could have taken 5h or more for all I knew.

I do not think any of its flaws really matter if you are just using it in the REPL to do numerical computation. There it really shines. But for PL work I am not sure if I'd consider it better than Python, let alone functional languages like F#. Its powerful features encourage a baroque style of programming at scale.

--- Spiral

In 2016, I made a prediction when working on an F# library that if GPU-based ML libraries were so difficult to make in it, then the situation would only be worse when AI chips arrived at the scene. I conjectured that GPUs being so hard to handle was why Python was the only language that had a decent ML story. So I wanted a language that could solve that problem, so that I'd be ready to program at my maximum comfort when future hardware arrived.

I think Spiral v2 itself in its current form meets all my goals of being a powerful, easy to use general purpose language that ML libraries for any kind of novel device can be made in. To support programming them natively in a functional style, making a C backend for such devices that has ref counting would be less than a week of work that I do not feel like sinking into now. It would be a completely different story if I had access to such devices.

So the language work will be put on hiatus until the situation changes, and I'll use its [repo](https://github.com/mrakgr/The-Spiral-Language) as a blog as usual. It sure would be great if some company just sponsored this kind of work. I’ve tried applying, but haven’t gotten any interest.

--- Review of my experience in RL

Totaling up the time I did reinforcement learning in 2018 and now in 2021 comes to over a year. I tried so many tricks from higher order optimizers, to various kinds of different RL algorithms, some of which of my own invention. The end result is that none of them succeeded in improving on vanilla RL in ways that would be significant to my naked eyes.

For example, I praised distributional RL, but after trying it out I realized just how much having extra outputs in the final layer impacted memory consumption. So vanilla RL has one output, and distributional RL has 2k, what is the big deal?

Float32 (4) * Batch size (512) * Seq size (avg 8) * Num Actions (2k) * Num Dist Values (2k) = OH SHIT, I DON'T HAVE ENOUGH MEMORY!

I think I am missing something above because I remember the expenditure being in the terabytes. Ah, what I am missing is that because I was using a transformer instead of an RNN, I had to make the above calculation for every step in the sequence. The way to fix that is to recalculate the forward part which increased the total computation time by 50%.

Also, instead of taking a softmax over all the actions, because of distributional RL taking up so much memory I had to sample like 16 semi-randomly. This means introducing a MLP module on the top of the transformer instead of having a linear layer over all the actions. That hurt performance quite a bit. Categorical distributional RL is also slower to optimize during than expected RL which really hurts when combined with non-stationarity of poker, and how long Holdem takes in general to train.

Transformers have great performance in various different domains of ML.

For poker I brought them in so the GPU would have more work to do on longer sequences. In poker you tend to have mostly short betting streets with sporadic longer ones. GPUs don't like that, they like it when you batch everything. This is like cramming all the stuff into one big sandwich and shoving it into their mouth all at once. This actually presents significant difficulties just to get them to train on poker. I had to CPS the simulator to do checkpointing on every game node in order to batch the inputs. It would have been a lot easier to do it in online mode.

Due to how much memory they consume, I couldn't make the net have any bigger 5 (512 wide) transformer layers followed by 3 (512 wide) feedforward layers in the head module. I regret this.

I thought that bringing in transformers would improve generalization capabilities, but they never worked better than MLPs. I only succeeded in finding a novel architecture that is quite stable in RL, but it wasn't any better than the MLP in the end. That was a disappointment.

I am harping on distributional RL and transformers to showcase the theme I've been running into, in that much of what are presented as advancements are really domain specific tradeoffs and you can in no way assume that transformers > RNNs, and distributional RL > expected RL despite what the benchmarks show. This is a huge disappointment to me, to know that there are hidden costs the papers do not document.

For example, in 2018 I experimented a lot with KFAC which is a higher order optimizer, but decided against it in 2021 in favor of signSGD. Why? Because the performance improvement was not that notable, but it increased the implementation complexity by quite a lot. Also it was one thing to hack it myself in the old Spiral's library, but quite another to do it in PyTorch which is less flexible in comparison.

I kid you not, literally not a single thing despite a year of trying made RL unambiguously better other than using more computation.

Training on Holdem did not work for me. Just before I threw in the towel for the final time back in mid August, just what did I try that actually made it work better? Increasing the batch size implicitly by doing more runs in the simulator before the optimization step.

I owe an apology to OpenAI. Given their links to the rationalist community I held a grudge against them for wanting to help humanity, and then approaching the problem by just plowing more computation at the problem. I was actually mad when I read that their Dota agent used a batch size of 1 million. In my view, groups like Deepmind and OpenAI should be giving me better algorithms to use instead of putting on circus shows. So I made up my mind to show them how it is done.

But I just did not have the experiences of guys like Hinton of working on NNs since the 80s. I only entertained the conjecture that computation is everything - deep down I believed I should be able to find something to make things work better.

Now that I've experienced the harshness of RL, I sympathize with that position much more and I won't hold a grudge towards big research outfits for just using bigger computers and calling the problem solved. If they can make AGI that way, all the more power to them. By all means feel free.

--- Future Of Programming

The thing about NNs is that they are a special purpose thing. They are slow and bulky right now on the GPUs, but it will be different on AI chips. That would allow them to be used to do approximate memoization of simulators for example without slowing down the system by orders of magnitude like now.

What could I have done to actually make the Holdem agent work better without relying purely on the standard RL training?

One of the things is the same thing as AlphaGo - Monte Carlo Tree Search. If you do proper Bayesian conditioning and replacement in the simulator - much like CFR does, and use that likelihood information to weight the rewards, it is possible to make MCTS work even for hidden information games. Previously, CFR was extremely mysterious to me, but now I can almost see it being capable of being expressed as a probabilistic program sampling solely from categorical distributions. There are some missing pieces as far as variance reduction is concerned that none of the existing PPLs support, and sampling tabular CFR does provide a view on how credit propagation could work in nested probabilistic programs.

I got the idea only last month. There are some papers on using MCTS with hidden information games, but I haven't looked into them yet. Still, I can claim the achievement of understanding Bayesian inference enough to come up with this independently.

Another thing I could have done is have a net predict given a hand the % showdown vs a random opponent hand, both for the current and future streets. This is something you'd write a simulator for - given a hand, you just sample random opposing hands and run them forward for a bunch of iterations, then score them. At the end you get a win %. The NNs are really horrible at learning to hand read directly from the rewards, even with 100s of millions of hands I still got a 10-20% error rate where it asymptotes.

A NN could be trained in a supervised fashion to memoize this. Right now this would be slower than actually running the simulator, but it should be faster on future hardware. Doing it in a supervised fashion against a lower variance target should help things greatly. And in the RL agent replacing the hand features with the current and future win % estimate would help sample efficiency greatly.

The same goes for MCTS. Just using the simulator for it would run into a combinatorial explosion, but using a NN based policy net would give the needed memoization to work around that. This scheme would give me decent players from the start. I expected they wouldn't be folding flushes and trips to a single bet on the flop or get stuck in weird behavioral local minima. Since the sequence steps are short in poker for each hand, it might be a better choice than training a value net for many steps.

Even if I did that though, it would still have the same computational intensity as regular RL. For much the same reason I haven't tried something like using a GAN on raw inputs before passing them onto the RL module. Instead of 10k hands like now, I'd have gotten 1k hands per second in that case. I just don't have any reason to think GANs could learn to do things like read hands on their own.

And while MCTS would make a better player, I have no reason to assume that it would make training better vs just increasing the batch size. Using MCTS would reduce my training performance to dozens of hands per second even though each of the hands would have much lower variance. Who knows if the tradeoff is worth it.

The way I see to actually succeed at RL, and anything else in ML is to do the opposite of the advice of doing end-to-end learning and finding more spots like eliminating the need for the net to learn to do hand reading. That would definitely improve sample efficiency.

This is the way I see programming going forward. It is a style of writing simulators and using NNs to memoize them. Instead of expecting NNs to do things like now, we will be expecting simulators to do the right things, but NNs to guide them towards likely areas. The NNs won't go away, but training them end-to-end and expecting them to learn anything significant will be seen as a minor phase in hindsight. This also makes me bullish on probabilistic programming + variational inference which offers a framework for composing those simulators.

--- Future Of My Programming Development

My path is just so weak. This is the first time I've started thinking this way. It is not my talent, abilities or skills that I doubt, but my path.

What use are programming skills if they don't get you what you want? Working on RL and continually improving the model to get you better and better performance, enough to win in real life would have been so cool. That is what I've been dreaming about. Instead I am getting...this.

I need a different approach. All this time I've been ignoring that it is easier to make games than to beat them. It is far easier to make a poker, or chess, or a Go game than it is to train an agent that can conquer them.

I'd like to find a style of programming that would improve my creative capabilities.

Right now, I am pretty confident of being able to write a story, but would be great for standing out if I could do the graphics and music for it as well. I am not good at the latter. I do not know how to draw and compose. I was terrible in art class. Maybe I could get better if I practiced, but instead it might be possible to use NNs to help me here.

For backgrounds, would it be possible to use something like [style transfer](https://towardsdatascience.com/style-transfer-with-gans-on-hd-images-88e8efcf3716)?

Even if generating 1024x1024 images would be out of reach on my current hardware, could I do something with probabilistic programming to generate things piece by piece? I don't know. I do not have particularly good ideas apart from style transfer, but I haven't really tried digging into this part of programming. Maybe it is worth giving it a try.

Rather than trying to conquer the world directly using pure power, maybe I should be controlling people with my mental powers. Back in 2014, I felt that I would be a charlatan if I just wrote stories about the Singularity instead of actively pursuing its ignition, but I've really fucking tried. So I am going to lift some of my self imposed restraints.

If I want money, I should be making games and selling them. I am not exactly expecting a code monkey salary, but even if it would be 0.5-1k a month, that would be suitable for the kind of life I want to lead. As long as it's made with my own power, I am fine with the outcome. I've been applying to places for the past month and a half, and one thing I've realized is that the kind of work that you do is more important than how much you get paid. I'd rather write 30 games or novels, than make 30 ASP.NET backends even if it nets me less pay.

The game I have in mind would be 90% a novel. The rest I would spice up with RPG elements as pure novels do not have the impact of bad ends and branching. To start myself off on the new path, I'll make the character stats into probability distributions rather than dumb scalars. I'll use [`Infer.NET`](https://dotnet.github.io/infer/) to do inference over them.

This should make it a stochastic novel. I've never seen anything like that before, but it should be a good fit for the computer.

My heart is overflowing with desire, evil and inspiration. If through my writing I increase the global AI risk by a few orders of magnitude and get the money needed to buy an AI chip, that would make the effort well worth it. In 2014 I did not have any other options than to just churn out text, but now I should be able to do just a bit more.

Since some of you guys supposedly like reading my stuff, do support the work when I release it in an app store. It will probably take me at least six months of work and probably way more to get something good done. The last time I tried writing, after 8 months I was a shell of a man and had fallen into madness. I still haven't recovered from that. Money is the only cure for this kind of affliction.

///

12pm. Actually this is not the right memory consumption. I remember it being terrabytes. Where am I missing things? Ah needing to do the calc for every input.

2:55pm. I am finally done writing the PL sub review.

3:35pm. I'll check it later. I haven't slept properly so my mind is strained now. I do not want to write right now.

I swear I am going to put my ego behind me and get one of those cheap and plentiful C#, Python, Typescript jobs after all this is done. I'll dedicate an entire month to just studying ASP.NET, SQL and other such job necessary things.

Forget Julia macros. Forget research positions. Forget PL work. Forget AI chips.

Hope that my creative work causes my AI skills to flourish. That is the way to go forward.

https://towardsdatascience.com/style-transfer-with-gans-on-hd-images-88e8efcf3716

The stuff here is interesting. I should find some pretrained GANs and train then in anime style. I said it was useless, but actually even 32x32 images would have a use wouldn't they? For character portraits.

It is the little things like these that I have been overlooking.

Let me rest, tomorrow I will write more scenes.

5pm. Let me put the review through Google Docs.

6:40pm. I worked on it forever. It was my obsession for the day, and I'd rather give closure to this than to obsess about negotiation with Zenna.

I'll put the old path behind me and firmly step on the new one. Forget targeting PL positions. If I apply to jobs again I shold go for the most generic jobs possible and I should master the popular frameworks.

I'll try to make something of my creative work instead. If that could net me some income that would be swell.

I'll post the review on the PL sub tomorrow. Let me close here for the day."

---
## [karashiiro/FFXIVQuickLauncher](https://github.com/karashiiro/FFXIVQuickLauncher)@[2a820bed81...](https://github.com/karashiiro/FFXIVQuickLauncher/commit/2a820bed814c80326c6a008653cfe7e26b7ba4a5)
#### Friday 2021-10-01 18:12:19 by Robert Baker

Add button to open integrity report

Fucking hell I hate UI code so much. I know this is a shitty way  to handle adding the button, but I tried making my own XAML window and XL never loaded it so I forced it in. 

This could probably be cleaned up or made into its own window, but it works and I never want to touch WPF again.

---
## [Siddhant-sarkar/Data-Structure-Algorithm](https://github.com/Siddhant-sarkar/Data-Structure-Algorithm)@[b00a55a61b...](https://github.com/Siddhant-sarkar/Data-Structure-Algorithm/commit/b00a55a61b50ce38eee5150caf7da3a4f662b50b)
#### Friday 2021-10-01 19:56:08 by Siddhant Sarkar

This was meant to be a dynamic programming question but i did it with some simple math concept.

THIS MARKS THE SWEET END OF DYNAMIC PROGRAMMING. FUCK YOU DP FR.

---
## [Sergio-Al/biolerplateV1-base](https://github.com/Sergio-Al/biolerplateV1-base)@[2076a0452b...](https://github.com/Sergio-Al/biolerplateV1-base/commit/2076a0452bcd70513b1d9df1fab7c41887eacded)
#### Friday 2021-10-01 20:16:36 by Sergio-Al

Private Firebase Data

We make a new component of ruote <PublicRoute/> to redirect if the user is authenticated
- We added authentication to our app. Now every expense will have an user as parent in firebase.
- We modified our actions expenses to write data to users getting the uid (getState().auth.uid) from the dispatch method as second argument (look (dispatch, getState). Remember this dispatch method comes from our middleware where getState extract the uid Session of the authenticated user from our provider (GoogleProvider).
- In firebase we modified our rules to access write and read through user authentication uid. (Read more in the docs Build/securityRules/understandSecurityRules/SecurityRulesAndfirebaseAuthentication.
- Firebase is an awesome tool to manage this realtime database for people that is not backend friendly (not my case, i love backend develompent).

---
## [A2L5-MTK/android_device_amazon_tank](https://github.com/A2L5-MTK/android_device_amazon_tank)@[b7aa0ebf16...](https://github.com/A2L5-MTK/android_device_amazon_tank/commit/b7aa0ebf161231b9c5b0afc91c940b7b68c17edd)
#### Friday 2021-10-01 21:49:51 by A2L5E0X1

fuck you

Change-Id: I48eaba49f3c4794609594b67428ce84932b850ce

---
## [rorydale/pointbreakradio](https://github.com/rorydale/pointbreakradio)@[e67825dd21...](https://github.com/rorydale/pointbreakradio/commit/e67825dd21e1e1ac21e6302b86d19c02dec03e19)
#### Friday 2021-10-01 22:05:47 by Rory Dale

2021-10-01

Friday, October 1st, 2021 - the 1960s rock, power pop, psychedelic, freakbeat show! Inspired by a song I heard this morning on a new radio station from my home town in England, today's show is a play-through of some obscure tracks from the era, balanced with some well known tracks, before moving gently into some of the best... oh no, a power cut!⚡️We have survived power cuts before (battery backups), and internet outages (MiFi hotspots), but this time, the MiFi wouldn't connect to the show computer, and the battery backup would have depleted before the end of the show. The last 14 songs and 39 minutes may well always remain a mystery...

---
## [nikitavoloboev/knowledge](https://github.com/nikitavoloboev/knowledge)@[d6cdb95c28...](https://github.com/nikitavoloboev/knowledge/commit/d6cdb95c282a076bc036d9f2f737ae6437a608a5)
#### Friday 2021-10-01 23:51:11 by Nikita Voloboev

analytics art generative-art dna startups values venture-capital aws azure aws-lambda ocr webgl ego cryptocurrencies kafka arweave blockchain ethereum polkadot blender design-inspiration design figma-plugins user-experience drugs psychedelics e-commerce learning focusing future games minecraft spatial-analysis governance risc-v foods humans macOS-apps ml-libraries pytorch dependent-types type-theory music-production decentralization dns http networking wireguard brain-computer-interfaces emulators operating-systems other wiki-workflow physics podcasts ada cpp-libraries cpp go-libraries js-libraries react-components threejs julia-libraries kotlin-libraries common-lisp nim-libraries programming-languages prolog python-libraries r rust-libraries scala standard-ml swift competitive-programming programming reverse-engineering git relationships security social-networks vs-code-extensions vs-code telegram finding-home china russia tv-series rss webassembly finding-work hiring remote-work

---

# [<](2021-09-30.md) 2021-10-01 [>](2021-10-02.md)

