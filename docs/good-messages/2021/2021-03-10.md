# [<](2021-03-09.md) 2021-03-10 [>](2021-03-11.md)

5,496,955 events, 1,387,294 push events, 2,139,569 commit messages, 158,745,587 characters


## [Working-Title-MSFS-Mods/fspackages@775f3c4016...](https://github.com/Working-Title-MSFS-Mods/fspackages/commit/775f3c4016f27e6b1519aa2261dd8b40dbd610c5)
##### 2021-03-10 00:34:24 by slip664

CJ4-tunepg-updates (#968)

* TUN button Dispatch mode

-Toggles Dispatch Radio page when TUN is pressed if avionics are in 'composite' mode.

* Changes to TUN Page

-Cosmetic cleanups
-Adds ATC Control Page
-Adds DISPATCH Page

* formatting stupidity

* formatting again...

please for the love of god, format correctly from the github editor.

* More fixes

I'm bad at this. Import formatting from VS to try to make life easier

* github doesn't like tabs

* commit number 4 million

* last formatting

* remove experimental code

* Dispatch Switch Implement

Thanks Matt!
-dispatch switch implemented
-minor updates to press. alt.

---
## [Delvigore/liliths-throne-public@e4c82f2bd7...](https://github.com/Delvigore/liliths-throne-public/commit/e4c82f2bd7e08f036f5ced79fc0da2c1e6c72543)
##### 2021-03-10 09:37:02 by Delvigore

Sexings and threesomes update

Changed the elasticity and plasticity on Sameera's vagina.
Implemented getFHGroup in dialogue with Sameera and Bevikar.  I was
being silly and finally figured out how to put it in.  Many thanks to
AceXP and his patience with me.
Added applyUniform to Bevikar with him wearing a hard hat.  Need to
figure out how to implement.

things that still need to be done:
Get the 'busy' dialogue to work
Need to finish adding NPCs
implement conversations with all proper NPCs
Need to write for NPCs so that they each have their own character and
personality
Need to figure out how to ask NPCs to have sex privately in case the
player doesn't want people watching
Need to fix the secretary 'step back' response so it accounts for time
Finish adding rooms
probably some sex behavior based on if dom or sub
enable dialogue flags so the NPCs only do the intro once
NPC affection stuff
Quests
Fire events and interactions
writing
NPCs change outfit depending on if they're working or not
Fire fighter equipment and uniforms
Fire fighter background perk
Arcane fire fighter background perk

additional thoughts
thinking of maybe having a quasi-hidden control panel on the secretary
desk for testing/debug purposes

---
## [mrakgr/The-Spiral-Language@cd36a7c3ba...](https://github.com/mrakgr/The-Spiral-Language/commit/cd36a7c3badd86a7308ecad88b7e6d901eac5814)
##### 2021-03-10 11:38:26 by Marko GrdiniÄ‡

"10:15am. I am up. Let me chill a bit and then I will start.

10:35am. https://zerophilosophy.substack.com/p/rules

This article really is a lot better than that article by Moldbug scolding some guy for confusing power for truth. In that particular context I thought the guy's problem was him mistaking New York Times for power. You can always count on Land not to moralize.

Let me read Frieren and Samayoeru. After that I will start.

10:50am. Let me start.

10:55am. First I'll cut out everything in the ServerUtils apart from the code action stuff. Now, let me put down my first type definition.

```fs
type SchemaState = { schema : Schema; errors_intra : RString list; errors_inter : RString list}
```

Previously I had a couple of these schema states, all linking to one another, but now I will only have one. By reducing the number of types in use, I will radically simplify my work. For links and actions I will make separate functions that merely look at the schema and the environment. And speaking of the later, here it is.

```fs
type SchemaEnv = Map<string,SchemaState>
```

Let me make the `ModuleEnv`.

```fs
type ModuleEnv = Map<string,ModuleState>
```

Do I need anything more than this for the dirty segment? Not really. Later I'll need a map of package dir paths to their ids, but I'll leave that when the time comes to connect the clean and the dirty segments.

```fs
let ss_has_error x = (List.isEmpty x.errors_intra && List.isEmpty x.errors_inter) = false
```

Let me make this for later.

Now...I need to do validation.

```fs
let ss_validate (packages : SchemaEnv) (modules : ModuleEnv) (x : SchemaState) =
    let errors = ResizeArray()
    let rec loop = function
        | SpiProj.FileHierarchy.Directory(_,_,_,l) -> list l
        | SpiProj.FileHierarchy.File(_,(r,path),_) -> if Map.containsKey path modules = false then errors.Add(r,"Module not found.")
    and list l = List.iter loop l
    list x.schema.modules
    x.schema.packages |> List.iter (fun {path=r,path} -> if Map.containsKey path packages = false then errors.Add(r,"Package not found."))
    {x with errors_intra=Seq.toList errors}
```

Missing directories will not be errors this time. I'll just use validate after loading the schema.

Actually, let me do it like...

```fs
let ss_validate' (packages : SchemaEnv) (modules : ModuleEnv) (x : SchemaState) =
    let errors = ResizeArray()
    let rec loop = function
        | SpiProj.FileHierarchy.Directory(_,_,_,l) -> list l
        | SpiProj.FileHierarchy.File(_,(r,path),_) -> if Map.containsKey path modules = false then errors.Add(r,"Module not found.")
    and list l = List.iter loop l
    list x.schema.modules
    x.schema.packages |> List.iter (fun {path=r,path} -> if Map.containsKey path packages = false then errors.Add(r,"Package not found."))
    Seq.toList errors
let ss_validate packages modules (x : SchemaState) = {x with errors_intra=ss_validate' packages modules x}
```

Ok, good. I won't do diffing for the dirty segments as the loading demands would invalidate it.

11:25am. The next part would be to make the propagation function.

```fs
x.schema.packages |> List.iter (fun {path=r,path} -> if Map.containsKey path packages = false then errors.Add(r,"Package not found."))
```

Actually, let me move this check to propagate.

```fs
let ss_propagate (packages : SchemaEnv) (x : SchemaState) (circulars : string HashSet) (order : string []) =
    let has_error x = (List.isEmpty x.errors_intra && List.isEmpty x.errors_inter) = false
    Array.fold (fun s path ->
        match Map.tryFind path s with
        | Some (x : SchemaState) ->
            let ers =
                (x.schema.packages, []) ||> List.foldBack (fun {path=r,p} ers ->
                    if circulars.Contains p then (r,"Package is circular.") :: ers
                    else
                        match Map.tryFind p s with
                        | Some s' when has_error s' -> (r,"Package has an error.") :: ers
                        | Some _ -> ers
                        | None -> (r,"Package not found.") :: ers
                    )
            Map.add path {x with errors_inter=ers} s
        | _ -> s
        ) packages order
```

Actually, when it comes to circulars, how about I in fact separate each in its own strong component.

11:55am.

```fs
let ss_propagate (packages : SchemaEnv) (x : SchemaState) (circulars : Dictionary<string,int>) (order : string []) =
    let has_error x = (List.isEmpty x.errors_intra && List.isEmpty x.errors_inter) = false
    Array.fold (fun s path ->
        match Map.tryFind path s with
        | Some (x : SchemaState) ->
            let c p = match circulars.TryGetValue(p) with true,b -> b | false,_ -> -1
            let is_circular x = x <> -1
            let are_in_same_strong_component a b = is_circular a && is_circular b && a = b
            let ers =
                let cpath = c path
                (x.schema.packages, []) ||> List.foldBack (fun {path=r,p} ers ->
                    let cp = c p
                    if are_in_same_strong_component cpath cp then (r,"Package is circular and loops through the current one.") :: ers
                    elif is_circular cp then (r,"Package is circular.") :: ers
                    else
                        match Map.tryFind p s with
                        | Some s' when has_error s' -> (r,"Package has an error.") :: ers
                        | Some _ -> ers
                        | None -> (r,"Package not found.") :: ers
                    )
            Map.add path {x with errors_inter=ers} s
        | _ -> s
        ) packages order
```

This is really good. Let me modify the graph operation.

```fs
let circular_nodes ((abs,bas) : MirroredGraph) dirty_nodes =
    let sort_order, sort_visited = topological_sort bas dirty_nodes
    let order = sort_order.ToArray()
    let visited = HashSet()
    let circular_nodes = Dictionary()
    Array.fold (fun i a ->
        let sc = ResizeArray() // This array stores the strongly connected components.
        let rec dfs a = if sort_visited.Contains(a) && visited.Add(a) then Seq.iter dfs (links_get abs a); sc.Add a
        dfs a
        if 1 < sc.Count then
            sc |> Seq.iter (fun x -> circular_nodes.Add(x,i) |> ignore)
            i+1
        else
            i
        ) 0 order |> ignore
    order, circular_nodes
```

This is good. Previously, the way I propagated information was wrong.

```fs
                    elif is_circular cp then (r,"Package is circular.") :: ers
```

Actually, no. i need to remove this. This error will only be valid when diffing everything. After a change it would revert to the normal one.

```fs
let ss_propagate (packages : SchemaEnv) (x : SchemaState) (order : string [], circulars : Dictionary<string,int>) =
    let has_error x = (List.isEmpty x.errors_intra && List.isEmpty x.errors_inter) = false
    Array.fold (fun s path ->
        match Map.tryFind path s with
        | Some (x : SchemaState) ->
            let c p = match circulars.TryGetValue(p) with true,b -> b | false,_ -> -1
            let is_circular x = x <> -1
            let are_in_same_strong_component a b = is_circular a && is_circular b && a = b
            let ers =
                let cpath = c path
                (x.schema.packages, []) ||> List.foldBack (fun {path=r,p} ers ->
                    let cp = c p
                    if are_in_same_strong_component cpath cp then (r,"Package is circular and loops through the current one.") :: ers
                    else
                        match Map.tryFind p s with
                        | Some s' when has_error s' -> (r,"Package has an error.") :: ers
                        | Some _ -> ers
                        | None -> (r,"Package not found.") :: ers
                    )
            Map.add path {x with errors_inter=ers} s
        | _ -> s
        ) packages order
```

Yes, this is it.

```fs
type SchemaState = { schema : Schema; errors_modules : RString list; errors_packages : RString list}
```

```fs
let ss_validate_modules modules (x : SchemaState) = {x with errors_modules=ss_validate_modules' modules x}
let ss_validate_packages (packages : SchemaEnv) (x : SchemaState) (order : string [], circulars : Dictionary<string,int>) =
```

Let me change the naming. Now it is much better.

Now what comes next?

12:20pm. Well, breakfast, but before that let me at least figure out what I want to do next. I have all the pieces ready in my mind, but not the order I shuold approach them. Ok, here is what I am going to do. I'll finally connect the clean and the dirty segments. After the packages have been validated, it is the `PackageEnv`'s turn to be processed.

After that I will do with the loading.

That will give me breathing room to deal with the rest.

I should also make a function to update the mirrored graph. This is the way to go.

...

```fs
open System
open System.IO
open System.Collections.Generic

let x = Stack()
x.Push(1)
x.Push(2)
x.Push(3)

printfn "%A" (x.ToArray())
```

This prints 3,2,1...

```fs
let circular_nodes ((abs,bas) : MirroredGraph) dirty_nodes =
    let sort_order, sort_visited = topological_sort bas dirty_nodes
    let order = sort_order.ToArray()
    let visited = HashSet()
    let circular_nodes = Dictionary()
    Array.fold (fun i a ->
        let sc = ResizeArray() // This array stores the strongly connected components.
        let rec dfs a = if sort_visited.Contains(a) && visited.Add(a) then Seq.iter dfs (links_get abs a); sc.Add a
        dfs a
        if 1 < sc.Count then
            sc |> Seq.iter (fun x -> circular_nodes.Add(x,i) |> ignore)
            i+1
        else
            i
        ) 0 order |> ignore
    order, circular_nodes
```

This is the right order for calculating the strong components, but is this really what I should be returning here?

No, not it is not. I am assuming the order starts from the current node and goes outward.

```fs
open System
open System.IO
open System.Collections.Generic

let x = Queue()
x.Enqueue(1)
x.Enqueue(2)
x.Enqueue(3)

printfn "%A" (x.ToArray())
```

Yes, the queue is what I need.

```fs
let topological_sort bas dirty_nodes =
    let sort_order = Queue()
    let sort_visited = HashSet()
    let rec dfs_rev a = if sort_visited.Add(a) then Seq.iter dfs_rev (links_get bas a); sort_order.Enqueue(a)
    Seq.iter dfs_rev dirty_nodes
    sort_order, sort_visited

let circular_nodes ((abs,bas) : MirroredGraph) dirty_nodes =
    let sort_order, sort_visited = topological_sort bas dirty_nodes
    let order = sort_order.ToArray()
    let visited = HashSet()
    let circular_nodes = Dictionary()
    Array.foldBack (fun a i ->
        let sc = ResizeArray() // This array stores the strongly connected components.
        let rec dfs a = if sort_visited.Contains(a) && visited.Add(a) then Seq.iter dfs (links_get abs a); sc.Add a
        dfs a
        if 1 < sc.Count then
            sc |> Seq.iter (fun x -> circular_nodes.Add(x,i) |> ignore)
            i+1
        else
            i
        ) order 0 |> ignore
    order, circular_nodes
```

To think there was a bug here. This might have contributed to the instability. Amazing what a second pass unearths.

I can see things much more clearly now.

Let me list out the bullet points again:

* Update the `PackageEnv` after validating the `SchemaEnv` based on the order.
* Do the schema loader.
* Update the mirror graph based on the order.

Let me have breakfast here."

---
## [JJawesomeJJ/jjawesome-3d@ceece1b121...](https://github.com/JJawesomeJJ/jjawesome-3d/commit/ceece1b12172ad1644a2f285df2a8fa692deb54d)
##### 2021-03-10 12:30:59 by zhaolijie

-water----normal life --
--single life how long will continue
--No mater how sadness of the life remember you are petty unique boy
--fight young man the futher may be darkness but don't be fear,remember the beauty will always wait for you in the some which is not far away --2020-12-15

---
## [TalkingCactus/ARFS-6@fc91485466...](https://github.com/TalkingCactus/ARFS-6/commit/fc91485466cb1b6be160150b67edefc31d8f5737)
##### 2021-03-10 16:03:22 by Wickedtemp

ML3M Rebalancing

Originally, the ML3M was intended to be a little bit stronger. The healing values for the Brute, Burn, Omni, Toxin, and Antirad cells, have been adjusted according to what was initially planned. 
Base Tier's now heal 10 per shot, for a total of 40 damage healed, up from 20.
Second Tier's now heal 20, instead of 10.
Third Tier's heal 40, instead of 20. 

Omni 1 heals 5's for brute, burn, and toxin, and 30 for oxy, up from half those values. Omni 2, is 10's and 60, and Omni 3 is 20's and 120. 

Antirad Cell had its toxin heal bumped up from 2.5 to 5, and its radiation-heal from 150, to 350. I wasn't originally going to touch this one, but the text said "It's 150 because that's equal to five units of arithrazine", and... it wasn't. So, I bumped it up to actually be equal to 5u of Arithrazine's worth of radiation healing.

Stabilizer Cell, CorpseMend, Resistance, Haste, and the size-changing cells, were not touched.
The reasons for this are as follows:

- The healing laser was simply not strong enough to ever tend to more than one patient. Healing 20-40 damage per cell just isn't enough, even if you had several clips full of cells, it just wasn't viable.
- As a result of this, it was seldom if ever used. Field Medics rarely if ever took it with them. In nearly every round I've played, it was left exactly where it was spawned, collecting dust. 
- I'd like to make it a more proper treatment option. It wouldn't be equal to reagents used in your usual Medbay setting, or surgical repair, but if it's modified to actually fulfill its niche as a rapid, contact-free treatment option, it could be relied on more by Field Medics. There is so much potential for this device as an "in the field" healing tool, and I'd like to see it done well. We have no shortage of people who would like to see non-chemical-based treatment options. We might as well make it useful enough to actually use.

Here are a few issues people brought up in Discord when I floated this idea.
"But, Tempest, you're doubling everything? That's a huge change! Won't this result in the ML3M overshadowing other treatment options?"
Certainly not. Currently, with tier-2 cells that only heal up to 40 damage, this is actually worse than basic first-aid in terms of raw healing ability, as the cutoff for first aid healing is 50 damage on a limb. First aid and reagents will still be the most convenient, most readily available, and overall most-used manner of treatment for injuries that can be treated using those methods. All this change would do is allow the ML3M to also have its uses, and stop being overshadowed by everything else. 

"Okay, but what if it DOES actually become The New Meta and becomes the favored tool for healing?"
I wouldn't see it as an issue if Chemistry gets dethroned, in all honesty. They'd both take quite a bit of prep-work to use. You have to make multiples of every chem if you want a solid stock, and you'd need multiples of every cell if you want proper coverage and healing-ability, since even with these changes you're expending 1-3 cells per patient. And, unless you get multiple ML3M's made, only folks who are gonna have one are the CMO, and whoever nabs the spawned one first. 

"But wouldn't this result in less departmental cooperation between Medical and Science now that Medical will require fewer cells?"
Most likely, no. If anything, I'd think there would be an increase, round-to-round, if this becomes a more viable and wanted tool, more people will ask for cells. Personally, my list of requested cells would stay the same, but I'd be sending that request in more often since I know it'll actually be useful rather than having it just to have it. Tier 2 cells are still going to be desirable, and I'm still probably not going to order Tier 3's because of the cost, but that's just me. It's still going to be incredibly weak at roundstart, and better cells will be that much nicer to obtain.

"But Tempest! If you get the highest tiers of cells, and a lot of them, you could fix anything that doesn't require surgery!"
Well, if Science had the time and mats, then sure, you could gather up a large enough collection of cells, and you probably could indeed do this for one or two badly injured patients... ... ...and I could accomplish the same goal if I'm given 20 seconds in a chem-lab. The ML3M is more costly to use, the cells cost resources, have to be recharged after 4 shots, and you only start with a base tier Burn, Brute, and Stabilizer cell. Each shot from a base level burn/brute cell is the equivalent of 1.25u of bicaridine or kelotane. This change would make it 2.5. Base level cells are still going to be next to useless for anything other than the most minor of injuries. Chemistry will still be the dominating powerhouse it always has been, but at least you can use this tool, provided the PR goes through, instead, more often.

"Tempest, this thing just wasn't intended to be used to fully heal people..."
A couple people have said this, and to be honest, it's silly. In our medical system, there's very little distinction between what can "heal a little bit" and what can "heal fully", because it all comes down to the fact that everything works off of damage values. If Option A heals 5 damage, and Option B heals 50... Both are capable of "healing fully" if you have enough Option A, it's just a question as to whether or not that's practical. Currently, the ML3M's healing values can't really even be used to even partially heal injuries, unless you have a large number of cells. You'd expend all of your charges on one patient and then you've got a paperweight taking up storage space until you can get to a recharger. 

Now, as for issues that I personally see? Biggest one is probably the Toxin cell. If I remlember correctly, the base Toxin cell is the same tech requirement as the Second Tier Brute/Burn cells. This PR doesn't fix that, and I don't really see it as a huge priority since I don't think anyone uses the toxin cells as it is, but yeah. Might need to be fixed at some point if this PR goes through.

And, absolute worst case scenario, let's say that this PR screws everything up, turns the Tether upside down, and now Medbay is dominated by a bunch of blue laser beams flying everywhere like it's the new Star Wars Trilogy (but actually better because those movies kinda set a low bar)... this PR was really easy to do. The only long part about it was typing all of this up. We can just bump the numbers down if this ends up sucking really bad, ezpz.

Thank you for coming to my ted talk.

---
## [makingglitches/CensusScripts@ea656f7a99...](https://github.com/makingglitches/CensusScripts/commit/ea656f7a9967967af9e63d2771b4b90aad744313)
##### 2021-03-10 18:56:40 by Magical Marvelous MADMADMAD Mister Mim !

in the record books, if ever this bullshit makes it there, they will look back and call this entire time period of overt trickery, whoredom, needless pain and suffering and years of deleted time in which they were probably murdering children, breeding deformed ones intentionally and in general just stuffing the world with bodies and the trash which was themselves, as the greatest period of idiocy anyone ever could have conceived patterned and designed by corrupt members of the baby boomer generation and older who didnt give a damn about anyone but themselves, and whose partial loyalty elsewhere stopped at their own age group, and was forbidden their children. thats a decent way of putting what pieces of garbage like my father were like, weak fools who could have their minds and impulses bent to lash out at whatever outlet was provided them because boo hoo they were cowards and boo hoo life was hard. think this has been easy you fucking bastard ? I wasnt a some bat eyed fuck that wanted my kids to be hurt traumatized or die or took weird pleasure in this constraining retard system you morons created, but here i am, and here i am again, and here i find myself wondering WHAT THE FUCK WAS WRONG WITH YOU ????

and yeah smirk a little more assholes, the older garbage is almost dead, the younger garbage is beginning to feel its artificially produced period of superior feeling and satisfaction spawned of exceedingly manipulated states of mania and surrender fade.

in the end i will find more of my own, and all of you will be left to rot here where you fucking pieces of shit belong.

you in this case meaning the chomo garbage such as runs colorado
and i/us = the remaining sane people in fucking america.

and stop playing stupid games with electronics assholes. keep track of your own bullshit. wanna help ? give up them salaries since money apparently isnt important to any of you and we'll walk off  :)

---
## [makingglitches/CensusScripts@6418adf7bd...](https://github.com/makingglitches/CensusScripts/commit/6418adf7bd48d1026c2a27ace88f05e0e7df5c48)
##### 2021-03-10 19:22:01 by Magical Marvelous MADMADMAD Mister Mim !

god damn it you fucking people wanting shit broken
mother fuckers, let me keep some progress and as before i'll fucking contribute more !!!!!!!!

the same version of wget for windows has been up on the site for years now as well !
its stuff like that..

if you'd just port visual studio to linux i'd convert over everything to that os since i can rebuild and check the software my fucking self !

---
## [dloe/TheLastArray@ae6427a2b6...](https://github.com/dloe/TheLastArray/commit/ae6427a2b62034a4df7b6d954bad312218266662)
##### 2021-03-10 21:43:53 by Necko21

god damn it all

Pushing UI changes because im getting bullied and made fun of. My team hates me

---

# [<](2021-03-09.md) 2021-03-10 [>](2021-03-11.md)

