# [<](2021-03-16.md) 2021-03-17 [>](2021-03-18.md)

3,109,021 events, 1,602,460 push events, 2,488,846 commit messages, 186,720,106 characters


## [DanaAndConnorProductions/ZeyGate@4394b28ada...](https://github.com/DanaAndConnorProductions/ZeyGate/commit/4394b28ada6e8b08f1474a7a45ea2a119880c2bf)
##### 2021-03-17 01:50:04 by DanaAndConnorProductions

i love you :3 kissy kissy JK FUCK YOU UCK YOU UCK YOU UCK YOU UCK YOU UCK YOU UCK YOU UCK YOU UCK YOU  nah nah im sorry bro i didnt mean it bro im sorry please forgive me please ;-;

---
## [Funce/Skyrat-tg@e3b36b1a33...](https://github.com/Funce/Skyrat-tg/commit/e3b36b1a33017c8deae7a1b8aae0bdc36667513e)
##### 2021-03-17 10:10:38 by SkyratBot

[MIRROR] Moth tourist bots -- They ask for your hat (#4152)

* Moth tourist bots -- They ask for your hat (#57563)

Adds a rare, once per restaurant venue, chance for a moth tourist bot to show up. Asks for the hat, gloves, or shoes you have on.

Closes #57541 if this is merged first, somehow. It includes the testing fix (since I needed to multiply all the weights to allow for rare bots anyway).

Wings are randomized.

I thought it was funny, and it's infrequent enough for the gag to hopefully not lose its magic.

Also a good test bench for the code to allow more dynamic customers. A lot of supporting code was added to make more customizable customers without influencing the surface area of the venue code too much.

Co-authored-by: ATH1909 <42606352+ATH1909@ users.noreply.github.com>

* Moth tourist bots -- They ask for your hat

* Update _customer.dm

Co-authored-by: Mothblocks <35135081+Mothblocks@users.noreply.github.com>
Co-authored-by: ATH1909 <42606352+ATH1909@ users.noreply.github.com>
Co-authored-by: Gandalf2k15 <jzo123@hotmail.com>

---
## [mrakgr/The-Spiral-Language@f15a67fd86...](https://github.com/mrakgr/The-Spiral-Language/commit/f15a67fd86531f645ff53c22203b71a151c3a4c2)
##### 2021-03-17 10:51:34 by Marko Grdinić

"2pm. Done with breakfast. Let me chill a bit and then I'll do the chores.

3:10pm. Done with chores. Let me rest a bit and then I will resume. The morning session was too intense so I need more time off.

3:40pm. Let me resume.

I did want to resume earlier, but given how early I got up, and how intensely I am focused on this task, my mind is in a daze. It feels like I have a fever from all this thinking.

3:45pm. I have a strong feeling of inspiration.

4:15pm.

```fs
type [<ReferenceEquality>] TypecheckerState = {
    package_id : PackageId
    module_id : ModuleId
    top_env : TopEnv Promise
    results : (Bundle * InferResult * TopEnv) Stream
    bundle : BlockBundleState
    }
```

Hmmm, to get the actual top env, what I have to do is use the top_env as the neutral element and fold over the results, getting the third item.

```fs
let top_env_last (x : TypecheckerState) = x.top_env >>=* fun s -> Stream.foldFun (fun _ (_,_,x) -> x) s x.results
```

Also to make compilation less annoying, I should in fact...

No nevermind. I'll have to go over all the packages anyway during prepass compilation.

This caught my attention for the reason that making the `BuildFile` command work took a hack.

4:45pm. I should be writing code, but I am not. It is not like I am blocked. It is not that I do not know what I need to do. It is that the insights and the inspiration are coming in at too rapid of a clip and I am trying to digest them properly.

5:25pm. Done with lunch.

I am actually quite tired after thinking at full tilt for so long. I got up significantly earlier than usual too. I don't think I'll be doing any more programming for the day.

At any rate, I think I understand it all. The entire editor support segment. Last time I could only hack it piece by piece, but now I have the entire structure internalized as one clean mental model.

This time I am absolutely sure that I will be able to design it so it is roboust.

Let me do just a little in anticipation of what is to come.

```fs
type PackageFiles =
    | File of module_id: int * path : string * name: string option
    | Directory of dir_id: int * path : string * name: string * PackageFiles list
```

This. Paths will definitely make the reverse updates easier.

```fs
let proj_files_diff (uids_file : ('a * 'b) [], uids_directory : 'b [], files) (num_dirs, uids, files') =
    let uids_file' = Array.zeroCreate (Array.length uids)
    let uids_directory' = Array.zeroCreate num_dirs
    let rec loop = function
        | File(uid,path,name), File(uid',path',name') when uid = uid' && name = name' && path = path' && uids.[uid] = fst uids_file.[uid] ->
            uids_file'.[uid] <- uids_file.[uid]; true
        | Directory(uid,path,name,l), Directory(uid',path',name',l') when uid = uid' && name = name' && path = path' && list (l,l') ->
            uids_directory'.[uid] <- uids_directory.[uid]; true
```

It did not require much modification.

5:30pm. I definitely made the wrong choice with streams.

Instead the right answer was to make the editor support one huge immutable data structure. This is quite amazing. I finally have the feeling for how this kind of machinery works.

Last time I toughed it out, but now now I can finally visualize the whole thing as an one big whole. I can zoom in and inspect what every piece does in my mind. And according to that, I can verify the correctness of the system.

I am not saying that once I code it all up, that it will work and be without bugs. But if a bug happens, you can bet that I will be able to track it down and fix it right away.

5:35pm. I am really tempted to do a bit more right now and code up at least the inter package updates, but I should leave that for later and take it easy for the rest of the day. A leisurely pace is the best. One day you think hard, the next day you code hard. That is what programming is. It is hard to switch gears to code writing mode.

Instead of doing it forcefully, by tomorrow this surge of thoughts will petter out and solidify as it cools down.

I know the whole system and I am already thinking ahead, but tomorrow I will just play it safe and finish the clean stuff. I only have two functions left before I am done with typechecking. After that comes the prepass. After that I'll move to the `.spiproj` parser.

There is no need to rush this. Now that I know how to do things, why not give it a few weeks? Forget the time.

After I implement the new design, the editor support won't have any new features, but it should be much more roboust. I'll never have trouble extending it again or fixing what minor bugs are left in it.

Not only will Spiral be very much complete, in the sense of not having all the features that I wanted, but also in the sense of being thoroughly battle tested, but I'll also gain an understanding of this technique. I get the sense that it will be pretty useful in my future endeavors. It meshes particularly well with concurrency, but it would have value without it.

Keeping track of state and managing complexity will be my main challenge as I start taking ML seriously again. I'll probably find an opportunity to make use of this design in my ML work.

I'll fuse my understanding of compiler engineering and ML. That is my main goal for 2021.

I'll refine Spiral and then consolidate all of my experiences.

I can do this. My 2021 ML attempt won't go the same way as the 2018 one. Just because one blow did not topple my opponent does not mean that a much stronger strike wouldn't."

---
## [mrakgr/The-Spiral-Language@76963ddc55...](https://github.com/mrakgr/The-Spiral-Language/commit/76963ddc55af5007d2877fd2e805fc128bb8dc73)
##### 2021-03-17 10:51:34 by Marko Grdinić

"9:45am. Let me chill and then I'll start. I've faced my demons a bit. In the next batch of emails I'll try talking about my vision.

But nevermind that.

10:10am. Let me start.

```fs
let add_line_to_range line ((a,b) : VSCRange) = {|a with line=line+a.line|}, {|b with line=line+b.line|}
let tokenize_replace (lines : _ PersistentVector PersistentVector) (errors : _ list) (edit : SpiEdit) =
    let toks, ers = Array.map tokenize edit.lines |> Array.unzip
    let lines = PersistentVector.replace edit.from edit.nearTo toks lines
    let errors =
        let adj = edit.lines.Length - (edit.nearTo - edit.from)
        errors |> List.choose (fun ((a : VSCPos,b),c as x) ->
            if edit.from <= a.line && a.line < edit.nearTo then None
            elif edit.nearTo <= a.line && adj <> 0 then Some (add_line_to_range adj (a,b),c)
            else Some x
            )
    let errors = List.append errors (process_errors edit.from (Array.toList ers))
    lines, errors

let tokenizer (state : TokenizerState) req =
    let replace edit =
        let lines, errors = tokenize_replace state.lines state.errors edit
        let blocks = wdiff_block_all state.blocks (lines, edit.lines.Length, edit.from, edit.nearTo)
        {lines=lines; errors=errors; blocks=blocks}

    let next (state : TokenizerState) = {blocks=state.blocks; errors=state.errors}, state
    match req with
    | DocumentAll text -> replace {|from=0; nearTo=state.lines.Length; lines=text|} |> next
    | DocumentEdit edit -> replace edit |> next
```

Ahhhh...what I need here is really easy. You do stupid things when you hack things just to make progress. If I want to merge the liner and tokenizer, notice that...

`{lines=lines; errors=errors; blocks=blocks}`

The lines are kept in the state here. Ah, no wait, I need the string lines.

```fs
let process_error (k,v) =
    let messages, expecteds = v |> List.distinct |> List.partition (fun x -> Char.IsUpper(x,0))
    let ex () = match expecteds with [x] -> sprintf "Expected: %s" x | x -> sprintf "Expected one of: %s" (String.concat ", " x)
    let f l = String.concat "\n" l
    if List.isEmpty expecteds then k, f messages
    elif List.isEmpty messages then k, ex ()
    else k, f (ex () :: "" :: "Other error messages:" :: messages)

let process_errors line (ers : LineTokenErrors list) : RString list =
    ers |> List.mapi (fun i l ->
        let i = line + i
        l |> List.map (fun (r,x) -> x, ({|line=i; character=r.from|}, {|line=i; character=r.nearTo|}))
        )
    |> List.concat
    |> List.groupBy snd
    |> List.map ((fun (k,v) -> k, List.map fst v) >> process_error)
```

Let me see if I can optimize this a bit. I have too manyargs all over the place.

```fs
let process_error v =
    let messages, expecteds = v |> List.distinct |> List.partition (fun x -> Char.IsUpper(x,0))
    let ex () = match expecteds with [x] -> sprintf "Expected: %s" x | x -> sprintf "Expected one of: %s" (String.concat ", " x)
    let f l = String.concat "\n" l
    if List.isEmpty expecteds then f messages
    elif List.isEmpty messages then ex ()
    else f (ex () :: "" :: "Other error messages:" :: messages)

let process_errors line (ers : LineTokenErrors list) : RString list =
    ers |> List.mapi (fun i l ->
        let i = line + i
        l |> List.map (fun (r,x) -> x, ({|line=i; character=r.from|}, {|line=i; character=r.nearTo|}))
        )
    |> List.concat
    |> List.groupBy snd
    |> List.map (fun (k,v) -> k, process_error (List.map fst v))
```

Yes, this way is better.

```fs
let tokenizer (state : TokenizerState) req =
    let replace (edit : SpiEdit) =
        if edit.nearTo <= state.lines_text.Length then
            let lines_text = PersistentVector.replace edit.from edit.nearTo edit.lines state.lines_text
            let lines_token, errors = tokenize_replace state.lines_token state.errors edit
            let blocks = wdiff_block_all state.blocks (lines_token, edit.lines.Length, edit.from, edit.nearTo)
            [], {lines_text=lines_text; lines_token=lines_token; errors=errors; blocks=blocks}
        else
            ["The edit is out of bounds and cannot be applied. The language server and the editor are out of sync. Try reopening the file being edited."], state
```

This is the only error that can really happen. The from being greater than nearTo or smaller than 0 would be compiler errors.

10:35am. Yes, this is the ideal way of doing this.

```fs
let tokenizer (state : TokenizerState) req =
    let replace (edit : SpiEdit) =
        if edit.nearTo <= state.lines_text.Length then
            let lines_text = PersistentVector.replace edit.from edit.nearTo edit.lines state.lines_text
            let lines_token, errors = tokenize_replace state.lines_token state.errors edit
            let blocks = wdiff_block_all state.blocks (lines_token, edit.lines.Length, edit.from, edit.nearTo)
            None, {lines_text=lines_text; lines_token=lines_token; errors=errors; blocks=blocks}
        else
            Some "The edit is out of bounds and cannot be applied. The language server and the editor are out of sync. Try reopening the file being edited.", state
```

Actually let me make it an option.

I am satisfied with this now.

```fs
let parse is_top_down (s : (LineTokens * ParsedBlock) list) (x : Block list) =
    let dict = Dictionary(HashIdentity.Reference)
    List.iter (fun (a,b) -> dict.Add(a,b.parsed)) s
    List.map (fun x -> x.block, {
        parsed = Utils.memoize dict (block_init is_top_down) x.block
        offset = x.offset
        }) x

type ParserRes = {lines : LineTokens; bundles : TopOffsetStatement list list; parser_errors : RString list; tokenizer_errors : RString list}
type ParserStream = abstract member Run : TokRes -> ParserRes Promise * ParserStream
let parser is_top_down =
    let run s req =
        let s = promise_thunk <| fun () -> parse is_top_down s req.blocks
        let a = s >>-* fun s ->
            let lines, bundles, parser_errors = block_bundle s
            {lines = lines; bundles = bundles; parser_errors = parser_errors; tokenizer_errors = req.errors}
        a, s
    let rec loop s =
        {new ParserStream with
            member t.Run(req) =
                let s = s()
                let a,s' = run s req
                a, loop (fun () -> if Promise.Now.isFulfilled s' then Promise.Now.get s' else s)
                }
    loop (fun () -> [])
```

The next thing I have to take care of is this.

10:45am. The stream seems complicated, but there isn't that much going on in it.

```
let parse is_top_down (s : (LineTokens * ParsedBlock) list) (x : Block list) =
    let dict = Dictionary(HashIdentity.Reference)
    List.iter (fun (a,b) -> dict.Add(a,b.parsed)) s
    List.map (fun x -> x.block, {
        parsed = Utils.memoize dict (block_init is_top_down) x.block
        offset = x.offset
        }) x
```

I find this very confusing. Why am I memoizing based off the LineTokens on that first line?

That is just a block without the offset.

```fs
Some "The edit is out of bounds and cannot be applied. The language server and the editor are out of sync. Try reopening the file being edited.", state
```

Actually, let me just return this as a bool.

```fs
let wdiff_tokenizer_init = { lines_text = PersistentVector.empty; lines_token = PersistentVector.empty; blocks = []; errors = [] }

/// Immutably updates the state based on the request. Does diffing to make the operation efficient.
/// It is possible for the server to go out of sync, in which case an error is returned.
let wdiff_tokenizer (state : TokenizerState) req =
    let replace (edit : SpiEdit) =
        if edit.nearTo <= state.lines_text.Length then
            let lines_text = PersistentVector.replace edit.from edit.nearTo edit.lines state.lines_text
            let lines_token, errors = tokenize_replace (state.lines_token, state.errors) edit
            let blocks = wdiff_block_all state.blocks (lines_token, edit.lines.Length, edit.from, edit.nearTo)
            Ok {lines_text=lines_text; lines_token=lines_token; errors=errors; blocks=blocks}
        else
            Error "The edit is out of bounds and cannot be applied. The language server and the editor are out of sync. Try reopening the file being edited."

    match req with
    | DocumentAll text -> replace {|from=0; nearTo=state.lines_text.Length; lines=text|}
    | DocumentEdit edit -> replace edit
```

I won't put comments on everything. But I will prefix all the important functions with wdiff.

```fs
Error [({|line=0; character=0|}, {|line=0; character=1|}), ExpectedAtLeastOneToken]
```

Do I really need this crappy error? How about I just leave it blank?

11:15am.

```fs
let wdiff_parse' is_top_down (s : (LineTokens * ParsedBlock) list) (x : OffsetBlock list) =
    let dict = Dictionary(HashIdentity.Reference)
    List.iter (fun (a,b) -> dict.Add(a,b.parsed)) s
    List.map (fun x -> x.block, {
        parsed = Utils.memoize dict (block_init is_top_down) x.block
        offset = x.offset
        }) x
```

This function is fine.

```fs
type ParserErrorsList = (VSCRange * ParserErrors) list
type ParseResult = Result<TopStatement,ParserErrorsList>
let parse (s : Env) : ParseResult =
```

Let me rederive the ParsedBlock again.

11:45am.

```fs
let wdiff_parse' (is_top_down, s : ({|old_unparsed_block : LineTokens; result : ParseResult; semantic_tokens : LineTokens|} Block) list)
        (unparsed_block : LineTokens Block list) =
    let dict = Dictionary(HashIdentity.Reference)
    // Offset should be ignoring when memoizing the results of parsing.
    s |> List.iter (fun x -> dict.Add(x.block.old_unparsed_block,{|result=x.block.result;semantic_tokens=x.block.semantic_tokens|}))
    List.map (fun x ->
        let r = Utils.memoize dict (parse_block is_top_down) x.block
        { block = {|r with old_unparsed_block=x.block|}; offset = x.offset }
        ) unparsed_block
```

I really struggled to make this more readable, but now the type of this should be enough to know what it is doing.

11:50am.

```fs
type ParserRes = {lines : LineTokens; bundles : TopOffsetStatement list list; parser_errors : RString list; tokenizer_errors : RString list}
type ParserStream = abstract member Run : TokRes -> ParserRes Promise * ParserStream
let parser is_top_down =
    let run s req =
        let s = promise_thunk <| fun () -> parse is_top_down s req.blocks
        let a = s >>-* fun s ->
            let lines, bundles, parser_errors = block_bundle s
            {lines = lines; bundles = bundles; parser_errors = parser_errors; tokenizer_errors = req.errors}
        a, s
    let rec loop s =
        {new ParserStream with
            member t.Run(req) =
                let s = s()
                let a,s' = run s req
                a, loop (fun () -> if Promise.Now.isFulfilled s' then Promise.Now.get s' else s)
                }
    loop (fun () -> [])
```

The next comes this. I think that `block_bundle` is really poorly named here. Also I am 90% sure that lines are supposed to be semantic tokens in fact.

I am thinking of separating the parsing aspects from the block merging aspects here.

...Yeah, I should do that. The way this is done right now is ridiculous.

11:55am. Let me take a break here."

---
## [mrakgr/The-Spiral-Language@cd36a7c3ba...](https://github.com/mrakgr/The-Spiral-Language/commit/cd36a7c3badd86a7308ecad88b7e6d901eac5814)
##### 2021-03-17 10:51:34 by Marko Grdinić

"10:15am. I am up. Let me chill a bit and then I will start.

10:35am. https://zerophilosophy.substack.com/p/rules

This article really is a lot better than that article by Moldbug scolding some guy for confusing power for truth. In that particular context I thought the guy's problem was him mistaking New York Times for power. You can always count on Land not to moralize.

Let me read Frieren and Samayoeru. After that I will start.

10:50am. Let me start.

10:55am. First I'll cut out everything in the ServerUtils apart from the code action stuff. Now, let me put down my first type definition.

```fs
type SchemaState = { schema : Schema; errors_intra : RString list; errors_inter : RString list}
```

Previously I had a couple of these schema states, all linking to one another, but now I will only have one. By reducing the number of types in use, I will radically simplify my work. For links and actions I will make separate functions that merely look at the schema and the environment. And speaking of the later, here it is.

```fs
type SchemaEnv = Map<string,SchemaState>
```

Let me make the `ModuleEnv`.

```fs
type ModuleEnv = Map<string,ModuleState>
```

Do I need anything more than this for the dirty segment? Not really. Later I'll need a map of package dir paths to their ids, but I'll leave that when the time comes to connect the clean and the dirty segments.

```fs
let ss_has_error x = (List.isEmpty x.errors_intra && List.isEmpty x.errors_inter) = false
```

Let me make this for later.

Now...I need to do validation.

```fs
let ss_validate (packages : SchemaEnv) (modules : ModuleEnv) (x : SchemaState) =
    let errors = ResizeArray()
    let rec loop = function
        | SpiProj.FileHierarchy.Directory(_,_,_,l) -> list l
        | SpiProj.FileHierarchy.File(_,(r,path),_) -> if Map.containsKey path modules = false then errors.Add(r,"Module not found.")
    and list l = List.iter loop l
    list x.schema.modules
    x.schema.packages |> List.iter (fun {path=r,path} -> if Map.containsKey path packages = false then errors.Add(r,"Package not found."))
    {x with errors_intra=Seq.toList errors}
```

Missing directories will not be errors this time. I'll just use validate after loading the schema.

Actually, let me do it like...

```fs
let ss_validate' (packages : SchemaEnv) (modules : ModuleEnv) (x : SchemaState) =
    let errors = ResizeArray()
    let rec loop = function
        | SpiProj.FileHierarchy.Directory(_,_,_,l) -> list l
        | SpiProj.FileHierarchy.File(_,(r,path),_) -> if Map.containsKey path modules = false then errors.Add(r,"Module not found.")
    and list l = List.iter loop l
    list x.schema.modules
    x.schema.packages |> List.iter (fun {path=r,path} -> if Map.containsKey path packages = false then errors.Add(r,"Package not found."))
    Seq.toList errors
let ss_validate packages modules (x : SchemaState) = {x with errors_intra=ss_validate' packages modules x}
```

Ok, good. I won't do diffing for the dirty segments as the loading demands would invalidate it.

11:25am. The next part would be to make the propagation function.

```fs
x.schema.packages |> List.iter (fun {path=r,path} -> if Map.containsKey path packages = false then errors.Add(r,"Package not found."))
```

Actually, let me move this check to propagate.

```fs
let ss_propagate (packages : SchemaEnv) (x : SchemaState) (circulars : string HashSet) (order : string []) =
    let has_error x = (List.isEmpty x.errors_intra && List.isEmpty x.errors_inter) = false
    Array.fold (fun s path ->
        match Map.tryFind path s with
        | Some (x : SchemaState) ->
            let ers =
                (x.schema.packages, []) ||> List.foldBack (fun {path=r,p} ers ->
                    if circulars.Contains p then (r,"Package is circular.") :: ers
                    else
                        match Map.tryFind p s with
                        | Some s' when has_error s' -> (r,"Package has an error.") :: ers
                        | Some _ -> ers
                        | None -> (r,"Package not found.") :: ers
                    )
            Map.add path {x with errors_inter=ers} s
        | _ -> s
        ) packages order
```

Actually, when it comes to circulars, how about I in fact separate each in its own strong component.

11:55am.

```fs
let ss_propagate (packages : SchemaEnv) (x : SchemaState) (circulars : Dictionary<string,int>) (order : string []) =
    let has_error x = (List.isEmpty x.errors_intra && List.isEmpty x.errors_inter) = false
    Array.fold (fun s path ->
        match Map.tryFind path s with
        | Some (x : SchemaState) ->
            let c p = match circulars.TryGetValue(p) with true,b -> b | false,_ -> -1
            let is_circular x = x <> -1
            let are_in_same_strong_component a b = is_circular a && is_circular b && a = b
            let ers =
                let cpath = c path
                (x.schema.packages, []) ||> List.foldBack (fun {path=r,p} ers ->
                    let cp = c p
                    if are_in_same_strong_component cpath cp then (r,"Package is circular and loops through the current one.") :: ers
                    elif is_circular cp then (r,"Package is circular.") :: ers
                    else
                        match Map.tryFind p s with
                        | Some s' when has_error s' -> (r,"Package has an error.") :: ers
                        | Some _ -> ers
                        | None -> (r,"Package not found.") :: ers
                    )
            Map.add path {x with errors_inter=ers} s
        | _ -> s
        ) packages order
```

This is really good. Let me modify the graph operation.

```fs
let circular_nodes ((abs,bas) : MirroredGraph) dirty_nodes =
    let sort_order, sort_visited = topological_sort bas dirty_nodes
    let order = sort_order.ToArray()
    let visited = HashSet()
    let circular_nodes = Dictionary()
    Array.fold (fun i a ->
        let sc = ResizeArray() // This array stores the strongly connected components.
        let rec dfs a = if sort_visited.Contains(a) && visited.Add(a) then Seq.iter dfs (links_get abs a); sc.Add a
        dfs a
        if 1 < sc.Count then
            sc |> Seq.iter (fun x -> circular_nodes.Add(x,i) |> ignore)
            i+1
        else
            i
        ) 0 order |> ignore
    order, circular_nodes
```

This is good. Previously, the way I propagated information was wrong.

```fs
                    elif is_circular cp then (r,"Package is circular.") :: ers
```

Actually, no. i need to remove this. This error will only be valid when diffing everything. After a change it would revert to the normal one.

```fs
let ss_propagate (packages : SchemaEnv) (x : SchemaState) (order : string [], circulars : Dictionary<string,int>) =
    let has_error x = (List.isEmpty x.errors_intra && List.isEmpty x.errors_inter) = false
    Array.fold (fun s path ->
        match Map.tryFind path s with
        | Some (x : SchemaState) ->
            let c p = match circulars.TryGetValue(p) with true,b -> b | false,_ -> -1
            let is_circular x = x <> -1
            let are_in_same_strong_component a b = is_circular a && is_circular b && a = b
            let ers =
                let cpath = c path
                (x.schema.packages, []) ||> List.foldBack (fun {path=r,p} ers ->
                    let cp = c p
                    if are_in_same_strong_component cpath cp then (r,"Package is circular and loops through the current one.") :: ers
                    else
                        match Map.tryFind p s with
                        | Some s' when has_error s' -> (r,"Package has an error.") :: ers
                        | Some _ -> ers
                        | None -> (r,"Package not found.") :: ers
                    )
            Map.add path {x with errors_inter=ers} s
        | _ -> s
        ) packages order
```

Yes, this is it.

```fs
type SchemaState = { schema : Schema; errors_modules : RString list; errors_packages : RString list}
```

```fs
let ss_validate_modules modules (x : SchemaState) = {x with errors_modules=ss_validate_modules' modules x}
let ss_validate_packages (packages : SchemaEnv) (x : SchemaState) (order : string [], circulars : Dictionary<string,int>) =
```

Let me change the naming. Now it is much better.

Now what comes next?

12:20pm. Well, breakfast, but before that let me at least figure out what I want to do next. I have all the pieces ready in my mind, but not the order I shuold approach them. Ok, here is what I am going to do. I'll finally connect the clean and the dirty segments. After the packages have been validated, it is the `PackageEnv`'s turn to be processed.

After that I will do with the loading.

That will give me breathing room to deal with the rest.

I should also make a function to update the mirrored graph. This is the way to go.

...

```fs
open System
open System.IO
open System.Collections.Generic

let x = Stack()
x.Push(1)
x.Push(2)
x.Push(3)

printfn "%A" (x.ToArray())
```

This prints 3,2,1...

```fs
let circular_nodes ((abs,bas) : MirroredGraph) dirty_nodes =
    let sort_order, sort_visited = topological_sort bas dirty_nodes
    let order = sort_order.ToArray()
    let visited = HashSet()
    let circular_nodes = Dictionary()
    Array.fold (fun i a ->
        let sc = ResizeArray() // This array stores the strongly connected components.
        let rec dfs a = if sort_visited.Contains(a) && visited.Add(a) then Seq.iter dfs (links_get abs a); sc.Add a
        dfs a
        if 1 < sc.Count then
            sc |> Seq.iter (fun x -> circular_nodes.Add(x,i) |> ignore)
            i+1
        else
            i
        ) 0 order |> ignore
    order, circular_nodes
```

This is the right order for calculating the strong components, but is this really what I should be returning here?

No, not it is not. I am assuming the order starts from the current node and goes outward.

```fs
open System
open System.IO
open System.Collections.Generic

let x = Queue()
x.Enqueue(1)
x.Enqueue(2)
x.Enqueue(3)

printfn "%A" (x.ToArray())
```

Yes, the queue is what I need.

```fs
let topological_sort bas dirty_nodes =
    let sort_order = Queue()
    let sort_visited = HashSet()
    let rec dfs_rev a = if sort_visited.Add(a) then Seq.iter dfs_rev (links_get bas a); sort_order.Enqueue(a)
    Seq.iter dfs_rev dirty_nodes
    sort_order, sort_visited

let circular_nodes ((abs,bas) : MirroredGraph) dirty_nodes =
    let sort_order, sort_visited = topological_sort bas dirty_nodes
    let order = sort_order.ToArray()
    let visited = HashSet()
    let circular_nodes = Dictionary()
    Array.foldBack (fun a i ->
        let sc = ResizeArray() // This array stores the strongly connected components.
        let rec dfs a = if sort_visited.Contains(a) && visited.Add(a) then Seq.iter dfs (links_get abs a); sc.Add a
        dfs a
        if 1 < sc.Count then
            sc |> Seq.iter (fun x -> circular_nodes.Add(x,i) |> ignore)
            i+1
        else
            i
        ) order 0 |> ignore
    order, circular_nodes
```

To think there was a bug here. This might have contributed to the instability. Amazing what a second pass unearths.

I can see things much more clearly now.

Let me list out the bullet points again:

* Update the `PackageEnv` after validating the `SchemaEnv` based on the order.
* Do the schema loader.
* Update the mirror graph based on the order.

Let me have breakfast here."

---
## [mrakgr/The-Spiral-Language@dabb3e8026...](https://github.com/mrakgr/The-Spiral-Language/commit/dabb3e8026dd08c6d713f35e0969b38a8f206aed)
##### 2021-03-17 10:51:34 by Marko Grdinić

"10:10am. I am up. Is the PL thread still not up yet. This is the longest I had to wait for it ever. Wow, it is still not out. Nevermind it then.

Let me chill just 5-10m.

10:25am. Let me start.

This applying to companies thing has been driving me insane. But it is good that I am going through this. I need to look at it from every available perspective.

I've been focusing too much on the benefits and too little on the disadvantages.

The disadvantage is that having sponsors would tie up my time, and once they go bust, a lot of my work would go to waste. Furthermore, most of the value captured from Spiral would go to them. Sure I could get 3k per month, but they would get large cost saving per each programmer. If using Spiral allows them to do the same kind of work with 3 programmers that would otherwise require 10, just how much would that win them.

A fair deal would be for them to pay royalties based on their cost savings. That would make my earnings astronomical.

And yet here I am getting concerned over not being taken advantage of.

What a fool I am.

10:30am. Seriously, if I still haven't crushed poker after some time, I should just make up my mind to do those 3k per month jobs for a single month. That will be enough to get me an upgrade. Hopefully Bitcoin will have crashed by that time. Its rise combined with Corona has sent computer component costs through the roof. It might not happen tomorrow, but probably by the end of next year.

3k per month is low, but I could easily get those and would not have to waste my time looking around or negotiating. That is the primary benefit of them. 6k would be better obviously, but I would not be able to get a much better rig than with 3k. Right now I do not need an upgrade.

10:35am. Now let me start.

It is finally time to do some work. This is where my real gains will come from.

I've made up my mind, I'll wait until I've gone through the MainStreamServer module and then I will just fire off the last batch of applications to everybody out there. I won't let this drag on anymore.

```fs
let cons_fulfilled l =
    let rec loop olds = function
        | Cons(old,next) when Promise.Now.isFulfilled next -> loop (PersistentVector.conj old olds) (Promise.Now.get next)
        | _ -> olds
    loop PersistentVector.empty l
type TypecheckerStream = EditorStream<ParserRes Promise, InferResult Stream>
let typechecker package_id module_id (path : string) top_env =
    let rec run old_results env i (bss : TopOffsetStatement list list) =
        match bss with
        | b :: bs ->
            match PersistentVector.tryNth i old_results with
            | Some (b', _, env as s) when b = b' -> Cons(s,Promise(run old_results env (i+1) bs))
            | _ ->
                let rec loop old_results env i = function
                    | b :: bs ->
                        let x = Infer.infer package_id module_id env (bundle_statements b)
                        let adds = match x.top_env_additions with AOpen x | AInclude x -> x
                        let _,_,env as s = b,x,Infer.union adds env
                        Cons(s,promise_thunk (fun () -> loop old_results env (i+1) bs))
                    | [] -> Nil
                loop old_results env i bss
        | [] -> Nil
    let rec loop r =
        {new TypecheckerStream with
            member _.Run(res) =
                let r = r()
                let r' =
                    r >>=* fun old_results ->
                    top_env >>= fun top_env ->
                    res >>- fun res ->
                    run (cons_fulfilled old_results) top_env 0 res.bundles
                let a = Stream.mapFun (fun (_,x,_) -> x) r'
                a, loop (fun () -> if Promise.Now.isFulfilled r' then r' else r)
            }
    loop (fun () -> Stream.nil)
```

10:45am. How complicated. Let me make a non-diffing version of this.

```fs
                        let x = Infer.infer package_id module_id env (bundle_statements b)
                        let adds = match x.top_env_additions with AOpen x | AInclude x -> x
                        let _,_,env as s = b,x,Infer.union adds env
                        Cons(s,promise_thunk (fun () -> loop old_results env (i+1) bs))
```

There 4 lines are most of the actual functionality.

```fs
let inline wdiff_fold f s x =
    let s = s()
    let p = promise_thunk_with (f s) x
    p, fun () -> if Promise.Now.isFulfilled p then Promise.Now.get p else s

let inline wdiff_mapFold f s x =
    let s = s()
    let p = promise_thunk_with (f s) x
    p >>-* fst, fun () -> if Promise.Now.isFulfilled p then snd (Promise.Now.get p) else s
```

Ah, this needs to be like so.

11:05am.

```fs
let typechecker package_id module_id top_env l : InferResult Stream =
    let rec loop env = function
        | l :: ls ->
            let x = Infer.infer package_id module_id env l
            let adds = match x.top_env_additions with AOpen x | AInclude x -> x
            let env = Infer.union adds env
            Cons(x,promise_thunk_with (loop env) ls)
        | [] ->
            Nil

    promise_thunk_with (loop top_env) l
```

This is how easy it would be without all the diff nonsense. Now let me do that as well.

11:40am.

```fs
type TypecheckerState = {
    package_id : int
    module_id : int
    top_env : TopEnv Promise
    results : (Bundle * InferResult * TopEnv) Stream
    }

let wdiff_typechecker (state : TypecheckerState) l =
    let rec loop env = function
        | l :: ls ->
            let x = Infer.infer state.package_id state.module_id env l
            let adds = match x.top_env_additions with AOpen x | AInclude x -> x
            let env = Infer.union adds env
            Cons((l,x,env),promise_thunk_with (loop env) ls)
        | [] ->
            Nil

    let rec diff env = function
        | Cons((b,_,env as x),next), b' :: bs when b = b' ->
            if Promise.Now.isFulfilled next then Cons(x,promise_thunk_with (diff env) (Promise.Now.get next,bs))
            else Cons(x,promise_thunk_with (loop env) bs)
        | _,bs -> loop env bs

    let results =
        state.top_env >>=* fun top_env ->
        state.results >>= fun r ->
        l >>- fun l -> diff top_env (r,l)
    Stream.mapFun (fun (_,x,_) -> x) results, {state with results = results}
```

Wow, just wow. This is it. This is the form I've been looking for.

This is much better than the old version. It is just so much clearer. The refactor has been worth it.

I love this. Clarity is compositional. If you do not understand one of the steps, you won't understand the follow ups either.

11:50am.

```fs
type ModuleId = int
type DiffableFileHierarchyT<'a,'b> =
    | File of path: string * name: string option * 'a
    | Directory of name: string * DiffableFileHierarchyT<'a,'b> list * 'b
type DiffableFileHierarchy =
    DiffableFileHierarchyT<
        (InferResult Stream * (ModuleId * TopEnv Promise)) option * ParserRes Promise * TypecheckerStream option,
        (ModuleId * TopEnv Promise) option
        >
type MultiFileStream = EditorStream<DiffableFileHierarchy list, Map<string,InferResult Stream> * TopEnv Promise>
```

Oh boy, now comes this.

12:40pm. I am grinding away at it.

```fs
// Rather than just throwing away the old results, diff returns the new tree with as much useful info from the old tree as is possible.
let diff_order_changed old new' =
    let mutable same_files = true
    let mutable same_order = true
    let rec elem (o,n) =
        match o,n with
        // In `n`, `meta` and `tc` fields are None.
        | File(path,name,(_,p,tc)) & o,File(path',name',(_,p',_)) when path = path' && name = name' ->
            if same_files then
                if Object.ReferenceEquals(p,p') then o
                else same_files <- false; File(path,name,(None,p',tc))
            else File(path,name,(None,p',None))
        | Directory(name,l,o), Directory(name',l',o') when name = name' -> Directory(name,list (l,l'),if same_files then o else o')
        | _, n -> same_order <- false; n
    and list = function
        | o :: o', n :: n' -> elem (o,n) :: (if same_order then list (o', n') else n')
        | [], [] -> []
        | _, n -> same_order <- false; n
    list (old,new')

let inline multi_file_run on_unchanged_file on_changed_file top_env_empty create_stream post_process_result union in_module package_id top_env files =
    let rec changed (module_id,top_env as i) x =
        match x with
        | File(path,_,(Some (r,o),_,_)) ->
            on_unchanged_file path r
            x, o
        | File(path,name,(None,res,tc)) ->
            let tc : EditorStream<_,_> = match tc with Some tc -> tc | None -> create_stream package_id module_id path top_env
            let r,tc = tc.Run res
            on_changed_file path r
            let top_env_additions =
                let adds = post_process_result r
                match name with
                | Some name -> adds >>-* in_module name
                | None -> adds
            let o = module_id+1, top_env_additions
            File(path,name,(Some (r,o),res,Some tc)),o
        | Directory(name,l,Some o) -> Directory(name,l,Some o), o
        | Directory(name,l,None) ->
            let l,(module_id,top_env_adds) = changed_list i l
            let o = module_id, top_env_adds >>-* in_module name
            Directory(name,l,Some o),o
    and changed_list (module_id,top_env) l =
        let o = module_id, Promise.Now.withValue(top_env_empty)
        let l,(_,o) =
            List.mapFold (fun (top_env, (module_id, top_env_adds as o)) x ->
                let i = module_id, top_env
                let x,(module_id,top_env_adds') = changed i x
                let union a b = a >>=* fun a -> b >>- fun b -> union a b
                let top_env = union top_env_adds' top_env
                let o = module_id, union top_env_adds' top_env_adds
                x,(top_env,o)
                ) (top_env,o) l
        l,o
    let i = 0, top_env
    let l,(_,top_env_adds) = changed_list i files
    top_env_adds, l
```

Figuring out how to simplify all of this is not an easy thing. It would be a lot easier if not for the directories.

I am getting some ideas for an alterantive design."

---
## [BroodLord/TeamProject@dae1606106...](https://github.com/BroodLord/TeamProject/commit/dae16061069e023a8172373e846003218db00355)
##### 2021-03-17 13:25:07 by Dereyabi

yo danny stop changing the god damned version of unity

love you really bby i also added a return to the axe script

---
## [nahidhasan0987/labtask2@e201626713...](https://github.com/nahidhasan0987/labtask2/commit/e2016267139c169f9c6791cb1189e6e52345169b)
##### 2021-03-17 16:28:19 by nahidhasan0987

Add files via upload

//code

<!DOCTYPE HTML>  
<html>
<head>
<style>
.error {color: #FF0000;}
</style>
</head>
<body>  

<?php
$nameErr = $emailErr = $genderErr = $dateofbirthErr =
$bloodgroup = "";
$name = $email = $gender = $dateofbirth = $bloodgroup = "";

if ($_SERVER["REQUEST_METHOD"] == "POST") {
  if (empty($_POST["name"])) {
    $nameErr = "Name is required";
  } else {
    $name = test_input($_POST["name"]);
  }
  
  if (empty($_POST["email"])) {
    $emailErr = "Email is required";
  } else {
    $email = test_input($_POST["email"]);
  }
    
  if (empty($_POST["dateofbirth"])) {
    $dateofbirth = "";
  } else {
    $dateofbirth = test_input($_POST["dateofbirth"]);
  }

  if (empty($_POST["bloodgroup"])) {
    $bloodgroup = "";
  } else {
    $bloodgroup = test_input($_POST["bloodgroup"]);
  }

  if (empty($_POST["gender"])) {
    $genderErr = "Gender is required";
  } else {
    $gender = test_input($_POST["gender"]);
  }
}

function test_input($data) {
  $data = trim($data);
  $data = stripslashes($data);
  $data = htmlspecialchars($data);
  return $data;
}
?>

<h2>Form Validation </h2>
<p><span class="error">* required field</span></p>
<form method="post" action="<?php echo htmlspecialchars($_SERVER["PHP_SELF"]);?>">  
  Name: <input type="text" name="name">
  <span class="error">* <?php echo $nameErr;?></span>
  <br><br>
  E-mail: <input type="text" name="email">
  <span class="error">* <?php echo $emailErr;?></span>
  <br><br>
  Date of Birth: <input type="date" name="dateofbirth">
  <span class="error"><?php echo $dateofbirthErr;?></span>
  <br><br>
  Blood Group: 
  <label for="bloodgroup">Choose a blood group:</label>
  <select name="bloodgroup" id="bloodgroup">
    <option value="A+">A+</option>
    <option value="A-">A-</option> 
    <option value="B+">B+</option> 
    <option value="B-">B-</option> 
    <option value="O+">O+</option> 
    <option value="O-">O-</option>
    </select>  
  <br><br>
  Gender: <input type="radio" name="gender" value="female">Female
  <input type="radio" name="gender" value="male">Male
  <input type="radio" name="gender" value="other">Other
  <span class="error">* <?php echo $genderErr;?></span>
  <br><br>
  <input type="submit" name="submit" value="Submit">  
</form>

</body>
</html>

---
## [SilentEnforcer/tgwr-mod@599fe10d8e...](https://github.com/SilentEnforcer/tgwr-mod/commit/599fe10d8e59283157de3a4291ef0f425f608c08)
##### 2021-03-17 17:03:57 by Ahmet-Samet

niggers going to bu planes

Based? Based on what? In your dick? Please shut the fuck up and use words properly you fuckin troglodyte, do you think God gave us a freedom of speech just to spew random words that have no meaning that doesn't even correllate to the topic of the conversation? Like please you always complain about why no one talks to you or no one expresses their opinions on you because you're always spewing random shit like poggers based cringe and when you try to explain what it is and you just say that it's funny like what? What the fuck is funny about that do you think you'll just become a stand-up comedian that will get a standing ovation just because you said "cum" in the stage? HELL NO YOU FUCKIN IDIOT, so please shut the fuck up and use words properly you dumb bitch.

---
## [Buildstarted/linksfordevs@3f0889a6fd...](https://github.com/Buildstarted/linksfordevs/commit/3f0889a6fd02f810342884eaf3e00366130bec9c)
##### 2021-03-17 23:12:19 by Ben Dornis

Updating: 3/17/2021 11:00:00 PM

 1. Added: Audacity 3.0.0 Released
    (https://www.audacityteam.org/audacity-3-0-0-released/)
 2. Added: It's Been Decades. Why Don't Databases Manage Themselves Yet? - Brent Ozar Unlimited®
    (https://www.brentozar.com/archive/2021/03/its-been-decades-why-dont-databases-manage-themselves-yet/)
 3. Added: Principles of Developer Experience | Christoph Nakazawa
    (https://cpojer.net/posts/principles-of-devx)
 4. Added: Snapshots in Event Sourcing for Rehydrating Aggregates
    (https://codeopinion.com/snapshots-in-event-sourcing-for-rehydrating-aggregates/)
 5. Added: CUPID – the back story
    (https://dannorth.net/2021/03/16/cupid-the-back-story/)
 6. Added: Feared by Default
    (https://andrew.im/essays/feared-by-default)
 7. Added: A Survey of Existing and Proposed TLS Visibility Solutions – Pomcor
    (https://pomcor.com/2021/01/21/a-survey-of-existing-and-proposed-tls-visibility-solutions/)
 8. Added: Performance and Polish with NuGet 5.9 | The NuGet Blog
    (https://devblogs.microsoft.com/nuget/performance-and-polish-with-nuget-5-9/)
 9. Added: The Carta SAFE for Seed Rounds - Silicon Hills Lawyer
    (https://siliconhillslawyer.com/2021/03/08/the-carta-safe-seed-rounds/)
10. Added: New Video Series: Coding Shorts
    (http://wildermuth.com/2021/03/17/New-Video-Series-Coding-Shorts)
11. Added: You might not need centralized continuous integration
    (https://dafoster.net/articles/2021/03/16/you-might-not-need-centralized-continuous-integration/)
12. Added: Living Like It's 99: No Social Media, No Smartphone
    (https://www.alvarez.io/posts/living-like-its-99/)
13. Added: 17 (ever so slightly) weird facts about the most popular dictionary format
    (https://zverok.github.io/blog/2021-03-16-spellchecking-dictionaries.html)
14. Added: My father died 23 years ago, his voice is now an NFT — Ryan Mercer's Thoughts
    (https://www.ryanmercer.com/ryansthoughts/2021/3/15/my-father-died-23-years-ago-his-voice-is-now-an-nft)
15. Added: How to Back Up Your Signal Conversations
    (https://ronitray.xyz/posts/signal-backup.html)
16. Added: Why I Love Making Other People Rich With their Silly Trading Strategy! | Strategic Options
    (https://www.strategic-options.com/insight/2021/03/09/why-i-love-making-other-people-rich-with-their-silly-trading-strategy/)

Generation took: 00:12:05.4545054

---

# [<](2021-03-16.md) 2021-03-17 [>](2021-03-18.md)

