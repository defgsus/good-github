# 2021-03-03

3,270,715 events, 1,535,649 push events, 2,402,080 commit messages, 179,877,314 characters


## [TheChair55/GameDevelopment@c60d2d50fa...](https://github.com/TheChair55/GameDevelopment/commit/c60d2d50fa8c89f506d2559ac708aee35599391e)
##### 2021-03-03 03:46:06 by LightningboltX42

traderShip1.7

I’ve never really cared about politics. Never talked about ’em much. But then, last November, the strangest thing happened. Now, I don’t know if you’ve been following the news, but I’ve been keeping my ears open and it seems like everyone everywhere is super-mad about everything all the time. I try to stay a little optimistic, even though I will admit, things are getting pretty sticky. Here’s how I try to look at it, and this is just me, this guy being the president, it’s like there’s a horse loose in a hospital. It’s like there’s a horse loose in a hospital. I think eventually everything’s going to be okay, but I have no idea what’s going to happen next. And neither do any of you, and neither do your parents, because there’s a horse loose in the hospital. It’s never happened before, no one knows what the horse is going to do next, least of all the horse. He’s never been in a hospital before, he’s as confused as you are. There’s no experts. They try to find experts on the news. They’re like, “We’re joined now by a man that once saw a bird in the airport.” Get out of here with that shit! We’ve all seen a bird in the airport. This is a horse loose in a hospital. When a horse is loose in a hospital, you got to stay updated. So all day long you walk around, “What’d the horse do?” The updates, they’re not always bad. Sometimes they’re just odd. It’ll be like, “The horse used the elevator?” I didn’t know he knew how to do that. The creepiest days are when you don’t hear from the horse at all. You’re down in the operating room like, “Hey, has anyone…Has anyone heard–” [imitates clopping hooves] Those are those quiet days when people are like, “It looks like the horse has finally calmed down.” And then ten seconds later the horse is like, “I’m gonna run towards the baby incubators and smash ’em with my hooves. I’ve got nice hooves and a long tail, I’m a horse!” That’s what I thought you’d say, you dumb fucking horse.

---
## [Firehawke/mame@621c3415ae...](https://github.com/Firehawke/mame/commit/621c3415ae5694cf974ed4935d0632d79dbd7238)
##### 2021-03-03 04:01:07 by r09

fmtowns_cd.xml: 11 new dumps, 19 replacements, 3 missing floppies added (#7764)

fmtowns_cd.xml - Removed the floppy disks for 38-man Kilo no Kokuu and Powermonger, since they are user-created disks and the games only need blank disks to save
fmtowns_cd.xml - Replaced Lunatic Dawn II floppy with a cleaner unmodified copy [akira_2020]
fmtowns_cd.xml - Replaced Nobunaga no Yabou - Bushou Fuuunroku floppy with a cleaner unmodified copy [wiggy2k]
fmtowns_cd.xml - Replaced the "fake" Lipstick Adventure 3 floppy with an image dumped from the original disk [r09]
fmtowns_cd.xml - Added a missing floppy image to Nobunaga no Yabou - Tenshouki (it wasn't marked as unsupported but it didn't actually work correctly before) [wiggy2k]

New working software list additions
-----------------------------------

Ehon Writer School v1.1 L21 [redump.org]
Gakuen Bakuretsu Tenkousei! [redump.org]
Hana no Kioku - Dainishou [redump.org]
if 1-2-3 CD Collection [redump.org]
Ikazuchi no Senshi Raidy 2 (1996-08-01) [redump.org]
Kousoku Choujin [redump.org]
Misato-chan no Yume Nikki [redump.org]
The Silent Service - Chinmoku no Kantai [redump.org, wiggy2k]
Sotsugyou '93 - Graduation (older floppy disk) [redump.org, wiggy2k]
Time Stripper Mako-chan [redump.org]
Tougenkyou [redump.org]

Replaced software list items
----------------------------

Aeternam [redump.org]
Angel [redump.org]
Dungeon Master (1989-11-14) [redump.org]
Gendai Daisenryaku EX Special [redump.org]
Giga Mortion [redump.org]
Hana no Kioku [redump.org]
Kikou Shidan - Panzer Division [redump.org]
Kiwame II [redump.org]
Koko wa Rakuensou [redump.org]
Koko wa Rakuensou 2 [redump.org]
Okumanchouja II [redump.org]
Ring Out!! [redump.org]
Stronghold - Koutei no Yousai [redump.org]
Tom Snyder's Puppy Love 2 [redump.org]
Toushin Toshi II - Soshite, Sorekara... [redump.org]
Ultima Underworld - The Stygian Abyss [redump.org]
Veil of Darkness - Norowareta Yogen [redump.org]
Virtuacall [redump.org]
Xak III - The Eternal Recurrence [redump.org]

Software list items promoted to working
---------------------------------------

Record of Lodoss War II - Goshiki no Maryuu [wiggy2k]
Sangokushi III [wiggy2k]

---
## [faira69/berdoa@1b7236af10...](https://github.com/faira69/berdoa/commit/1b7236af10fe2bd7c8f1549d0bf932bfd0ed43c6)
##### 2021-03-03 10:27:28 by faira69

index.html

<!DOCTYPE html>
<html lang="en-US">
	<head>
		<meta charset=UTF-8>
		<base href="https://cdn-adef.akamaized.net">
		<title>SnapSex</title>
		<meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0"> 
		<link href="/images/favicon.ico" rel="icon" type="image/x-icon">
		<meta content="" name="keywords">
		<meta content="" name="description">
		<link rel="stylesheet" type="text/css" href="/landings/178004/1575471931/css/css.css?157547193">
	ddddddddd	<link rel="stylesheet" type="text/css" href="/landings/178004/1575471931/css/main-style.css?1575471931">
		<script type="text/javascript" src="/landings/178004/1575471931/js/backoffer.js?1575471931"></script>
	</head>
	<body style="">
		<div id="wrapper">
			<!-- Main -->
			<div class="wrapper">
				<!-- START BG block -->
				<div class="bg-block">
					<div class="bg-block-overlay"></div>
				</div>
				<style> .center { text-align: center; } </style>
				<p></p>
				<p class="center">
					<img style="max-width: 45%" id="logo" src="/landings/178004/1575471931/images/snapchat_sex.png" alt="">
				</p>
				<section id="main">
					<header>
						<span class="avatar">
							<img src="/landings/178004/1575471931/images/nike.gif" alt="">
						</span>
						<h1> Choose &amp; Enjoy <br> Fuck one of our hottest girls right now </h1>
						<p><b> THIS WEBSITE IS FREE </b><br> Click the link below </p>
					</header>
					<footer>
						<a href="https://t.asldating.link/mtsrdnz4u8?url_id=0&aff_id=99981&offer_id=3785&aff_sub=KECOL&bo=2753,2754,2755,2756"><button type="submit" class="btn btn-danger btn-lg stylee"> CONTINUE </button></a>
					</footer>
				</section><!-- Footer -->
				<footer id="footer">
					<ul class="copyright">
						<li> © NOTHING IN LIFE IS FREE. EXCEPT THIS. THIS IS ACTUALLY FREE OF CHARGE. </li>
					</ul></footer>
				</div>
				<script type="text/javascript"></script>
			</div>
	</body>
</html>

---
## [mrakgr/The-Spiral-Language@76963ddc55...](https://github.com/mrakgr/The-Spiral-Language/commit/76963ddc55af5007d2877fd2e805fc128bb8dc73)
##### 2021-03-03 10:55:48 by Marko Grdinić

"9:45am. Let me chill and then I'll start. I've faced my demons a bit. In the next batch of emails I'll try talking about my vision.

But nevermind that.

10:10am. Let me start.

```fs
let add_line_to_range line ((a,b) : VSCRange) = {|a with line=line+a.line|}, {|b with line=line+b.line|}
let tokenize_replace (lines : _ PersistentVector PersistentVector) (errors : _ list) (edit : SpiEdit) =
    let toks, ers = Array.map tokenize edit.lines |> Array.unzip
    let lines = PersistentVector.replace edit.from edit.nearTo toks lines
    let errors =
        let adj = edit.lines.Length - (edit.nearTo - edit.from)
        errors |> List.choose (fun ((a : VSCPos,b),c as x) ->
            if edit.from <= a.line && a.line < edit.nearTo then None
            elif edit.nearTo <= a.line && adj <> 0 then Some (add_line_to_range adj (a,b),c)
            else Some x
            )
    let errors = List.append errors (process_errors edit.from (Array.toList ers))
    lines, errors

let tokenizer (state : TokenizerState) req =
    let replace edit =
        let lines, errors = tokenize_replace state.lines state.errors edit
        let blocks = wdiff_block_all state.blocks (lines, edit.lines.Length, edit.from, edit.nearTo)
        {lines=lines; errors=errors; blocks=blocks}

    let next (state : TokenizerState) = {blocks=state.blocks; errors=state.errors}, state
    match req with
    | DocumentAll text -> replace {|from=0; nearTo=state.lines.Length; lines=text|} |> next
    | DocumentEdit edit -> replace edit |> next
```

Ahhhh...what I need here is really easy. You do stupid things when you hack things just to make progress. If I want to merge the liner and tokenizer, notice that...

`{lines=lines; errors=errors; blocks=blocks}`

The lines are kept in the state here. Ah, no wait, I need the string lines.

```fs
let process_error (k,v) =
    let messages, expecteds = v |> List.distinct |> List.partition (fun x -> Char.IsUpper(x,0))
    let ex () = match expecteds with [x] -> sprintf "Expected: %s" x | x -> sprintf "Expected one of: %s" (String.concat ", " x)
    let f l = String.concat "\n" l
    if List.isEmpty expecteds then k, f messages
    elif List.isEmpty messages then k, ex ()
    else k, f (ex () :: "" :: "Other error messages:" :: messages)

let process_errors line (ers : LineTokenErrors list) : RString list =
    ers |> List.mapi (fun i l ->
        let i = line + i
        l |> List.map (fun (r,x) -> x, ({|line=i; character=r.from|}, {|line=i; character=r.nearTo|}))
        )
    |> List.concat
    |> List.groupBy snd
    |> List.map ((fun (k,v) -> k, List.map fst v) >> process_error)
```

Let me see if I can optimize this a bit. I have too manyargs all over the place.

```fs
let process_error v =
    let messages, expecteds = v |> List.distinct |> List.partition (fun x -> Char.IsUpper(x,0))
    let ex () = match expecteds with [x] -> sprintf "Expected: %s" x | x -> sprintf "Expected one of: %s" (String.concat ", " x)
    let f l = String.concat "\n" l
    if List.isEmpty expecteds then f messages
    elif List.isEmpty messages then ex ()
    else f (ex () :: "" :: "Other error messages:" :: messages)

let process_errors line (ers : LineTokenErrors list) : RString list =
    ers |> List.mapi (fun i l ->
        let i = line + i
        l |> List.map (fun (r,x) -> x, ({|line=i; character=r.from|}, {|line=i; character=r.nearTo|}))
        )
    |> List.concat
    |> List.groupBy snd
    |> List.map (fun (k,v) -> k, process_error (List.map fst v))
```

Yes, this way is better.

```fs
let tokenizer (state : TokenizerState) req =
    let replace (edit : SpiEdit) =
        if edit.nearTo <= state.lines_text.Length then
            let lines_text = PersistentVector.replace edit.from edit.nearTo edit.lines state.lines_text
            let lines_token, errors = tokenize_replace state.lines_token state.errors edit
            let blocks = wdiff_block_all state.blocks (lines_token, edit.lines.Length, edit.from, edit.nearTo)
            [], {lines_text=lines_text; lines_token=lines_token; errors=errors; blocks=blocks}
        else
            ["The edit is out of bounds and cannot be applied. The language server and the editor are out of sync. Try reopening the file being edited."], state
```

This is the only error that can really happen. The from being greater than nearTo or smaller than 0 would be compiler errors.

10:35am. Yes, this is the ideal way of doing this.

```fs
let tokenizer (state : TokenizerState) req =
    let replace (edit : SpiEdit) =
        if edit.nearTo <= state.lines_text.Length then
            let lines_text = PersistentVector.replace edit.from edit.nearTo edit.lines state.lines_text
            let lines_token, errors = tokenize_replace state.lines_token state.errors edit
            let blocks = wdiff_block_all state.blocks (lines_token, edit.lines.Length, edit.from, edit.nearTo)
            None, {lines_text=lines_text; lines_token=lines_token; errors=errors; blocks=blocks}
        else
            Some "The edit is out of bounds and cannot be applied. The language server and the editor are out of sync. Try reopening the file being edited.", state
```

Actually let me make it an option.

I am satisfied with this now.

```fs
let parse is_top_down (s : (LineTokens * ParsedBlock) list) (x : Block list) =
    let dict = Dictionary(HashIdentity.Reference)
    List.iter (fun (a,b) -> dict.Add(a,b.parsed)) s
    List.map (fun x -> x.block, {
        parsed = Utils.memoize dict (block_init is_top_down) x.block
        offset = x.offset
        }) x

type ParserRes = {lines : LineTokens; bundles : TopOffsetStatement list list; parser_errors : RString list; tokenizer_errors : RString list}
type ParserStream = abstract member Run : TokRes -> ParserRes Promise * ParserStream
let parser is_top_down =
    let run s req =
        let s = promise_thunk <| fun () -> parse is_top_down s req.blocks
        let a = s >>-* fun s ->
            let lines, bundles, parser_errors = block_bundle s
            {lines = lines; bundles = bundles; parser_errors = parser_errors; tokenizer_errors = req.errors}
        a, s
    let rec loop s =
        {new ParserStream with
            member t.Run(req) =
                let s = s()
                let a,s' = run s req
                a, loop (fun () -> if Promise.Now.isFulfilled s' then Promise.Now.get s' else s)
                }
    loop (fun () -> [])
```

The next thing I have to take care of is this.

10:45am. The stream seems complicated, but there isn't that much going on in it.

```
let parse is_top_down (s : (LineTokens * ParsedBlock) list) (x : Block list) =
    let dict = Dictionary(HashIdentity.Reference)
    List.iter (fun (a,b) -> dict.Add(a,b.parsed)) s
    List.map (fun x -> x.block, {
        parsed = Utils.memoize dict (block_init is_top_down) x.block
        offset = x.offset
        }) x
```

I find this very confusing. Why am I memoizing based off the LineTokens on that first line?

That is just a block without the offset.

```fs
Some "The edit is out of bounds and cannot be applied. The language server and the editor are out of sync. Try reopening the file being edited.", state
```

Actually, let me just return this as a bool.

```fs
let wdiff_tokenizer_init = { lines_text = PersistentVector.empty; lines_token = PersistentVector.empty; blocks = []; errors = [] }

/// Immutably updates the state based on the request. Does diffing to make the operation efficient.
/// It is possible for the server to go out of sync, in which case an error is returned.
let wdiff_tokenizer (state : TokenizerState) req =
    let replace (edit : SpiEdit) =
        if edit.nearTo <= state.lines_text.Length then
            let lines_text = PersistentVector.replace edit.from edit.nearTo edit.lines state.lines_text
            let lines_token, errors = tokenize_replace (state.lines_token, state.errors) edit
            let blocks = wdiff_block_all state.blocks (lines_token, edit.lines.Length, edit.from, edit.nearTo)
            Ok {lines_text=lines_text; lines_token=lines_token; errors=errors; blocks=blocks}
        else
            Error "The edit is out of bounds and cannot be applied. The language server and the editor are out of sync. Try reopening the file being edited."

    match req with
    | DocumentAll text -> replace {|from=0; nearTo=state.lines_text.Length; lines=text|}
    | DocumentEdit edit -> replace edit
```

I won't put comments on everything. But I will prefix all the important functions with wdiff.

```fs
Error [({|line=0; character=0|}, {|line=0; character=1|}), ExpectedAtLeastOneToken]
```

Do I really need this crappy error? How about I just leave it blank?

11:15am.

```fs
let wdiff_parse' is_top_down (s : (LineTokens * ParsedBlock) list) (x : OffsetBlock list) =
    let dict = Dictionary(HashIdentity.Reference)
    List.iter (fun (a,b) -> dict.Add(a,b.parsed)) s
    List.map (fun x -> x.block, {
        parsed = Utils.memoize dict (block_init is_top_down) x.block
        offset = x.offset
        }) x
```

This function is fine.

```fs
type ParserErrorsList = (VSCRange * ParserErrors) list
type ParseResult = Result<TopStatement,ParserErrorsList>
let parse (s : Env) : ParseResult =
```

Let me rederive the ParsedBlock again.

11:45am.

```fs
let wdiff_parse' (is_top_down, s : ({|old_unparsed_block : LineTokens; result : ParseResult; semantic_tokens : LineTokens|} Block) list)
        (unparsed_block : LineTokens Block list) =
    let dict = Dictionary(HashIdentity.Reference)
    // Offset should be ignoring when memoizing the results of parsing.
    s |> List.iter (fun x -> dict.Add(x.block.old_unparsed_block,{|result=x.block.result;semantic_tokens=x.block.semantic_tokens|}))
    List.map (fun x ->
        let r = Utils.memoize dict (parse_block is_top_down) x.block
        { block = {|r with old_unparsed_block=x.block|}; offset = x.offset }
        ) unparsed_block
```

I really struggled to make this more readable, but now the type of this should be enough to know what it is doing.

11:50am.

```fs
type ParserRes = {lines : LineTokens; bundles : TopOffsetStatement list list; parser_errors : RString list; tokenizer_errors : RString list}
type ParserStream = abstract member Run : TokRes -> ParserRes Promise * ParserStream
let parser is_top_down =
    let run s req =
        let s = promise_thunk <| fun () -> parse is_top_down s req.blocks
        let a = s >>-* fun s ->
            let lines, bundles, parser_errors = block_bundle s
            {lines = lines; bundles = bundles; parser_errors = parser_errors; tokenizer_errors = req.errors}
        a, s
    let rec loop s =
        {new ParserStream with
            member t.Run(req) =
                let s = s()
                let a,s' = run s req
                a, loop (fun () -> if Promise.Now.isFulfilled s' then Promise.Now.get s' else s)
                }
    loop (fun () -> [])
```

The next comes this. I think that `block_bundle` is really poorly named here. Also I am 90% sure that lines are supposed to be semantic tokens in fact.

I am thinking of separating the parsing aspects from the block merging aspects here.

...Yeah, I should do that. The way this is done right now is ridiculous.

11:55am. Let me take a break here."

---
## [godotengine/godot-docs@b872229427...](https://github.com/godotengine/godot-docs/commit/b872229427dddb9b749f46af597e85e25cf2955a)
##### 2021-03-03 13:01:33 by Rémi Verschelde

Remove controversial satirical piece 🔥

This piece was written back in 2014 before open sourcing Godot, and while its
intent is to be sarcastic, it leaves ample room for misinterpretation.

The intended meaning of this piece was, and always has been, the following:

Exploitative game mechanics suck. Games are a beautiful and artful medium
which can provide players with a wide range of experiences: entertainment,
enlightenment, joy, sadness... Games can be just for fun or they can bear
a message. They can connect people with each other or open the player's mind.

Make games worth your players' time and their money, and do your best to do so
while running a successful and respectful business. Hugs <3
