# [<](2021-02-08.md) 2021-02-09 [>](2021-02-10.md)

2,922,661 events, 1,436,381 push events, 2,304,234 commit messages, 180,641,462 characters


## [TheFurryFeline/YWPolarisVore@fc91485466...](https://github.com/TheFurryFeline/YWPolarisVore/commit/fc91485466cb1b6be160150b67edefc31d8f5737)
##### 2021-02-09 00:30:41 by Wickedtemp

ML3M Rebalancing

Originally, the ML3M was intended to be a little bit stronger. The healing values for the Brute, Burn, Omni, Toxin, and Antirad cells, have been adjusted according to what was initially planned. 
Base Tier's now heal 10 per shot, for a total of 40 damage healed, up from 20.
Second Tier's now heal 20, instead of 10.
Third Tier's heal 40, instead of 20. 

Omni 1 heals 5's for brute, burn, and toxin, and 30 for oxy, up from half those values. Omni 2, is 10's and 60, and Omni 3 is 20's and 120. 

Antirad Cell had its toxin heal bumped up from 2.5 to 5, and its radiation-heal from 150, to 350. I wasn't originally going to touch this one, but the text said "It's 150 because that's equal to five units of arithrazine", and... it wasn't. So, I bumped it up to actually be equal to 5u of Arithrazine's worth of radiation healing.

Stabilizer Cell, CorpseMend, Resistance, Haste, and the size-changing cells, were not touched.
The reasons for this are as follows:

- The healing laser was simply not strong enough to ever tend to more than one patient. Healing 20-40 damage per cell just isn't enough, even if you had several clips full of cells, it just wasn't viable.
- As a result of this, it was seldom if ever used. Field Medics rarely if ever took it with them. In nearly every round I've played, it was left exactly where it was spawned, collecting dust. 
- I'd like to make it a more proper treatment option. It wouldn't be equal to reagents used in your usual Medbay setting, or surgical repair, but if it's modified to actually fulfill its niche as a rapid, contact-free treatment option, it could be relied on more by Field Medics. There is so much potential for this device as an "in the field" healing tool, and I'd like to see it done well. We have no shortage of people who would like to see non-chemical-based treatment options. We might as well make it useful enough to actually use.

Here are a few issues people brought up in Discord when I floated this idea.
"But, Tempest, you're doubling everything? That's a huge change! Won't this result in the ML3M overshadowing other treatment options?"
Certainly not. Currently, with tier-2 cells that only heal up to 40 damage, this is actually worse than basic first-aid in terms of raw healing ability, as the cutoff for first aid healing is 50 damage on a limb. First aid and reagents will still be the most convenient, most readily available, and overall most-used manner of treatment for injuries that can be treated using those methods. All this change would do is allow the ML3M to also have its uses, and stop being overshadowed by everything else. 

"Okay, but what if it DOES actually become The New Meta and becomes the favored tool for healing?"
I wouldn't see it as an issue if Chemistry gets dethroned, in all honesty. They'd both take quite a bit of prep-work to use. You have to make multiples of every chem if you want a solid stock, and you'd need multiples of every cell if you want proper coverage and healing-ability, since even with these changes you're expending 1-3 cells per patient. And, unless you get multiple ML3M's made, only folks who are gonna have one are the CMO, and whoever nabs the spawned one first. 

"But wouldn't this result in less departmental cooperation between Medical and Science now that Medical will require fewer cells?"
Most likely, no. If anything, I'd think there would be an increase, round-to-round, if this becomes a more viable and wanted tool, more people will ask for cells. Personally, my list of requested cells would stay the same, but I'd be sending that request in more often since I know it'll actually be useful rather than having it just to have it. Tier 2 cells are still going to be desirable, and I'm still probably not going to order Tier 3's because of the cost, but that's just me. It's still going to be incredibly weak at roundstart, and better cells will be that much nicer to obtain.

"But Tempest! If you get the highest tiers of cells, and a lot of them, you could fix anything that doesn't require surgery!"
Well, if Science had the time and mats, then sure, you could gather up a large enough collection of cells, and you probably could indeed do this for one or two badly injured patients... ... ...and I could accomplish the same goal if I'm given 20 seconds in a chem-lab. The ML3M is more costly to use, the cells cost resources, have to be recharged after 4 shots, and you only start with a base tier Burn, Brute, and Stabilizer cell. Each shot from a base level burn/brute cell is the equivalent of 1.25u of bicaridine or kelotane. This change would make it 2.5. Base level cells are still going to be next to useless for anything other than the most minor of injuries. Chemistry will still be the dominating powerhouse it always has been, but at least you can use this tool, provided the PR goes through, instead, more often.

"Tempest, this thing just wasn't intended to be used to fully heal people..."
A couple people have said this, and to be honest, it's silly. In our medical system, there's very little distinction between what can "heal a little bit" and what can "heal fully", because it all comes down to the fact that everything works off of damage values. If Option A heals 5 damage, and Option B heals 50... Both are capable of "healing fully" if you have enough Option A, it's just a question as to whether or not that's practical. Currently, the ML3M's healing values can't really even be used to even partially heal injuries, unless you have a large number of cells. You'd expend all of your charges on one patient and then you've got a paperweight taking up storage space until you can get to a recharger. 

Now, as for issues that I personally see? Biggest one is probably the Toxin cell. If I remlember correctly, the base Toxin cell is the same tech requirement as the Second Tier Brute/Burn cells. This PR doesn't fix that, and I don't really see it as a huge priority since I don't think anyone uses the toxin cells as it is, but yeah. Might need to be fixed at some point if this PR goes through.

And, absolute worst case scenario, let's say that this PR screws everything up, turns the Tether upside down, and now Medbay is dominated by a bunch of blue laser beams flying everywhere like it's the new Star Wars Trilogy (but actually better because those movies kinda set a low bar)... this PR was really easy to do. The only long part about it was typing all of this up. We can just bump the numbers down if this ends up sucking really bad, ezpz.

Thank you for coming to my ted talk.

---
## [RainierEH/Carrier-Server@dcd2f1ca8e...](https://github.com/RainierEH/Carrier-Server/commit/dcd2f1ca8e932dab9746c6e8492e50796cb4d427)
##### 2021-02-09 00:58:33 by RainierEH

FUCKING KILL ME CHRIST I HATE THIS GOD DAMN PROJECT JUST END MY SUFFERING (I'm still fucking trying to import mysql drivers)

---
## [lyft/rules_kotlin@15dd1de6dd...](https://github.com/lyft/rules_kotlin/commit/15dd1de6dd1431c5d2f7d2d7f1179a951d63a328)
##### 2021-02-09 06:34:59 by Christian Edward Gruber

Expose kotlinc's -Xfriend-paths to all jvm/android kt rules under the attribute 'assocates=' (#465)

Associates lets a library associate it self to other libraries, making them part of the same module. This is constrained such that while multiple libraries may be associated, they must all shard the same module, and so cannot associate to anything that is part of a different module. These module relationships are in the bazel build graph, not the contents of the jars as such.

This module membership is transitive (within the above-mentioned constraint), though strict-deps would stop that. Also, only kotlin targets can be associated.

Per discussions across several media, the name "associates" was chosen over "friends" (despite the kotlinc flag being -Xfriend-paths) as that is the terminology used in the gradle kotlin plugin, which is kotlin's primary delivery vehicle, and to avoid confusion with the C++ friends concepts. The pre-existing "friends" attribute is preserved for backward compatibility with a warning. Future PR will add a flag to turn off that support, and then we'll delete it.

kt_jvm_import does not include this facility, but these can just set their module_name in common to participate.

Android should work, but because kt_android_* is a macro not a rule, the implicit target //my/android/library:mytarget_kt should be friended, since it has a KtJvmInfo. The //my/android/library will macro-resolve into an android_library. Until the android rules get the right kind of love, such that we can make a rule that has KtJvmInfo AND android-whatever providers, this simply is a known limitation we'll have to live with.

Also, the prior implementation shoved the full transitive closure (all jars, kotlin or no) of the friend= into the -Xfriends-paths flag, which is awful. This PR does break that, in case people were relying on that by some oddity. The fix is to just add the targets directly.

Fixes #211

---
## [BioOnPC/Metamorphosis@f1180be210...](https://github.com/BioOnPC/Metamorphosis/commit/f1180be2104e803feee954b896cc8bcfb5598771)
##### 2021-02-09 07:22:09 by Wildebee

we didnt wanna push until we had the cool effect for repentance done but crown cranium demands it

- racing thoughts got tweaked AGAIN ooUAUUGh. it shouldnt be as nuts as before ( hopefully )
- polish for various crown cranium effects
- camoflauge and displacement  now undo their stat changing stuff on skill_lose
- mechanics for repentance spawning have been changed to be more forgiving and also work if you didnt have any curse
- resurrection now works if you have it on characters that arent skeleton while not in coop ( just for u, gepsi )
- secret stash now makes sure not to slap soda machines on top of chests
- cultra updates courtesy of yokin
- sprite updates woo

---
## [ZH-Hristov/GMOD-Material-Editor-2@e94a2d961c...](https://github.com/ZH-Hristov/GMOD-Material-Editor-2/commit/e94a2d961c6231120ba04c746c57e11f669c8864)
##### 2021-02-09 10:48:21 by Zhivko Hristov

oh god what the fuck did i do

please dont use this it's horrible

---
## [mrakgr/The-Spiral-Language@2b22c3c169...](https://github.com/mrakgr/The-Spiral-Language/commit/2b22c3c169fd72fdaffe0ac6006bc49a2c8ac3d0)
##### 2021-02-09 11:42:45 by Marko Grdinić

"10:15am. It is the long awaited go-to-the-bank day. Shortly before 4pm I'll have to go out of the house for an hour or two.

10:20am. Let me do my morning reading. I'll do programming later.

10:30am. https://mangadex.org/title/44529/jk-musou-owaru-sekai-no-sukuikata

Tomoko in a Zombie apocalypse. I enjoy crazy, violent female leads in shonen-type works a bit too much.

Let me catch up with Satanophany and I will start programming. I've had a ton of time to think about how I want things to work. Today, I will get the games out of the way at least. Maybe I will do a few of them even.

10:45am. It is time to start.

```
union card = King | Queen | Jack
union player = PlayerOne | PlayerTwo
type chips = i32
type raise = u8
union observation =
    | HoleCard: card For: player
    | CommunityCard: card
    | Call | Raise | Fold
    | Reward: chips

inl GameSettings = {
    round_one_raise = 2 : chips
    round_two_raise = 4 : chips
    max_raises_per_round = 2 : raise
    }

union kuhn_state =
    | Init
    | RoundOne: {pot : chips * chips; hands : card * card; raises_left : raise; waiting_for : player}
    | RoundTwo: {pot : chips * chips; hands : card * card; community_card : card; raises_left : u8; waiting_for : player}

inl shuffle (x : array _) : () =
    !!!!Import("numpy.random")
    $"numpy.random.default_rng(!x)"

// TODO: Make a proper array literal so I can write this as ![King; King; Queen; Queen; Jack; Jack]
inl InitialDeck = arrayu64.init 6 (fun i => match i / 2 with 0 => King | 1 => Queen | _ => Jack)
// inl sample_with_replacement (x : array card) : card * array card = failwith "TODO"
inl get_random_community_card (hands : card * card) : card = failwith "TODO"

inl game _ = ()

// inl normalize forall t. (x : array (t * f64)) : array (t * f64) = failwith "TODO"
// inl sample forall t. (x : array (t * f64)) : t = failwith "TODO"

inl main() =
    ()
```

Let me get rid of all of this. I'll start from scratch.

```
inl game init_deck {chance_all chance action terminal} =
    ()
```

I spent a lot of time thinking about this. As it turns out, the main inspiration was my CFR work from late 2019. I actually came close to the ideal form near the end of that experiment, but I stopped just a step short of reaching it.

In fact, last time I did end up with the feeling of reaching my limit. I worked a lot on that, so unfortunately, I thought I was done with it. Because I could not go far enough, I ended up thinking that was how far things could go. So my initial thoughts was to try to find an alternative way.

I had to churn away at it in order to get past my misconceptions.

I am happy though that the work I did last time is sound as a base. That means I did not waste my time doing it.

If I had not gone through that, I would be so much poorer now as a result. I'd actually need to put in all of that effort now. But instead I have the experience pushing me on.

11:05am. Now if I can stop surfing 4chan, I'd be able to get some work done.

```
inl sample forall t. (x : array t) : t = failwith "TODO"
inl sample_with_replacement forall t. (x : array t) : t * array t = failwith "TODO"

inl game init_deck {draw_all draw action terminal} =
    ()
```

Let me make a draw node instead of the plain chance node. No need to complicate things here.

All of this is really annoying though. I need my own library of immutable data structures. I also need dictionaries and array library functions. Maybe Python has something, but with Python I do not have integration with equality, hashing and comparison. The integration is only halfway right now. How annoying.

11:20am.

```
action p1 [Call, Raise] fun action =>
```

This is unbearable. I really need to put in the array and list literals.

TODO: List and array patterns and literals.

Forget the patterns, but I will do literals right now. Unlike F#, I'll make arrays the default []. I'll make lists ![] rather than having || inside. [||] would actually be fairly hard to parse.

...No, I'll make ![] arrays.

11:25am. But I really don't want to work on this right now. I want to work on the game. Forget this for the time being.

```
inl InitActions : array action = failwith "TODO" // ![Call; Rise]
```

Let me leave this like so.

11:45am.

```
union action = Fold | Call | Raise
union card = King | Queen | Jack

// TODO: Implement the array literals.
inl ActionsInit : array action = failwith "TODO" // ![Call; Rise]
inl ActionsFull : array action = failwith "TODO" // ![Fold; Call; Rise]
inl ActionsNoRaise : array action = failwith "TODO" // ![Fold; Call]
inl DeckInit : array card = failwith "TODO" // ![King; Queen; Jack; King; Queen; Jack]

inl game {draw_all draw act terminal} =
    inl done = ()
    let rec init () =
        draw 0 DeckInit fun (card, deck : card * array card) =>
        inl p1 = {card pot=1; id=0}
        draw 1 deck fun card, deck =>
        inl p2 = {card pot=1; id=1}
        round_one {raise_amount=2; rounds_left=2; raises_left=2; actions on_call} (p1,p2)
    and let round {raise_amount rounds_left raises_left actions on_call} (p1,p2) =

        act p1 actions' function
        | Fold => terminal (p1.id, p1.pot + p2.pot)
        | Call => round_one raises_left Actions (p2,p1)
        | Raise =>
            inl raises_left = raises_left - 1
            inl raise () = inl dif = p2.pot - p1.pot in p1.pot + dif + 2
            round_one raises_left (if raises_left = 0 then ActionsNoRaise else Actions) (p2, {p1 with pot=raise()})

    ()
```

How annoying. How much of this do I want to hardcode?

12:30pm.

```
// The Leduc poker game in CPS'd form.
union action = Fold | Call | Raise
union card = King | Queen | Jack

// TODO: Implement the array literals.
inl ActionsInit : array action = failwith "TODO" // ![Call; Rise]
inl ActionsFull : array action = failwith "TODO" // ![Fold; Call; Rise]
inl ActionsNoRaise : array action = failwith "TODO" // ![Fold; Call]
inl DeckInit : array card = failwith "TODO" // ![King; Queen; Jack; King; Queen; Jack]
type player = {card : card; id : u8; pot : u32}
type players = player * player

inl game {sample_all draw action terminal} =
    inl done = ()
    inl raise amount (p1,p2 : players) = p2.pot + amount

    draw 0 DeckInit fun (card, deck : card * array card) =>
    inl p1 = {card pot=1; id=0}
    draw 1 deck fun card, deck =>
    inl p2 = {card pot=1; id=1}
    let rec round_two (raises_left : i32) (community_card : card) (p1,p2 : players) =
        action p1.id (if 0 < raises_left then ActionsFull else ActionsNoRaise) function
        | Fold => terminal (p2.id, p1.pot + p2.pot)
        | Call => failwith "TODO: compare_hands" community_card (p1,p2)
        | Raise => round_two (raises_left-1) community_card (p2,{p1 with pot=raise 4 (p1,p2)})
    let round_two_init (p1,p2 : players) =
        sample_all deck fun card =>
        action p1.id ActionsInit function
        | Fold => failwith "impossible"
        | Call => round_two 2 card (p2,p1)
        | Raise => round_two 1 card (p2,{p1 with pot=raise 4 (p1,p2)})
    let rec round_one (raises_left : i32) (p1,p2 : players) =
        action p1.id (if 0 < raises_left then ActionsFull else ActionsNoRaise) function
        | Fold => terminal (p2.id, p1.pot + p2.pot)
        | Call => round_two_init (if p1.id = 0 then p1,p2 else p2,p1)
        | Raise => round_one (raises_left-1) (p2,{p1 with pot=raise 2 (p1,p2)})

    action p1.id ActionsInit function
    | Fold => failwith "impossible"
    | Call => round_one 2 (p2,p1)
    | Raise => round_one 1 (p2,{p1 with pot=raise 2 (p1,p2)})
```

This is perfect. I could lower the code size though some functional abstraction, but that would make things harder to read. There is no need to push myself here.

```
inl game {sample_all draw action terminal} =
    inl done = ()
    inl raise amount (p1,p2 : players) = p2.pot + amount

    inl pot = 1
    inl id = 0
    draw id DeckInit fun (card, deck : card * array card) =>
    inl p1 = {card id pot}
    inl id = 1
    draw id deck fun card, deck =>
    inl p2 = {card id pot}
```

Let me do it like this. The type passed into draw is an arbitrary number instead of an id.

```
forall 'a. {action : u8 -> array action -> (action -> 'a) -> 'a; draw : u8 -> array card -> (card * array card -> 'a) -> 'a; sample_all : array card -> (card -> 'a) -> 'a; terminal : u8 * u32 -> 'a} -> 'a
```

Now the type of `game` is this. Exactly what one would expect if it were CPS'd.

I should do Dudo next. But before that I also need to do the hand ranking function.

Let me have breakfast here. I'll do that afterwards."

---
## [mrakgr/The-Spiral-Language@d08f01ad9c...](https://github.com/mrakgr/The-Spiral-Language/commit/d08f01ad9cc819203f3ab7460e9aafb0d0433026)
##### 2021-02-09 14:44:24 by Marko Grdinić

"1:55pm. Let me finish the chapter of Otherside Picnic and then I'll resume. I have 1.5 hours before I leave so that is not too much time, but it might be enough to deal with the hand ranking functions and the Dudo game. The Leduc game just came out so well. 5/5. If I'd tried to abstract it further, it would have been 4/5.

2pm. Ok, focus me. Let me do the hand ranker.

2:15pm.

```
inl compare_hands (community_card : card) (p1,p2 : players) =
    let tag = function King => 2i32 | Queen => 1 | Jack => 0
    let order (a,b) = if a > b then a,b else b,a
    let a = (tag p1.card, tag community_card) |> order
    let b = (tag p2.card, tag community_card) |> order
    let is_pair (a,b) = a = b
    if is_pair a && is_pair b then comp (fst a) (fst b)
    elif is_pair a then GT
    elif is_pair b then LT
    else
        match comp (fst a) (fst b) with
        | EQ => comp (snd a) (snd b)
        | x => x
```

I really hate how Cython heap allocates unions. I am tempted to just make the order an int.

```
union order = LT | EQ | GT
prototype comparable a : a -> a -> order
inl eq_is = function EQ => true | _ => false
```

Let me change this. Forget making this smooth. It will be more efficient if it is not an union anyway.

```
type order = i32
prototype comparable a : a -> a -> order
inl EQ = 0i32
inl eq_is (x : i32) = !!!!EQ(x, 0i32)
inl LT = -1i32
inl lt_is (x : i32) = !!!!EQ(x, -1i32)
inl GT = 1i32
inl gt_is (x : i32) = !!!!EQ(x, 1i32)
```

```
inl compare_hands (community_card : card) (p1,p2 : players) =
    let tag = function King => 2i32 | Queen => 1 | Jack => 0
    let a = tag p1.card, tag community_card
    let b = tag p2.card, tag community_card
    let is_pair (a,b) = a = b
    if is_pair a && is_pair b then comp (fst a) (fst b)
    elif is_pair a then GT
    elif is_pair b then LT
    else
        let order (a,b) = if a > b then a,b else b,a
        inl a,b = order a, order b
        inl x = comp (fst a) (fst b)
        if eq_is x then comp (snd a) (snd b) else x
```

Here is the hand ranker.

```
        | Call =>
            let x = compare_hands community_card (p1,p2)
            if gt_is x then terminal (p1.id, p1.pot + p2.pot)
            elif lt_is x then terminal (p2.id, p1.pot + p2.pot)
            else terminal (p1.id, 0)
```

Here is the last case.

```
union action = Fold | Call | Raise
union card = King | Queen | Jack
```

Though I am wondering about the value of the optimization I did considering these will also be heap alloc'd.

2:35pm. Maybe I for getting real performance out of the Cython backend, I should do a C one as well and then call that where I need to. Nevermind this for the time being.

This kind of extreme performance case is not something I need to concern myself with right now.

2:40pm. I am getting distracted with meaningless things. I made the change, so I might as well live with it.

What is next? Focus me.

Let me do Dudo.

I am getting that lingering error on rename.

Sometimes even on delete. Damn it, I thought I took care of this?

```ts
                        if ("RenameFile" in x[1] || "RenameDirectory" in x[1]) {
                            const r = range(x[0])
                            const target = await window.showInputBox({value: doc.getText(r), prompt: "Enter a new file name."})
                            if (target) {
                                if ("RenameDirectory" in x[1]) {x[1].RenameDirectory.target = target}
                                else {x[1].RenameFile.target = target}
                                error = await spiprojCodeActionExecuteReq(uri,x[1])
                                if (!error) {
                                    const edit = new WorkspaceEdit()
                                    edit.replace(doc.uri,r,target)
                                    workspace.applyEdit(edit)
                                    }
                                }
                        }
```

But I did not really consider the code actions. What a pile of crap.

Let me add this to the list. It is not that important at the moment.

Dudo, let me do dudo here.

```fs
let rec dudo_main (history, one, two as key) =
    match history with
    | [] -> response key claims (fun claim one -> dudo_main (claim :: history, two, one))
    | (number,rank as claim) :: _ ->
        response key
            actions.[Array.findIndex ((=) claim) claims + 1 .. ]
            (fun action one ->
                match action with
                | Dudo ->
                    let check_guess s x = if x = 1 || x = rank then s+1 else s
                    let dice_guessed = check_guess (check_guess 0 one.state) two.state
                    if dice_guessed < number then 1.0 else -1.0
                    |> terminal
                | Claim claim -> dudo_main (claim :: history, two, one)
                )

let dudo_initial one two =
    chance one <| fun one ->
        chance two <| fun two ->
            dudo_main ([], one, two)
```

Let me paste this here again.

2:50pm. It is really annoying...I am supposed to be working, but knowing I have to leave in an hour is really squeezing me. I am subconsciously trying to hold back on sleeping too much into the zone. This is hindering me.

Well, let me do what I can.

```
// Appends two arrays.
inl append a b = init (length a + length b) (fun i => inl l = length a in if i < l then index a i else index b (i - l))
```

Let me implement it like this.

3:05pm.

```
inl Dice : array rank = failwith "TODO"
inl Claims : array claim = failwith "TODO"
inl Actions : array action = arrayu64.append (arrayu64.map claim_ Claims) (arrayu64.singleton Dudo)
```

The way this works is honestly crazy. I am creating these heap allocated arrays and concatenating them.

```
// TODO: Implement the array literals.
inl ActionsInit : array action = failwith "TODO" // ![Call; Rise]
inl ActionsFull : array action = failwith "TODO" // ![Fold; Call; Rise]
inl ActionsNoRaise : array action = failwith "TODO" // ![Fold; Call]
inl DeckInit : array card = failwith "TODO" // ![King; Queen; Jack; King; Queen; Jack]
```

The same thing here. I am going to wrap these in a join point and pull them inside the function so they do not keep getting realloc'd.

Nevermind this for now.

3:25pm.

```
// Finds the index of the true applicant.
inl findIndex f x =
    let rec loop i = if i < length x then f (index x i) && loop (i+1) else failwith "The true applicant does not exist."
    loop 0
// Slices the array at the specified range.
inl slice (from:nearTo:) x = init (nearTo-from) (fun i => index x (i+from))
```

Let me add these two as well.

```
// Finds the index of the true applicant.
inl findIndex f x =
    let rec loop i =
        if i < length x then if f (index x i) then i else loop (i+1)
        else failwith "The true applicant does not exist."
    loop 0
```

Let me do this one like so. I messed up.

3:45pm.

```
inl game {sample action_response action_init terminal} =
    inl actions = Actions
    inl claims = Claims
    inl dice = Dice

    let rec loop (number,rank as claim) (p1,p2 : players) =
        inl from = arrayu64.findIndex ((=) claim) claims + 1
        action_response p1.id (arrayu64.sliceFrom from actions) function
        | Claim: x => loop x (p2,p1)
        | Dudo =>
            inl check_guess x = if x = 1 || x = rank then 1 else 0
            inl dice_guessed = check_guess p1.die + check_guess p2.die
            inl winner_id = if dice_guessed < number then p1.id else p2.id
            terminal (winner_id, 1)

    let id = 0
    sample id dice fun die =>
    inl p1 = {id die}

    let id = 1
    sample id dice fun die =>
    inl p2 = {id die}

    action_init p1.id claims fun claim =>
    loop claim (p2,p1)
```

I am not done yet, but let me stop here. I need to get ready to leave. Maybe I'll do a bit more after I get back."

---
## [susannovalinski/susannovalinski@fecce03c4e...](https://github.com/susannovalinski/susannovalinski/commit/fecce03c4e12ee3d3e7ffd39694aa3a542d3fe5e)
##### 2021-02-09 15:47:53 by susannovalinski

Create README.md

Hello my name is Susan I am a curious dentist. 
I love digital life, languages and adventures. 
Actually I am into programming, e-learning and developing my platforms of my dentistry profesion. 
You can contact me at snovalinski@gmail.com 

I will be glad to keep you informed in relation to dentistry and make it a great experience to maintain your health. 
You can ask me about: dentistry diagnosis in case you are feeling insecure and need more info to continue a treatment, implants, and neural therapy.

---
## [RuMont/test@aeb2da9820...](https://github.com/RuMont/test/commit/aeb2da982049d095a566a84579c9b33149d2b750)
##### 2021-02-09 16:01:47 by RuMont

Still having hope; I already uploaded this shit to github. Although I deleted like 10 years of my life in photos, I think I'm progressing at this stupid thing

---
## [jkdufair/spotify.el@704531da37...](https://github.com/jkdufair/spotify.el/commit/704531da37d29e8ded51ddbcd8162e1a47d44c82)
##### 2021-02-09 22:35:26 by Jason Dufair

Call status after activity & reduce number of calls...

Using `define-globalized-minor-mode` was causing `spotify-remote-mode` to be called repeatedly on
every switch from a buffer another buffer (or to the minibuffer). This was causing many unnecessary
API calls because I had assumed the minor mode function would be called once. By specifying :global
in the minor mode definition, the minor mode function is now called once for each toggle. This does
prevent us from offering a buffer-specific minor mode, but that doesn't seem very useful anyway?

I attempted to handle various sets of callbacks to get the status after the API calls were complete
but it truly was callback hell and required a lot of ugly, repetitive code. I think the right
approach would be to use something like aio or whatever is considered the best async/await/promise
library currently. As it stands, I just hacked in a 1s timer to get status after any call is made.

---

# [<](2021-02-08.md) 2021-02-09 [>](2021-02-10.md)

