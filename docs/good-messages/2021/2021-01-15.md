# [<](2021-01-14.md) 2021-01-15 [>](2021-01-16.md)

2,646,050 events, 1,336,120 push events, 2,087,809 commit messages, 164,391,861 characters


## [Lupus590-CC/CC-Tweaked@1255bd00fd...](https://github.com/Lupus590-CC/CC-Tweaked/commit/1255bd00fd21247a50046020d7d9a396f66bc6bd)
##### 2021-01-15 02:22:46 by Jonathan Coates

Fix mounts being usable after a disk is ejected

This probably fails "responsible disclosure", but it's not an RCE and
frankly the whole bug is utterly hilarious so here we are...

It's possible to open a file on a disk drive and continue to read/write
to them after the disk has been removed:

    local disk = peripheral.find("drive")
    local input = fs.open(fs.combine(disk.getMountPath(), "stream"), "rb")
    local output = fs.open(fs.combine(disk.getMountPath(), "stream"), "wb")
    disk.ejectDisk()

    -- input/output can still be interacted with.

This is pretty amusing, as now it allows us to move the disk somewhere
else and repeat - we've now got a private tunnel which two computers can
use to communicate.

Fixing this is intuitively quite simple - just close any open files
belonging to this mount. However, this is where things get messy thanks
to the wonderful joy of how CC's streams are handled.

As things stand, the filesystem effectively does the following flow::
 - There is a function `open : String -> Channel' (file modes are
   irrelevant here).

 - Once a file is opened, we transform it into some <T extends
   Closeable>. This is, for instance, a BufferedReader.

 - We generate a "token" (i.e. FileSystemWrapper<T>), which we generate
   a week reference to and map it to a tuple of our Channel and T. If
   this token is ever garbage collected (someone forgot to call close()
   on a file), then we close our T and Channel.

 - This token and T are returned to the calling function, which then
   constructs a Lua object.

The problem here is that if we close the underlying Channel+T before the
Lua object calls .close(), then it won't know the underlying channel is
closed, and you get some pretty ugly errors (e.g. "Stream Closed"). So
we've moved the "is open" state into the FileSystemWrapper<T>.

The whole system is incredibly complex at this point, and I'd really
like to clean it up. Ideally we could treat the HandleGeneric as the
token instead - this way we could potentially also clean up
FileSystemWrapperMount.

BBut something to play with in the future, and not when it's 10:30pm.

---

All this wall of text, and this isn't the only bug I've found with disks
today :/.

---
## [dchacke/git-blog@1e0c87c5d4...](https://github.com/dchacke/git-blog/commit/1e0c87c5d4f20b3ac459df9f6a2f5b7be47acacc)
##### 2021-01-15 04:37:35 by Dennis C Hackethal

# Governments Are Involuntary

The vast majority of citizens see governments as a good idea. They're convinced that without government, chaos would ensue. Many even think being forced to pay taxes is a good idea.

So, can we claim that most people consent to being governed?

I find it difficult to use the word "consent" to describe the attitude of those who do not *resist* government force. For something to be consent, it means that the person affected was asked and then agreed. The government does not ask any of its subjects if it may tax them, it just does it. And the absence of resistance is not consent.

To illustrate the distinction: if somebody shows up at your house with a group of bullies and an overwhelming amount of guns and threatens to shoot you if you don't come with them or even make so much as a wrong move, you may decide not to resist. But no Western court would consider your lack of resistance consent, and rightly so.

The present relationship between the government and its subjects is often referred to as a "contract" (Hobbes). A common claim is that those who do not want to sign the contract can just leave the country. That is not so, because the state has a monopoly on travel documents, so you're not free to leave without signing the contract first. Nor are you ever asked to sign it—the signature is implied by the lack of resistance to a threat of force. And a forced signature is null and void.

There's also a question as to whether the people who do "consent" to taxation came to that belief voluntarily, or if that belief was forced on them through years of coercion and brainwashing in school, in which case the problem is the same as that of the forced signature.

Some may assure you that they positively consent to paying taxes. People can be mistaken about the reasons for their beliefs and behaviors (cf. (see David Deutsch's [*The Beginning of Infinity*](https://www.amazon.com/Beginning-Infinity-Explanations-Transform-World/dp/0670022756/) (BoI) ch. 15). Those who think that it's okay that they're being forced to pay taxes remind me of adults who are glad that their parents forced them to, say, play the piano as a child. They're broken enough that they retrospectively condemn freedom and value force.

Schools are institutions that the state and *static memes* (BoI ch. 15) use in part to make sure children grow up to be tax payers that don't resist. Even better if those memes somehow get the child to believe that coercion is just a part of life, even a necessary one. There are many parallels between coercive government and coercive parenting.

I've written some about the purpose of schools here: http://www.gitpretty.com/dchacke/git-blog/863ddea

Lastly, there is the issue that some people are mistaken about what coercion and consent are. For example, an idea I run into from time to time says "it's not coercion if you receive something in return." The argument is that you receive, say, roads in exchange for paying taxes, so it's not really coercion. There are many problems with this, including that people have different preferences as to what they may want to buy with their money, and some value roads more than others. Another problem is that the victim of force in this example does not get a chance to agree or disagree—his agreement is (mistakenly) assumed because he receives a "benefit." His "participation" is completely passive and he becomes a mere pawn. The perpetrator can then also force the victim to do just about anything and give him something—*anything*—to justify their force and to shut the victim and bystanders up. In this power dynamic, the "benefit" is always going to be worth less than the extorted value—both in terms of the stolen money, and, more importantly, in terms of the freedom that is lost, which is priceless.

This last issue is reflected in coercive parenting when children are expected to be thankful to their coercive parents, if not in childhood then at least in adulthood. Some parents may even expect something in return—time, money, things—once their children are adults, which is awful. The parent may try to justify this by claiming that the child received a "benefit" which the parent now considers a loan that is due, especially if the parent made sacrifices "for" the child—even if the child never asked the parent to make sacrifices or consented to any of that. The parent has an overwhelming amount of force available to him over the child, so the child may choose not to resist, which, just as in the case of bullies knocking on your door, shouldn't be mistaken for consent.

In short: the absence of dissent or resistance does not imply consent, nor does anyone, even in the free world, consent to being governed or taxed. It's something that happens *to* them, not *with* them.

---
## [dchacke/git-blog@e90241e6eb...](https://github.com/dchacke/git-blog/commit/e90241e6eb7c8640f571a53fbc6d874535e4988c)
##### 2021-01-15 05:22:11 by Dennis C Hackethal

# Lockdowns: Science vs. Morals

There are growing concerns that lockdown policies are not "based on science" but are, instead, [a totalitarian Chinese export](https://twitter.com/MichaelPSenger/status/1349505333652201474). The latter may be true—and seems to be—but that lockdowns are not scientific is not the biggest problem with them (assuming that indeed they aren't).

The thing is, even if lockdowns *were* scientific, that would say nothing about the *morality* of the situation. The argument that lockdowns aren't scientific runs the risk of being refuted tomorrow through new scientific findings. And it's still letting scientism off the hook too lightly.

Let's say the argument *were* refuted tomorrow. The moral problems would remain. Lockdowns would still be a horrendous evil.

Take an example where we know that the outcome of force, in purely scientific terms, is beneficial: that of forcing someone not to smoke. Or forcing them to exercise a few times a week. Scientifically speaking, their body will be healthier as a result of that force, and advocates of such force can always point to scientific evidence for that. It'd be "based on science."

And still, forcing people not to smoke is wrong. Forcing them to exercise is wrong. Force in general is wrong, and no amount of scientific evidence changes that.

The same goes for lockdowns. Even if there were overwhelming scientific evidence that locking people into their homes lowers transmission rates, death rates, what have you, *it would still be evil*.

To those concerned about ICU numbers, their loved ones, etc: *their is another way*. Lockdowns are not the only way. You can *persuade* people to stay home. And those who are vulnerable are free to stay home already, no lockdowns required.

That's why lockdowns are redundant: they lock down those who don't want to *in addition* to those who'd voluntarily do so. There's no added benefit to the latter group by having the former forced to stay home, too.

Voluntary self-isolation solves the moral problem and the medical problem.

But that won't convince lockdown supporters, because they're not after solving either of those problems. What they're really after—and [what they learned to do in school](http://www.gitpretty.com/dchacke/git-blog/863ddea)—is spreading altruism and forcing others to do what they think is right. Which is disgusting.

---
## [mysteriouspants/uDevGames.com@59151e5e0d...](https://github.com/mysteriouspants/uDevGames.com/commit/59151e5e0d637db608ea99a2f8a96e08315c31d9)
##### 2021-01-15 07:21:34 by Christopher R. Miller

Migrate homepage, session workflow to Actix

Some initial thoughts:

Actix has fewer (no?) macros, so it's not magical. It's pretty clear
what it's doing and why.

The Handler contract can be frustrating to satisfy and the error
messages are somewhat cryptic. I found it somewhat challenging to make
sure it was done correctly.

I'm currently halting between two ideological positions, the first is
using Actix to plumb my application state and configuration into the
handlers (using Data) and the second is using some globals to do it out
of band.

- Data is advantaged in that the lifting is already done for me. There's
  really no additional effort.
- Data is disadvantaged in that it makes the handler's function
  arguments rather long. I'm not a fan of that.
- Conversely, globals are advantaged in that it keeps handler function
  arguments very short.

Currently the template engine is the only thing stuffed into a global to
emulate the API of Rocket regarding templates, but it's not completely
similar. In so doing I've noticed a subtlety of Rocket that I hadn't
noticed before, in that Template return type for handlers gets fed into
another Responder which pulls the template context out of the HTTP
request context - so it's effectively using Data again, only with less
boilerplate and ceremony.

If I can reduce the boilerplate in the ArcSwapOption pattern that may be
the way to go, or the other thing I've been considering is packaging up
the application state into a single context struct, so a single argument
in the handler gets everything - templates, database connection pool,
the works.

Something to ponder.

---
## [xlab-si/xopera-opera@db04f21e74...](https://github.com/xlab-si/xopera-opera/commit/db04f21e74147103722d83d04de3323da283def7)
##### 2021-01-15 13:49:02 by anzoman

Jingle all the way with opera tab completion

It's time to fulfil our quest that was desired to be done from times
of yore (#56). And since Christmas is about giving back and caring
about others, we decided to bring merry to all our users and enable
tab completion for opera CLI arguments.

One can almost get enchanted when looking at a CLI that has a
nice-working tab completion. Shell completion can be hard to
comprehend sometimes because there's many ways to support it.
Since opera uses argparse we had to find a tab completion package
that's compatible with it. The love on first sight would be
argcomplete Python package which was designed for completing argparse
commands and their arguments. However, when we tried it, it didn't turn
out so well. Most of the time we were unable to get it working with our
subparsers and on the other hand we didn't want to activate completion
globally. So we almost gave up with that. But then we remembered that
failure only happens when you give up. Hope and determination fuel
the true champions. So we found shtab as a possible solution. The
package is still very young and some features will probably be worked
on in the future.

We were able to use shtab in our code to generate a shell completion
script. And we don't even need a separate command to do that since
shtab supports defining a global optional argument that will print
out the completion script for the main parser. We used that and
defined --shell-completion/-s flag which receives a shell type to
generate completion for. Shtab currently supports bash and zsh so those
are the options. So, after running `opera -s bash|zsh` the generated
tab completion script will be printed out. To activate it you must
source the contents which can be done with `eval "$(opera -s bash)"`
or you can save it to a file and then source it. The procedure will
be fully explained in the opera documentation.

First thoughts about tab completion also included a possibility to
pre-install it for the user. For that we would need to do the sourcing
within the installation. There was also a suggestion to have a
separate opera shell-completion command that would have a --install
switch to install tab completion on user's system. We didn't want to
upset the users by installing something into their environment that
they might not want. We also didn't want to modify their ~/.bashrc file
and add our completion as that could bring a lot of problems. At the
end, we  decided to just print out the generated completion script and
then the user can decide how to continue for himself.

The new completion feature will give aid to those opera users who seek
it. Since opera CLI is evolving and growing, new and new commands and
CLI options are being introduced. So it's easy to make a mistake while
you're using the CLI. And that's when tab completion comes in handy.

---
## [saitcakmak/botorch@17ad4fe55b...](https://github.com/saitcakmak/botorch/commit/17ad4fe55bae04fc590ca183ec7404c53f41926c)
##### 2021-01-15 18:53:01 by Neeraj Pradhan

Apply transform to constrain RBFKernel lengthscale in LCEMGP (#643)

Summary:
## Motivation

This adds a transform to `UniformPrior` in `LCEMGP` class to convert real values to constrained values in `[0, 2]`. Otherwise, with distribution validation enabled (which will be the default once https://github.com/pytorch/pytorch/pull/48743 is merged), this throws an error in `Uniform.log_prob` method. We were facing this issue in an internal FB test that uses botorch.

While this fixes the specific issue, my thinking is that this transform should ideally be applied automatically within `gpytorch.priors`. That said, my understanding of the codebase is very limited, so would love to hear others' thoughts on this.

### Have you read the [Contributing Guidelines on pull requests](https://github.com/pytorch/botorch/blob/master/CONTRIBUTING.md#pull-requests)?

Yes

Pull Request resolved: https://github.com/pytorch/botorch/pull/643

Test Plan:
Turned `Distribution.set_default_validate_args(True)` and succesffully ran `test_contextual_multioutput.py: ContextualMultiOutputTest.testLCEMGP` with a fixed seed and increased `maxiter` (this test fails without the fix).

cc Balandat

Reviewed By: qingfeng10

Differential Revision: D25699129

Pulled By: Balandat

fbshipit-source-id: 0485bbaa5db551fcab122119acd53549b9a5f166

---
## [grapl-security/grapl@6137fd7042...](https://github.com/grapl-security/grapl/commit/6137fd704231e48a4f29229018c140658f8ad181)
##### 2021-01-15 21:30:50 by wimax-grapl

Begin to migrate python S3/SQS clients to a FromEnv equivalent (#541)

* On the road to Rust-like Fargate Stuff

yeah sure whatever

Fixed up typechecks

blep blep

It should work, but it doesn't.

I think it should work potentially

It fucking succeeded asdfgh

Yes yes it works yes

e2e works

sysmon works

okay time to rip out more garbage

it work

* readd removed logging driver none thing

* woops two tabs

* Remove the thing that caused pytype failure

* Lock test requirements

* change some prints to logger calls

---

# [<](2021-01-14.md) 2021-01-15 [>](2021-01-16.md)

