# [<](2021-05-29.md) 2021-05-30 [>](2021-05-31.md)

2,357,917 events, 1,296,717 push events, 1,910,574 commit messages, 96,388,838 characters


## [hashicorp/terraform-plugin-framework@1f27bf6cb2...](https://github.com/hashicorp/terraform-plugin-framework/commit/1f27bf6cb2e16409da6566497533f34fb3e27a05)
##### 2021-05-30 01:00:04 by Paddy Carver

Add support for pointers and interfaces.

Add support for our setUnknownable and setNullable interfaces, as well
as for the AttributeValue interface and the tftypes.ValueConverter
interface.

This involved some sleight of hand. We want to have an empty version of
the type implementing the interface, but that type may be a pointer, so
an empty version would be nil, which leads to accidental panics. Which
we don't want. Worse, it could, in theory, be a pointer to a pointer to
a pointer to a pointer to a pointer to a pointer... you get the idea. So
we needed a new `pointerSafeZeroValue` that would find whatever type
underlies all the pointers, create a zero value of it, and then create a
pointer to that zero value, matching the level of indirection.

We also stopped converting values to interfaces to call the method
directly, letting us avoid nil pointer panics. It's more verbose, but
using reflection lets us have zero values and just not worry about
things that are nil. Much better.

Add support for pointers, dereferencing them and reflecting on the type
they implement, then wrapping that in a pointer on the way back out.
This also involves some sleight of hand to make the pointer settable,
but with some ingenuity and some cursed convoluted code, we manage it.
See comments in the reflectPointer function for more details.

Don't handle interface kinds, because there's no solid type underlying
them, and I don't feel like picking one. People can set real types, it's
ok.

Add tests for setUnknownable, setNullable, and AttributeValue values, as
well as for maps and pointers.

Supporting AttributeValue as targets required AttributeValues to gain a
SetTerraformValue method, updating the contents to match a
tftypes.Value. This required our AttributeValues to become pointers.
Annoying. It also required our composite AttributeValues to have
AttributeTypes as the ElemType, so they could create new AttributeValues
in the AttributeValue.SetTerraformValue method, if needed. This, in
turn, required AttributeType to gain an Equal method, so the
AttributeValue Equal method could compare AttributeTypes. Exhausting.

Also, we're actually testing that complex structs are having their
properties set correctly now, which is novel and neat. (They are.)

---
## [henricaodopao/kernel_asus_sdm660@03e8a8ff22...](https://github.com/henricaodopao/kernel_asus_sdm660/commit/03e8a8ff22c19a38d0aa7bdef09bc57942e7e197)
##### 2021-05-30 01:43:25 by Michal Hocko

proc: oom: drop bogus task_lock and mm check

Series "Handle oom bypass more gracefully", V5

The following 10 patches should put some order to very rare cases of mm
shared between processes and make the paths which bypass the oom killer
oom reapable and therefore much more reliable finally.  Even though mm
shared outside of thread group is rare (either vforked tasks for a short
period, use_mm by kernel threads or exotic thread model of
clone(CLONE_VM) without CLONE_SIGHAND) it is better to cover them.  Not
only it makes the current oom killer logic quite hard to follow and
reason about it can lead to weird corner cases.  E.g.  it is possible to
select an oom victim which shares the mm with unkillable process or
bypass the oom killer even when other processes sharing the mm are still
alive and other weird cases.

Patch 1 drops bogus task_lock and mm check from oom_{score_}adj_write.
This can be considered a bug fix with a low impact as nobody has noticed
for years.

Patch 2 drops sighand lock because it is not needed anymore as pointed
by Oleg.

Patch 3 is a clean up of oom_score_adj handling and a preparatory work
for later patches.

Patch 4 enforces oom_adj_score to be consistent between processes
sharing the mm to behave consistently with the regular thread groups.
This can be considered a user visible behavior change because one thread
group updating oom_score_adj will affect others which share the same mm
via clone(CLONE_VM).  I argue that this should be acceptable because we
already have the same behavior for threads in the same thread group and
sharing the mm without signal struct is just a different model of
threading.  This is probably the most controversial part of the series,
I would like to find some consensus here.  There were some suggestions
to hook some counter/oom_score_adj into the mm_struct but I feel that
this is not necessary right now and we can rely on proc handler +
oom_kill_process to DTRT.  I can be convinced otherwise but I strongly
think that whatever we do the userspace has to have a way to see the
current oom priority as consistently as possible.

Patch 5 makes sure that no vforked task is selected if it is sharing the
mm with oom unkillable task.

Patch 6 ensures that all user tasks sharing the mm are killed which in
turn makes sure that all oom victims are oom reapable.

Patch 7 guarantees that task_will_free_mem will always imply reapable
bypass of the oom killer.

Patch 8 is new in this version and it addresses an issue pointed out by
0-day OOM report where an oom victim was reaped several times.

Patch 9 puts an upper bound on how many times oom_reaper tries to reap a
task and hides it from the oom killer to move on when no progress can be
made.  This will give an upper bound to how long an oom_reapable task
can block the oom killer from selecting another victim if the oom_reaper
is not able to reap the victim.

Patch 10 tries to plug the (hopefully) last hole when we can still lock
up when the oom victim is shared with oom unkillable tasks (kthreads and
global init).  We just try to be best effort in that case and rather
fallback to kill something else than risk a lockup.

This patch (of 10):

Both oom_adj_write and oom_score_adj_write are using task_lock, check for
task->mm and fail if it is NULL.  This is not needed because the
oom_score_adj is per signal struct so we do not need mm at all.  The code
has been introduced by 3d5992d2ac7d ("oom: add per-mm oom disable count")
but we do not do per-mm oom disable since c9f01245b6a7 ("oom: remove
oom_disable_count").

The task->mm check is even not correct because the current thread might
have exited but the thread group might be still alive - e.g.  thread group
leader would lead that echo $VAL > /proc/pid/oom_score_adj would always
fail with EINVAL while /proc/pid/task/$other_tid/oom_score_adj would
succeed.  This is unexpected at best.

Remove the lock along with the check to fix the unexpected behavior and
also because there is not real need for the lock in the first place.

Link: http://lkml.kernel.org/r/1466426628-15074-2-git-send-email-mhocko@kernel.org
Signed-off-by: Michal Hocko <mhocko@suse.com>
Reviewed-by: Vladimir Davydov <vdavydov@virtuozzo.com>
Acked-by: Oleg Nesterov <oleg@redhat.com>
Cc: David Rientjes <rientjes@google.com>
Cc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Change-Id: Id5b29755e8dbc70fc104263e207bb54de5eeb6ee

---
## [Capitanloco6/Divergences-HPM@12d6f6a18f...](https://github.com/Capitanloco6/Divergences-HPM/commit/12d6f6a18f882478f0c4b58e3d665be7ecfb3e78)
##### 2021-05-30 10:25:17 by Capitanloco6

Iran and East Asia Update

-	Reworked the starting political map and lore for Iran
o	Iran is now divided between the Shaki Khanate, the Shekhbizin Empire, the Kar-Kiya and the Timurtash
	Timurtash Dynasty: The remnants of the last dynasty to unite all of Iran after the splintering of the Timurid Empire. A Persianized Sunni dynasty of Khorasani-Turkmen origin, their long-standing rivalry with the Ottoman Empire over the Caucasus proved to be their undoing. The catastrophic loss of the Caucasian regions in the late 18th Century precipitated its collapse
	Shaki Khanate: A Turkoman polity that came to dominate the Southern Caucasus after the collapse of Ottoman authority in the region
	Shekhbizin Empire: The largest state to emerge from the Timurtash collapse, the Shekhbizin started as a Lurish tribe that came to dominate most of Southern Iran, including the key citites of Isfahan and Shiraz
	Kar-Kiya: A venerable Shia dynasty with its powerbase in Gilan-Mazandaran. Originally a vassal under the Timurtash Empire, following a series of humiliating defeats against the Ottomans they started a rebellion against the Sunni Timurtash
o	Re-worked pops in Iran. More Persian pops have been added to regions with historical Persian influence (Transoxiana and the Caucasus, as well as the Greater Khorasan area). Additionally, regions that were depopulated by OTL wars (i.e. Bam and Kerman, razed by the Qajars IOTL).  Iran is now religiously diverse due to the lack of a Safavid Empire proselytizing Shiism in this timeline.
o	Added Tat, Caspian, Lurish and Nuristani cultures
o	Replaced Tajiks and Hazara with Persian pops
o	Added 11 new provinces to better reflect the political and cultural borders in the region
o	Ported the reworked terrain for the Iranian plateau from HPM 0.44. Basic terrain features such as the Zagros and the Hindu Kush are now much better represented
o	Added the principalities of Imereti and Samstkhe and the Shamkhalate of Tarki as Shaki vassals
o	Added the Khanate of Kalat as a Sindi vassal
o	Added an event for the Khanate of Kalat to break free in the 1840s
o	Added an event for the Ottomans to lose cores on Iran and Iraq if they haven’t retaken Baghdad and beaten the rebellions by 1840
o	Added a decision for the Timurtash to colonise the Kara-Kum and Kyzyl-Su
o	Reworked OOBs for the starting nations
-	Big thanks to Atlas and Varro for their contributions to the new lore. Extra thanks to Atlas for allowing me to use some of his provinces as templates
-	Occitania, should it spawn, not has a valid starting party
-	Fixed the Spanish Commonwealth Friendship Treaty events
-	Gran Colombia dissolution events will now not fire if Granada exists as a vassal (i.e. in the partial peace event chain)
-	Sedentarising as the Crimean Khanate now no longer requires Astrakhan to be owned
-	Added a decision for Astrakhan or Tatarstan to renovate the city of Astrakhan, giving it a population boom and increasing its life rating
-	Simplified the requirements for the Glorious Revolution triggering a Congress event
-	Halved factory needs for dye and silk to ensure better supply
-	New loading screens and menu art
-	East Asia update by Boytoy:
o	Reworked borders between Chinese nations
o	Chinese states have been renamed and redrawn
o	Changed pops in Manchuria and Zhejiang
o	De-pin yined some Provinces aswell as removing European named regions and provinces
o	Changed some inner workings (capitals, cultures, religions) of some of the Chinese nations
-	Bugfixes by PlazmaticulRO:
o	Vryland can now also trigger the scripted peace with Burgundy during the Boer War
o	Vryland can now also get the Trek Boer immigration modifier upon forming South Africa, granted it has researched Medicine, State and Government and Functionalism
o	Arcadia, Ameriga and Yugoslavia can now also be formed by puppeting instead of sphering
o	Forming Germany now sets a population boom in Frankfurt am Main
o	Polynesia’s Embrace the Micronesians decision now requires Taitung to be owned
o	Gran Colombia can now purchase Cuba
o	Gran Colombia can now accept Athesians, Caribeños and Ayitians
o	The Falklands can now also be purchased by the Holy Britannian Empire
o	Forming Russia now gives Chuvash, Komi, Mari, Mordvin and Udmurt as accepted cultures
o	Added more Ruthenian soldier pops in Muscovy
o	Reduced justification time for the Acquire Substate Core CB
o	Enabled the increased/decreased justification time events for a bunch of CBs

---
## [mathemage/CompetitiveProgramming@fc3de2231c...](https://github.com/mathemage/CompetitiveProgramming/commit/fc3de2231caae80303ae1915226bf912f5c92785)
##### 2021-05-30 14:25:28 by Karel Ha

Compete in AtCoder ABC 203

standings: 3136/8341 (~10400 competitors) on page 157/521
-> PERCENTILE >62% (~ >69%) :-/ :-( <- stupid problem D
rank: 3135/8432
-> PERCENTILE >62% :-/ :-(
rating: -20 -> 915 (provisional) [6 KYU] :-( :-(
performance as 806 :-(
- I came on time/in advance!!!
- What could I have done better????! Problem D sucks!

Analysis:
- tested new Vim <F5> shortcut -> yank file content -> clipboard
  -> superfaster!
- first 2 problems in <6 min
- first 3 problems in <25 min
- got stuck on 4th problem -> submitted at 1:34:32 (i.e. ~70min :-()
  -> better total time overall (compared to ABC 201)
- 3/4 ACs, 1/4 WA/TLE :-/ :-(

A:
- hesitations: started implementing with A, B, C variable
  - but changed to vector<ll> and compare via abc[i]
=> DECIDE IN ADVANCE ON A,B,C... VARIABLES VS VEC OF VARS!!
- quite lengthy solution for A :-/
  -> editorial?

B:
- original idea with string manip + stoll
- faster via 100*n+k
=> CONSIDER BUILDING INTEGERS DIRECTLY!
   - before `string manip + stoll`

C:
- simulation w/ skipping intermediate steps
  - directly to end positions (i.e. towns w/ friends)
- presubmit bug -> slowed down :-/
  - forgot to update `curPos=AB.F;`
=> WHILE RE-READING, CHECK EACH VARIABLE/STATE GETS UPDATED!!
  - especially in loops
  - `if (steps<0)` instead of `if (steps>K)`
=> THINK HARD ABOUT IF CONDITIONS / THE LOGIC OF THE ALGO!!!

D:
- sliding window
  - compute median via ordered_set in O(log K^2)
    - policy-based data structure available in gcc
  - but updates take O(K) * O(log K^2)
    - per each of O((N-K)^2) window
    -> amounts to worse than O(N^3) solution :-/ :-(
- likely wrong idea/design
  -> to upsolve!
- but only 775 ACs /3218 submissions (~24%)!
  - genuinely hard/tricky?

Signed-off-by: Karel Ha <mathemage@gmail.com>

---

# [<](2021-05-29.md) 2021-05-30 [>](2021-05-31.md)

