# 2021-03-04

3,094,604 events, 1,570,645 push events, 2,449,354 commit messages, 224,773,078 characters


## [newstools/2017-the-sun-nigeria@908b58bd31...](https://github.com/newstools/2017-the-sun-nigeria/commit/908b58bd316bd71c77248372ee34fee52fea68b9)
##### 2021-03-04 01:39:18 by NewsTools

Created Text For URL [www.sunnewsonline.com/a-taste-of-hell-kerosene-explosion-makes-life-horrible-for-11-year-old-girl/]

---
## [noeinan/DoL-World-Expansion-Mod@4c82f71d26...](https://github.com/noeinan/DoL-World-Expansion-Mod/commit/4c82f71d26c19cc6c28872504ff8262147c9fd4a)
##### 2021-03-04 01:54:57 by noeinan

Fixed Fox TF Code + Misc

-Went through the code and changed all instances of $fox (in relation to the transformation) to $foxgirl because $fox is used for something else in the official version of the game. 

-Added cow to list of beast types. 

-Copied animation code for wolf to use for fox, copied animation code for pig to use for cow. Later I'll need to make unique art. 

-Made it so you can always confess to Alex as long as you're not currently dating. Later, I will write a scene where Alex will reject you if love is not high enough. For now it's just automatic. I noticed a little heart shows up in the social screen when you're dating Robin, but that doesn't happen for Alex so I may need to find that code and add it. 

-Added <<farm_work_update>> to try to fix error when you get assaulted after sleeping in the barn. Still not working, but now I think it's because I switched to cow instead of pigs. More work likely needed to add cows as they were not originally in the game.

---
## [godotengine/godot-docs@e1d18ee784...](https://github.com/godotengine/godot-docs/commit/e1d18ee784d74decf72177f5a7c2e9a0d17c0eff)
##### 2021-03-04 10:18:11 by RÃ©mi Verschelde

Remove controversial satirical piece ðŸ”¥

This piece was written back in 2014 before open sourcing Godot, and while its
intent is to be sarcastic, it leaves ample room for misinterpretation.

The intended meaning of this piece was, and always has been, the following:

Exploitative game mechanics suck. Games are a beautiful and artful medium
which can provide players with a wide range of experiences: entertainment,
enlightenment, joy, sadness... Games can be just for fun or they can bear
a message. They can connect people with each other or open the player's mind.

Make games worth your players' time and their money, and do your best to do so
while running a successful and respectful business. Hugs <3

(cherry picked from commit b872229427dddb9b749f46af597e85e25cf2955a)

---
## [mrakgr/The-Spiral-Language@dabb3e8026...](https://github.com/mrakgr/The-Spiral-Language/commit/dabb3e8026dd08c6d713f35e0969b38a8f206aed)
##### 2021-03-04 11:47:12 by Marko GrdiniÄ‡

"10:10am. I am up. Is the PL thread still not up yet. This is the longest I had to wait for it ever. Wow, it is still not out. Nevermind it then.

Let me chill just 5-10m.

10:25am. Let me start.

This applying to companies thing has been driving me insane. But it is good that I am going through this. I need to look at it from every available perspective.

I've been focusing too much on the benefits and too little on the disadvantages.

The disadvantage is that having sponsors would tie up my time, and once they go bust, a lot of my work would go to waste. Furthermore, most of the value captured from Spiral would go to them. Sure I could get 3k per month, but they would get large cost saving per each programmer. If using Spiral allows them to do the same kind of work with 3 programmers that would otherwise require 10, just how much would that win them.

A fair deal would be for them to pay royalties based on their cost savings. That would make my earnings astronomical.

And yet here I am getting concerned over not being taken advantage of.

What a fool I am.

10:30am. Seriously, if I still haven't crushed poker after some time, I should just make up my mind to do those 3k per month jobs for a single month. That will be enough to get me an upgrade. Hopefully Bitcoin will have crashed by that time. Its rise combined with Corona has sent computer component costs through the roof. It might not happen tomorrow, but probably by the end of next year.

3k per month is low, but I could easily get those and would not have to waste my time looking around or negotiating. That is the primary benefit of them. 6k would be better obviously, but I would not be able to get a much better rig than with 3k. Right now I do not need an upgrade.

10:35am. Now let me start.

It is finally time to do some work. This is where my real gains will come from.

I've made up my mind, I'll wait until I've gone through the MainStreamServer module and then I will just fire off the last batch of applications to everybody out there. I won't let this drag on anymore.

```fs
let cons_fulfilled l =
    let rec loop olds = function
        | Cons(old,next) when Promise.Now.isFulfilled next -> loop (PersistentVector.conj old olds) (Promise.Now.get next)
        | _ -> olds
    loop PersistentVector.empty l
type TypecheckerStream = EditorStream<ParserRes Promise, InferResult Stream>
let typechecker package_id module_id (path : string) top_env =
    let rec run old_results env i (bss : TopOffsetStatement list list) =
        match bss with
        | b :: bs ->
            match PersistentVector.tryNth i old_results with
            | Some (b', _, env as s) when b = b' -> Cons(s,Promise(run old_results env (i+1) bs))
            | _ ->
                let rec loop old_results env i = function
                    | b :: bs ->
                        let x = Infer.infer package_id module_id env (bundle_statements b)
                        let adds = match x.top_env_additions with AOpen x | AInclude x -> x
                        let _,_,env as s = b,x,Infer.union adds env
                        Cons(s,promise_thunk (fun () -> loop old_results env (i+1) bs))
                    | [] -> Nil
                loop old_results env i bss
        | [] -> Nil
    let rec loop r =
        {new TypecheckerStream with
            member _.Run(res) =
                let r = r()
                let r' =
                    r >>=* fun old_results ->
                    top_env >>= fun top_env ->
                    res >>- fun res ->
                    run (cons_fulfilled old_results) top_env 0 res.bundles
                let a = Stream.mapFun (fun (_,x,_) -> x) r'
                a, loop (fun () -> if Promise.Now.isFulfilled r' then r' else r)
            }
    loop (fun () -> Stream.nil)
```

10:45am. How complicated. Let me make a non-diffing version of this.

```fs
                        let x = Infer.infer package_id module_id env (bundle_statements b)
                        let adds = match x.top_env_additions with AOpen x | AInclude x -> x
                        let _,_,env as s = b,x,Infer.union adds env
                        Cons(s,promise_thunk (fun () -> loop old_results env (i+1) bs))
```

There 4 lines are most of the actual functionality.

```fs
let inline wdiff_fold f s x =
    let s = s()
    let p = promise_thunk_with (f s) x
    p, fun () -> if Promise.Now.isFulfilled p then Promise.Now.get p else s

let inline wdiff_mapFold f s x =
    let s = s()
    let p = promise_thunk_with (f s) x
    p >>-* fst, fun () -> if Promise.Now.isFulfilled p then snd (Promise.Now.get p) else s
```

Ah, this needs to be like so.

11:05am.

```fs
let typechecker package_id module_id top_env l : InferResult Stream =
    let rec loop env = function
        | l :: ls ->
            let x = Infer.infer package_id module_id env l
            let adds = match x.top_env_additions with AOpen x | AInclude x -> x
            let env = Infer.union adds env
            Cons(x,promise_thunk_with (loop env) ls)
        | [] ->
            Nil

    promise_thunk_with (loop top_env) l
```

This is how easy it would be without all the diff nonsense. Now let me do that as well.

11:40am.

```fs
type TypecheckerState = {
    package_id : int
    module_id : int
    top_env : TopEnv Promise
    results : (Bundle * InferResult * TopEnv) Stream
    }

let wdiff_typechecker (state : TypecheckerState) l =
    let rec loop env = function
        | l :: ls ->
            let x = Infer.infer state.package_id state.module_id env l
            let adds = match x.top_env_additions with AOpen x | AInclude x -> x
            let env = Infer.union adds env
            Cons((l,x,env),promise_thunk_with (loop env) ls)
        | [] ->
            Nil

    let rec diff env = function
        | Cons((b,_,env as x),next), b' :: bs when b = b' ->
            if Promise.Now.isFulfilled next then Cons(x,promise_thunk_with (diff env) (Promise.Now.get next,bs))
            else Cons(x,promise_thunk_with (loop env) bs)
        | _,bs -> loop env bs

    let results =
        state.top_env >>=* fun top_env ->
        state.results >>= fun r ->
        l >>- fun l -> diff top_env (r,l)
    Stream.mapFun (fun (_,x,_) -> x) results, {state with results = results}
```

Wow, just wow. This is it. This is the form I've been looking for.

This is much better than the old version. It is just so much clearer. The refactor has been worth it.

I love this. Clarity is compositional. If you do not understand one of the steps, you won't understand the follow ups either.

11:50am.

```fs
type ModuleId = int
type DiffableFileHierarchyT<'a,'b> =
    | File of path: string * name: string option * 'a
    | Directory of name: string * DiffableFileHierarchyT<'a,'b> list * 'b
type DiffableFileHierarchy =
    DiffableFileHierarchyT<
        (InferResult Stream * (ModuleId * TopEnv Promise)) option * ParserRes Promise * TypecheckerStream option,
        (ModuleId * TopEnv Promise) option
        >
type MultiFileStream = EditorStream<DiffableFileHierarchy list, Map<string,InferResult Stream> * TopEnv Promise>
```

Oh boy, now comes this.

12:40pm. I am grinding away at it.

```fs
// Rather than just throwing away the old results, diff returns the new tree with as much useful info from the old tree as is possible.
let diff_order_changed old new' =
    let mutable same_files = true
    let mutable same_order = true
    let rec elem (o,n) =
        match o,n with
        // In `n`, `meta` and `tc` fields are None.
        | File(path,name,(_,p,tc)) & o,File(path',name',(_,p',_)) when path = path' && name = name' ->
            if same_files then
                if Object.ReferenceEquals(p,p') then o
                else same_files <- false; File(path,name,(None,p',tc))
            else File(path,name,(None,p',None))
        | Directory(name,l,o), Directory(name',l',o') when name = name' -> Directory(name,list (l,l'),if same_files then o else o')
        | _, n -> same_order <- false; n
    and list = function
        | o :: o', n :: n' -> elem (o,n) :: (if same_order then list (o', n') else n')
        | [], [] -> []
        | _, n -> same_order <- false; n
    list (old,new')

let inline multi_file_run on_unchanged_file on_changed_file top_env_empty create_stream post_process_result union in_module package_id top_env files =
    let rec changed (module_id,top_env as i) x =
        match x with
        | File(path,_,(Some (r,o),_,_)) ->
            on_unchanged_file path r
            x, o
        | File(path,name,(None,res,tc)) ->
            let tc : EditorStream<_,_> = match tc with Some tc -> tc | None -> create_stream package_id module_id path top_env
            let r,tc = tc.Run res
            on_changed_file path r
            let top_env_additions =
                let adds = post_process_result r
                match name with
                | Some name -> adds >>-* in_module name
                | None -> adds
            let o = module_id+1, top_env_additions
            File(path,name,(Some (r,o),res,Some tc)),o
        | Directory(name,l,Some o) -> Directory(name,l,Some o), o
        | Directory(name,l,None) ->
            let l,(module_id,top_env_adds) = changed_list i l
            let o = module_id, top_env_adds >>-* in_module name
            Directory(name,l,Some o),o
    and changed_list (module_id,top_env) l =
        let o = module_id, Promise.Now.withValue(top_env_empty)
        let l,(_,o) =
            List.mapFold (fun (top_env, (module_id, top_env_adds as o)) x ->
                let i = module_id, top_env
                let x,(module_id,top_env_adds') = changed i x
                let union a b = a >>=* fun a -> b >>- fun b -> union a b
                let top_env = union top_env_adds' top_env
                let o = module_id, union top_env_adds' top_env_adds
                x,(top_env,o)
                ) (top_env,o) l
        l,o
    let i = 0, top_env
    let l,(_,top_env_adds) = changed_list i files
    top_env_adds, l
```

Figuring out how to simplify all of this is not an easy thing. It would be a lot easier if not for the directories.

I am getting some ideas for an alterantive design."

---
## [dit7ya/learn4haskell@543fa7fae1...](https://github.com/dit7ya/learn4haskell/commit/543fa7fae16fa72b295ddaccaa92ce573d8cbfc2)
##### 2021-03-04 13:58:28 by arpl

Typos Chapters 1, 2, 3 & 4 (#343)

* Create ARPL @vrom911

Little intro.
==== DELETE THIS FILE ====

* Minor typos

* Small typos

* Typos (and small comment)

Pattern matching:
"The syntax of using pattern matching is similar to defining ordinary functions, but instead of using variable names, you use the values."
  and
"Note that you can pattern match on a variable too! Variable is like a pattern that matches any value and gives it a name. You can think of variables in function definitions as special cases of pattern matching."
==> Formulation is a little confusing.

* Small typos (and comment)

I like the quote you put in from Jasper Van der Jeugt. It was the typo in his name that prompted me to fork. : )
I had read through this tutorial and it was clear that many of the 'typos' had their origin in the fact that your native language is Russian. But I found that quite charming. : ) I did think that some of them might be a bit 'jarring' for some readers but so be it. However, it is never bad to make the experience 'smoother'.
Earlier I saw the keynote by Simon Peyton Jones at Scala eXchange 2020 and SPJ /also/ wrote his name wrong (different error though). Attributions are not difficult to get right.
But it must be something with Dutch/Flemish that the rest of the world finds difficult. I have stopped using my own name in international contexts for over 2 decades. You can call me whatever you like, but if you use my actual name I do appreciate it be written correctly. (Or pronounced correctly ... which my American wife still can't do ... so I changed my name to help her out. : )
Feel free to ignore/reject all my edits, but please keep the correction on Jasper's name. : )

* Minor typos

* Delete ARPL @vrom911

---
## [SgtHunk/fulpstation-1@92b564b66b...](https://github.com/SgtHunk/fulpstation-1/commit/92b564b66bfedfda9a6f844762ac59b9ab29c223)
##### 2021-03-04 16:02:51 by SgtHunk

HEEHEE WOW LOOK AT ME I'M A FULPSTATION CODER

OH LOOK AT MY BEAUTIFUL "MODULAR" CODE THATS ONLY MODULAR WHEN THE FUCKING HEADCODER ENFORCES IT! MY CODE IS SO FUCKING ABSOLUTELY MODULAR FROM OVERWRITING AN ESSENTIAL TG FUNCTION, JUST BECAUSE IT DOESN'T EDIT A TG FILE THAT WAY! YEP! NO COMPLAINTS FROM THE HEADCODER! NO COMPLAINTS FROM A FELLOW CODER! I WAS JUST CODING AND OVERWROTE AN ENTIRE FUNCTION FOR MY STUPID FUCKING FEATURE! EDITING TG FILES? SOUNDS LIKE YOU'RE JUST A FUCKING SHITCODER. PARDON MY INNABILITY TO FUCKING TALK PERRPEDRLY AS I FUCKING BREAK THE ENTIRE GAME BY A SINGLE OVERWRITE, RESULTING IN THOUSANDS (AND YES, AGGONNIZZINGG FUCKING) RUNTIMES, CRASHING THE SERVER!
Honestly fulp coders are so fucking stupid. nobody who actually codes tries to modularize it. Its an inbetween semi-modular/non-modular at most. And when people ARE ACTUALLY having working features, they do it by editing TG files. half of the fulp coders are okay while the other half are completely fucking real life brain damaged. Honestly, why the FUCK would you MODULARIZE something that WILL BREAK no matter what? WHAT FUCKING REASON do you have to tell me to modularize my code for something that NOBODY other than your stupid, fucking horrible programming self had a problem with. I hate Baycode, and I think that most of t heir coders aren't the best (same for TG) but you know what they do right? They let people code without restraints. As long as something is a good feature, as long as maintainers aren't complaining, they let it be. OH, AND TO FUCKING TOP IT ALL OFF, AND THIS, THIS IS FUCKING UNFORGIVABLE, ON THE REPOSITORY'S PAGE, THE FUCKING LINK THAT IS FOR "DISCORD" DOESN'T EVEN REDIRECT TO A FULP CODERBUS. WHAT DO YOU WANT ME TO DO? JOIN YOUR SHITTY FUCKING DISCORD SERVER? Fuck fulp coders. fucking shitty ass coders.

---
## [Deteriorator/git@4e168333a8...](https://github.com/Deteriorator/git/commit/4e168333a8716d902aed10c74ae5e408e683f902)
##### 2021-03-04 19:06:33 by Ã†var ArnfjÃ¶rÃ° Bjarmason

shortlog: remove unused(?) "repo-abbrev" feature

Remove support for the magical "repo-abbrev" comment in .mailmap
files. This was added to .mailmap parsing in [1], as a generalized
feature of the git-shortlog Perl script added earlier in [2].

There was no documentation or tests for this feature, and I don't
think it's used in practice anymore.

What it did was to allow you to specify a single string to be
search-replaced with "/.../" in the .mailmap file. E.g. for
linux.git's current .mailmap:

    git archive --remote=git@gitlab.com:linux-kernel/linux.git \
        HEAD -- .mailmap | grep -a repo-abbrev
    # repo-abbrev: /pub/scm/linux/kernel/git/

Then when running e.g.:

    git shortlog --merges --author=Linus -1 v5.10-rc7..v5.10 | grep Merge

We'd emit (the [...] is mine):

      Merge tag [...]git://git.kernel.org/.../tip/tip

But will now emit:

      Merge tag [...]git.kernel.org/pub/scm/linux/kernel/git/tip/tip

I think at this point this is just a historical artifact we can get
rid of. It was initially meant for Linus's own use when we integrated
the Perl script[2], but since then it seems he's stopped using it.

Digging through Linus's release announcements on the LKML[3] the last
release I can find that made use of this output is Linux 2.6.25-rc6
back in March 2008[4]. Later on Linus started using --no-merges[5],
and nowadays seems to prefer some custom not-quite-shortlog format of
merges from lieutenants[6].

You will still see it on linux.git if you run "git shortlog" manually
yourself with --merges, with this removed you can still get the same
output with:

    git log --pretty=fuller v5.10-rc7..v5.10 |
    sed 's!/pub/scm/linux/kernel/git/!/.../!g' |
    git shortlog

Arguably we should do the same for the search-replacing of "[PATCH]"
at the beginning with "". That seems to be another relic of a bygone
era when linux.git patches would have their E-Mail subject lines
applied as-is by "git am" or whatever. But we documented that feature
in "git-shortlog(1)", and it seems more widely applicable than
something purely kernel-specific.

1. 7595e2ee6ef (git-shortlog: make common repository prefix
   configurable with .mailmap, 2006-11-25)
2. fa375c7f1b6 (Add git-shortlog perl script, 2005-06-04)
3. https://lore.kernel.org/lkml/
4. https://lore.kernel.org/lkml/alpine.LFD.1.00.0803161651350.3020@woody.linux-foundation.org/
5. https://lore.kernel.org/lkml/BANLkTinrbh7Xi27an3uY7pDWrNKhJRYmEA@mail.gmail.com/
6. https://lore.kernel.org/lkml/CAHk-=wg1+kf1AVzXA-RQX0zjM6t9J2Kay9xyuNqcFHWV-y5ZYw@mail.gmail.com/

Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Ã†var ArnfjÃ¶rÃ° Bjarmason <avarab@gmail.com>
Signed-off-by: Junio C Hamano <gitster@pobox.com>
