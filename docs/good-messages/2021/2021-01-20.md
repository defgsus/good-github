# [<](2021-01-19.md) 2021-01-20 [>](2021-01-21.md)

3,078,587 events, 1,423,695 push events, 2,251,642 commit messages, 181,085,811 characters


## [jws85/Dotfiles](https://github.com/jws85/Dotfiles)@[5b0f09a301...](https://github.com/jws85/Dotfiles/commit/5b0f09a3013c7fdc3373cefe6d6014bb2b801593)
#### Wednesday 2021-01-20 03:45:59 by J. W. Smith

Move *everything* into the i3 role

I've been unenthusiastic about my half-stow, half-ansible setup.

I contemplated yeeting ansible, but I'm already "here" with it, and
going to Plain Ol' Bash Scripts would lose a fair bit of pre-made
functionality that I'm getting now "for free."

I'm not getting much from stow that I couldn't already be getting from
moving everything inside ansible; plus I don't have to slavishly
replicate the file structure or worry about config files getting
checked in or whatever.

At some point I'm going to do this to all of my roles and get rid of
stow entirely, and by doing so move the entire playbook directory into
the project root.  Yeah Ansible's the heavyweight, anti-Unix solution
here, but honestly I don't care at this point so long as I have to do
less thinking!

---
## [ccodwg/Covid19Canada](https://github.com/ccodwg/Covid19Canada)@[8b19833842...](https://github.com/ccodwg/Covid19Canada/commit/8b198338426c27ca83e368eb7431683539c1fb2e)
#### Wednesday 2021-01-20 04:20:27 by Jean-Paul R. Soucy

New data: 2021-01-19: See data notes for important messages.

Vaccine datasets:

- 2021-01-19: Fully vaccinated data have been added (vaccine_completion_cumulative.csv, timeseries_prov/vaccine_completion_timeseries_prov.csv, timeseries_canada/vaccine_completion_timeseries_canada.csv). Note that this value is not currently reported by all provinces (some provinces have all 0s).
- 2021-01-11: Our Ontario vaccine dataset has changed. Previously, we used two datasets: the MoH Daily Situation Report (https://www.oha.com/news/updates-on-the-novel-coronavirus), which is released weekdays in the evenings, and the “COVID-19 Vaccine Data in Ontario” dataset (https://data.ontario.ca/dataset/covid-19-vaccine-data-in-ontario), which is released every day in the mornings. Because the Daily Situation Report is released later in the day, it has more up-to-date numbers. However, since it is not available on weekends, this leads to an artificial “dip” in numbers on Saturday and “jump” on Monday due to the transition between data sources. We will now exclusively use the daily “COVID-19 Vaccine Data in Ontario” dataset. Although our numbers will be slightly less timely, the daily values will be consistent. We have replaced our historical dataset with “COVID-19 Vaccine Data in Ontario” as far back as they are available.
- 2020-12-17: Vaccination data have been added as time series in timeseries_prov and timeseries_hr.
- 2020-12-15: We have added two vaccine datasets to the repository, vaccine_administration_cumulative.csv and vaccine_distribution_cumulative.csv. These data should be considered preliminary and are subject to change and revision. The format of these new datasets may also change at any time as the data situation evolves.

Upcoming changes (specific dates to be announced soon):

- The data structure of time series data will change in response to user feedback. This will only consist of adding additional columns to make the data easier to work with. The core columns will remain the same, for now. More details to follow. Initially, the updated dataset will be provided alongside the new dataset. After a time, the new data format will completely replace the old format.

Recent changes:

- 2021-01-08: The directories cases_extra and mortality_extra have been moved to other/cases_extra and other/mortality_extra.

Revise historical data: cases (AB, BC, MB, ON, QC, SK).

Note regarding deaths added in QC today: “The data also report 55 new deaths, for a total of 9,142. Among these 55 deaths, 16 have occurred in the last 24 hours, 33 have occurred between January 12 and January 17 and 6 have occurred before January 12.” We report deaths such that our cumulative regional totals match today’s values. This sometimes results in extra deaths with today’s date when older deaths are removed.

https://www.quebec.ca/en/health/health-issues/a-z/2019-coronavirus/situation-coronavirus-in-quebec/#c47900

Note about SK data: As of 2020-12-14, we are providing a daily version of the official SK dataset that is compatible with the rest of our dataset in the folder official_datasets/sk. See below for information about our regular updates.

SK transitioned to reporting according to a new, expanded set of health regions on 2020-09-14. Unfortunately, the new health regions do not correspond exactly to the old health regions. Additionally, the provided case time series using the new boundaries do not exist for dates earlier than August 4, making providing a time series using the new boundaries impossible.

For now, we are adding new cases according to the list of new cases given in the “highlights” section of the SK government website (https://dashboard.saskatchewan.ca/health-wellness/covid-19/cases). These new cases are roughly grouped according to the old boundaries. However, health region totals were redistributed when the new boundaries were instituted on 2020-09-14, so while our daily case numbers match the numbers given in this section, our cumulative totals do not. We have reached out to the SK government to determine how this issue can be resolved. We will rectify our SK health region time series as soon it becomes possible to do so.

---
## [FiestaLake/Smg-Kernel-Project_heroxlte](https://github.com/FiestaLake/Smg-Kernel-Project_heroxlte)@[8c17675c7c...](https://github.com/FiestaLake/Smg-Kernel-Project_heroxlte/commit/8c17675c7c0eba821eee9bf68349d994ae4938b8)
#### Wednesday 2021-01-20 05:40:29 by Masahiro Yamada

BACKPORT: modpost: file2alias: go back to simple devtable lookup

Commit e49ce14150c6 ("modpost: use linker section to generate table.")
was not so cool as we had expected first; it ended up with ugly section
hacks when commit dd2a3acaecd7 ("mod/file2alias: make modpost compile
on darwin again") came in.

Given a certain degree of unknowledge about the link stage of host
programs, I really want to see simple, stupid table lookup so that
this works in the same way regardless of the underlying executable
format.

Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
Acked-by: Mathieu Malaterre <malat@debian.org>
Link: https://git.kernel.org/linus/ec91e78d378cc5d4b43805a1227d8e04e5dfa17d
Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
Signed-off-by: Samuel Pascua <pascua.samuel.14@gmail.com>
Signed-off-by: FiestaLake <FiestaLake@protonmail.com>

---
## [Traap/kjv](https://github.com/Traap/kjv)@[77c923823a...](https://github.com/Traap/kjv/commit/77c923823a507a230cea7cdb540191c9f8ef9eec)
#### Wednesday 2021-01-20 06:11:08 by Traap

Refactor main() method.

main() uses helper functions carry out each process step.

As I stuidied main(), I organized logical chunks of code into
static functions.  The new functions are:
  kjv-init_config
  kjv-process-command-line
  kjv_list_books
  kjv_line_length
  kjv_fetch_verse

Version 1.1.1.60

Note. I bump the build number each with each successful make command.

The test output was captured using the comand below.
./kjv eph 2:8-9 -A 3 -B 3 -b -d -w 50

Ephesiansm

2:5 Even when we were dead in
	sins, hath quickened us
	together with Christ, (by
	grace ye are saved;)

2:6 And hath raised us up
	together, and made us sit
	together in heavenly places in
	Christ Jesus:

2:7 That in the ages to come he
	might shew the exceeding
	riches of his grace in his
	kindness toward us through
	Christ Jesus.

2:8 For by grace are ye saved
	through faith; and that not of
	yourselves: it is the gift of
	God:

2:9 Not of works, lest any man
	should boast.

2:10 For we are his workmanship,
	created in Christ Jesus unto
	good works, which God hath
	before ordained that we should
	walk in them.

2:11 Wherefore remember, that ye
	being in time past Gentiles in
	the flesh, who are called
	Uncircumcision by that which
	is called the Circumcision in
	the flesh made by hands;

2:12 That at that time ye were
	without Christ, being aliens
	from the commonwealth of
	Israel, and strangers from the
	covenants of promise, having
	no hope, and without God in
	the world:

---
## [lleiding/gemm](https://github.com/lleiding/gemm)@[9913e4db5c...](https://github.com/lleiding/gemm/commit/9913e4db5c5fb26b0f7197095282c064d9290ec0)
#### Wednesday 2021-01-20 11:00:56 by Daniel Vedder

Major refactor: all settings now globally available via `setting()`

Rationale: "The road to programmer hell is paved with global
variables", but in some cases, "practicality beats purity". In this
instance, we already had several debates about whether it wouldn't
make more sense to make settings available globally instead of always
passing it around via function arguments.

Using function arguments means we can avoid a global variable and
limits access to the settings dict to those functions that really need
it. However, in practice, almost all function *do* need it. (And in a
few annoying cases, the parent function doesn't, but a function it
calls does.) Effectively, the settings dict was being passed to most
functions, which pretty much makes it a global variable anyway.

Therefore, I have now "taken it out of circulation" and stuck the
actual settings dict in a `let` block in `run_simulation.jl`. The way
to access it is now via `setting()`. This has simplified a lot of code.
An added advantage is that any changes to the settings dict by the software
have to be explicitly declared, as you now have to use
`initsettings()` or `updatesettings()` for that.

---
## [mrakgr/The-Spiral-Language](https://github.com/mrakgr/The-Spiral-Language)@[42a61e4f49...](https://github.com/mrakgr/The-Spiral-Language/commit/42a61e4f499ee96cb71b43de9d7ec334ae6befa9)
#### Wednesday 2021-01-20 11:07:11 by Marko Grdinić

"10:25am. I am up. Today is the interview day. I am going to start off slowly. I'll mix things up a bit. I won't fire 20 emails to all the different companies all at once. Instead, I'll pick a top tier company like Groq or Graphcore, and 3 or so lesser ones and make that my daily target. Once I get some feedback, I'll tune my pitch for the next try. Rather than emptying my whole clip, I should fire a burst at a time.

Companies like Xanadu, Cornami, and Intel('s neurochip division) are traps, so I'll ignore them for the time being. The ideal place to be in is to have a sponsor or a few, and using hardware that will allow me to leapfrog where I was in 2018. That means, no messing with quantum computers, adaptible hardware or neurochips. I do not want to turn my successful application into a years long research project.

I had a lot of success improving my concurrency skills in 2020, and 2021 should be continuation of that. I should not try to master completely new programming models on too novel hardware, instead chips that have many cores communicating with message passing and local memory is what I should master here. This will be sustainable model.

If my plan of ensemble learning turns out to stabilize RL enough to make me confident to be able to use it in the real world, then I will be able to use it to make the kind of income salaried programmers can only dream about. 100ks per month eventually is not out of the question. This kind of position would be extremely strong too. I'd have top notch programming skills, access to the right hardware, and my fingers on the pulse of the ML community. After poker, there are all sorts of games waiting me to master them too, and that path culminates in me becoming good to tackle real life using AI.

Ensembles are good. Yes, I am picking a lower hanging fruit here. If I was really smart I'd derive some algorithm better than backprop instead of taking the easy road of buffing it. But I think that whatever algorithm will come after backprop will also benefit from ensembles. Ultimately, learning is NP Hard, and no algorithm will be the holy grail. In 2018, offense completely failed me, so I will play defense.

Somewhat ironically, my 2018 ML attempt was quite similar to the 2007-2014 trading attempt, in that the benefits I got from it were not at all what I aimed for.

10:40am. For ensembles, I do in fact need better hardware. GPUs would just choke on them. Local memory is a must.

So I must start applying. I am not sure if Graphcore's chips are commercial yet, or if they will soon be...Amazon search turns out nothing, but even if they were I could not afford them at the moment.

10:45am. Now...

11:10pm. https://news.ycombinator.com/item?id=25821340
The Spiral Language v2

I noticed this thread yesterday, but ignored it.

> What does inlining have to do with heap allocation? I would have thought the opposite of heap allocation was "stack allocation"? In particular, I would expect that inlining would produce no effect on the number or size of heap allocations?

///

If you have a function, there is a certain equivalence (in terms of compilation) where you can either allocate it as a closure at runtime or emulate the effect of that by just tracking it fully at compile time and inlining it a the site of use. If you do the later, you can avoid having to do a heap allocation that having a runtime closure would require.

I said it is an equivalence in terms of compilation because, whether it is allocated as a closure on the heap, or tracked at compile time has no bearing on the correctness of the program. It only affect its memory allocation and performance profile.

If you are a C programmer, or working at a similar level of abstraction, this concern over heap allocations might seem academic, but to a functional programmer such as myself there is a lot of importance because we use function composition for all of our abstractions and don't want them to heap allocate as closures. The more abstract the code we are writing is, the more inlining matters.

The way I am describing this is confusing because inlining is not an event that happens. Rather inlining is the default. Tracking functions at compile time is the default. Heap allocation of them and their conversion into closures is an event, after which the compiler stops tracking variables of a function on an individual basis and keeps track of them at a lower resolution.

> I would have thought the opposite of heap allocation was "stack allocation"?

The way I think about this is not in terms of where the variables are allocated, but by how they are tracked. Compile-time functions track their variables individually, and heap allocating them is a simple operation that can be done at any time assuming the partial evaluator knows what its type is.

///

Should I reply with this. I feel that this will confuse the guy. Let me try something else for that later part.

///

If you have a function, there is a certain equivalence (in terms of compilation) where you can either allocate it as a closure at runtime or emulate the effect of that by just tracking it fully at compile time and inlining it a the site of use. If you do the later, you can avoid having to do a heap allocation that having a runtime closure would require.

I said it is an equivalence in terms of compilation because, whether it is allocated as a closure on the heap, or tracked at compile time has no bearing on the correctness of the program. It only affect its memory allocation and performance profile.

If you are a C programmer, or working at a similar level of abstraction, this concern over heap allocations might seem academic, but to a functional programmer such as myself there is a lot of importance because we use function composition for all of our abstractions and don't want them to heap allocate as closures. The more abstract the code we are writing is, the more inlining matters.

The way I am describing this is confusing because inlining is not an event that happens. Rather inlining is the default. Tracking functions at compile time is the default. Heap allocation of them and their conversion into closures is an event, after which the compiler stops tracking variables of a function on an individual basis and keeps track of them at a lower resolution.

> I would have thought the opposite of heap allocation was "stack allocation"?

      | Stack | Heap
------|-------------
Full  |   x   |
Box   |       |  x

To get a full picture of how Spiral's partial evaluator sees functions and recursive unions, it consider the table above. Spiral is designed so that it is very easy to go between the fully known and boxed. You don't actually control heap and stack allocations explicitly, but instead shift the perspective of the partial evaluator through the dyn patterns and control flow.

It just so happens that a very natural way of generating code for fully known functions is to leave their variables as they are on the stack. If the function needs to be tracked at runtime, then those variables are used to make a closure. The natural way of compiling things that are fully known (functions, unboxed unions) is to put them the stack. While things that are boxed (closures, boxed recursive unions) are on the heap.

This is just on the F# backend. If I were compiling to LLVM for example, I would not use a stack, but the infinite amount of virtual registers instead. And non-recursive union types are compiled as structs, meaning they should be on the stack even in boxed mode.

This view of memory is more complicated than the usual heap vs stack allocation one, because I am playing a game here where I attach a bunch of other concepts to it, but it is very useful and simplifies actual programming.

///

Let me go with this.

Ugh, the table came out so horrible.

https://pastebin.com/G5vBt0cC

12:05pm. Let me read the Mahoako thread and watch Snk

Today is a day for taking it easy it seems. It has been a while since I wrote a longish post online."

---
## [xmhuangzhen/Compiler](https://github.com/xmhuangzhen/Compiler)@[0a3163fa35...](https://github.com/xmhuangzhen/Compiler/commit/0a3163fa35b5bbe571538cbff256ef08bd141a3d)
#### Wednesday 2021-01-20 11:22:10 by xmhuangzhen

Love implies sharing meanings we construct on an ongoing basis of life experience and shifting life realities.

---
## [rockso7/Kaggle](https://github.com/rockso7/Kaggle)@[483463aca3...](https://github.com/rockso7/Kaggle/commit/483463aca30567a42937e00e15221a76eff573a6)
#### Wednesday 2021-01-20 12:47:08 by Anti Matter

Update Lvl2-Heuristic One Step lookahead

Copy pasting shit temp made my brain hazy lol. I was wondering why the thing wouldn't work before, and I realised a col parameter was missing from get_heuristic. Now I realise, that's bullshit.
There doesn't need to be a col parameter in get_heuristic; it doesn't use it! So in score_moves, it should only call a get_heuristic with 3 parameters! No need to enter col. lol. Oopsies. Learning though!

---
## [KathyRyals/sojourn-station](https://github.com/KathyRyals/sojourn-station)@[a4ea03d27e...](https://github.com/KathyRyals/sojourn-station/commit/a4ea03d27e9007eb68988fff069bc81719296ed4)
#### Wednesday 2021-01-20 13:22:39 by Trilbyspaceclone

Borg love (#465)

* Borg love

* smallest of fix, we dont magicly make fuel

* nitpick

---
## [acrazyczy/Supernova](https://github.com/acrazyczy/Supernova)@[52487ff439...](https://github.com/acrazyczy/Supernova/commit/52487ff439180ce33e5de4e88d11f135814b3237)
#### Wednesday 2021-01-20 13:45:23 by crazy_cloud

I am the sword in the darkness. I am the watcher on the walls. I am the shield that guards the realms of men. I pledge my life and honor to the Night's Watch, for this night and all the nights to come. | fix some bugs

---
## [Batman27801/Ashanti](https://github.com/Batman27801/Ashanti)@[8722acb717...](https://github.com/Batman27801/Ashanti/commit/8722acb7173178581aef9c135b814da1489919ce)
#### Wednesday 2021-01-20 13:53:09 by Batman27801

added some shit this truly is it boys

It has been a pleasure to lead you fine gentlemen into data structures glory. God knows that i have given it my all.

---
## [LDR-Siren/EmilyC-SamanthaPrater-EruzaArto](https://github.com/LDR-Siren/EmilyC-SamanthaPrater-EruzaArto)@[f22d1e9a7c...](https://github.com/LDR-Siren/EmilyC-SamanthaPrater-EruzaArto/commit/f22d1e9a7c88f6cb731264a5c52eb967bfa79d8e)
#### Wednesday 2021-01-20 14:04:04 by LDR

Add files via upload

Oh last night was hilarious! So she got a hold of this lovely repo. And the first thing she attacks is the Aliases. Oh I about died on that. Because she obviously does not know what Alias means: Thank you Webster for this.

"An alias name or AKA (also known as) is any name that has been used by the candidate in the past. Life events such as marriage and divorce result in many candidates with records associated with more than one name. It is possible that criminal records could exist under any prior name." 

In other words, that list is a known list of all her Aliases or AKA's. So while she scribbled all over it(btw breaking the copyright I have on this repo, its on the front page), she proved that we were right on all those names. Sucks to be here.

And in the midst of all this, she goes off on me and this repository. To clarify something. This repository was originally created as a means to see all the harassment coming from her via Notecards, and FLICKR messages, and anything else she wanted to throw at me, so I could see for myself that I was not imagining anything. It has turned into a place to dump all the crap she spews for when we finally need it. But I am not the only one who has started a repository. Squirrel(lovely sarcastic brilliant Squirrel) has done the same.  Its not paranoia or I need a hobby.

I do this for 10 minutes out of every morning. Thats it. The information that often gets thrown in here now, comes from screen grabbers in my discord. There are a lot of us that contribute. So when I say this is a work of love, I just organize things into neat little folders, those girls and guys that hate her guts, do all the work. I have a job, a family, and hobbies, like finding patterns right now for kilts for my husband and son.

Lets touch on that too. She likes to focus on 1 child. My daughter. I have 2. My daughter right now is in that teenage state of only wanting mom when she needs an opinion about her drawing, nibbles, or cuddles(she acts like a cat and I am not against this). My Son, is still a little sprout. And he takes up a lot more time than my daughter does. Not because I favor him more, she doesn't need me right now as much as he does, and she will tell me when she needs me. So while I find it funny Emily only focuses on my daughter, I have 2 children. 

Speaking of my daughter, and this has come up in the past, many of us feel it is because Cheshire is Autistic, that Emily focuses so hard on her and not my son(who has a learning disability as well). She tries to associate herself with Cheshire not realizing, Cheshire and her are NOTHING alike and using Cheshire as a means to get me on her(Emily's) side only does the opposite.  Cheshire is a beautiful, loving, empathetic teenager with immense amount of raw artistic talent that we have been helping focus her with for ages. She is smarter than Emily will ever be, kinder, doesn't bully people, not even her brother, and knows how to treat people. She understands the words no, and leave me alone, stop, and not right now. She does not push anything on anyone, but will make a pretty decent argument when she has to. She doesn't need to spam me or her father to get something she wants, she simply asks the right way the First TIme! Unlike Emily who is a complete Nightmare of a person.

IQ! HOLY HELLS I woke up to this and damn near laughed my ass off. So she tried to say that her chromosomes can not lead to her having a low IQ. Lets clarify this, I am bringing in the words of the wise person I know who knows all about this.

"She has a microdeletion of a small portion of a chromosome. I also already explained that to her long ago when she was whining in a voice chat about being missing chromosomes and I explained exactly what 22Q is and what tiny fraction of a chromosome is damaged. If she was missing an entire chromosome, much less several like she says, she wouldn't have been born alive. And IQ isn't compared to chromosomal count at all. Maybe because of the Q in 22q so...her usual being a moron and not able to read properly." (This conversation can be found above in today's commit)

She has also gone off recently, about having her IQ tested by her doctors when she was a kid, hence, they took into consideration her mental incapability's at the time of the test. Unless she did one online, then the odds were already stacked against her. And its been stated by several renowned websites and professionals, that IQ deteriorates over age.  So her age has likely lowered that number as well further. The damn thing about this is, its not her IQ that we base a lot of our Idiot comments off of, frankly its her actions. 

And the last 4 images is indicator she is in the apology phase again. I think this is 3 times in the past 2 weeks. Honestly we have in the Dibney Cru simply laughed it off. Its not sincere she doesn't mean it, and we have heard it and seen it so many times, its just words.  Now if she actually stopped her drama mongering, shut up about everyone and I mean everyone, this whole thing would have died ages ago. But she simply can not. Again that leads back to the Narcissism that is prevalent in her actions. And her own words for that matter. She needs this attention.

Oh a quick things: We found her tiktok thanks to her blasting that when she doodled on the aliases page, if I am not mistaken, most of us on TikTok now have her blocked. I know I do. 

Have a good day folks!

---
## [oranche-manufacturing/oranche-standard-issue](https://github.com/oranche-manufacturing/oranche-standard-issue)@[98eb33fefc...](https://github.com/oranche-manufacturing/oranche-standard-issue/commit/98eb33fefcf9bca98448716c27fdef23f79d191f)
#### Wednesday 2021-01-20 15:36:49 by rzen1th

cylo's glock attachments, magnum sniper slight changes

i helped write the des crip tions. fuck your

---
## [thecsw/thecsw.github.io](https://github.com/thecsw/thecsw.github.io)@[c9100652b4...](https://github.com/thecsw/thecsw.github.io/commit/c9100652b4ea2069f004f22b53e825aecd31807a)
#### Wednesday 2021-01-20 16:06:29 by Root Terraria

[ASTRIE] Added a new fortune: *** 20; 12021 H.E.

Prince Wang's programmer was coding software. His fingers danced upon the keyboard. The program compiled without and error message, and the program ran like a gentle wind.

"Excellent!" the Prince exclaimed. "Your technique is faultless!"

"Technique?" said the programmer, turning from his terminal, "What I follow is Tao -- beyond all techniques! When I first began to program, I would see before me the whole problem in one mass. After three years, I no longer saw this mass. Instead, I used subroutines. But now I see nothing. My whole being exists in a formless void. My senses are idle. My spirit, free to work without a plan, follows its own instinct. In short, my program writes itself. True, sometimes there are difficult problems. I see them coming, I slow down, I watch silently. Then I change a single line of code and the difficulties vanish like puffs of idle smoke. I then compile the program. I sit still and let the joy of the work fill my being. I close my eyes for a moment and then log off."

Prince Wang said, "Would that all of my programmers were as wise!"

-- Geoffrey James, "The Tao of Programming"

---
## [mrakgr/The-Spiral-Language](https://github.com/mrakgr/The-Spiral-Language)@[c1f506fddc...](https://github.com/mrakgr/The-Spiral-Language/commit/c1f506fddc05f4072e65c532ed62312d48a63248)
#### Wednesday 2021-01-20 17:43:36 by Marko Grdinić

"1:25pm. Ex-Arm and then I'll do the chores. After that I'll get composing.

I am going to have to do some things while I wait for the replies. The first thing I should do is fill out the core library docs. I should put in the comments for every top level function.

I am not sure what to do apart from that, maybe I'll take a look a look at the docs for some of these devices and see if they have an emulator.

Whatever I do, I should not see this period as an oppotunity to do nothing.

Today I've been feeling a bit nervous and relaxed myself. Once it is time to resume I should pick up the tension.

A smallish vacation every once in a while is not bad.

2:10pm. Enough fooling around. Let me do the chores here. After that comes composing the mails. After that I'll get started on documenting the library functions. There isn't that much to document at the moment actually. I'll have it easy. But getting to this point is what I've been hard at work. So this situation I am in right now is my reward. A slight lul in the frenzy is what I've earned.

2:45pm. Done with chores. Let me start.

First let me pick 4 targets.

Graphcore
Fathom Computing
Lightelligence
Lightmatter

The last 3 are in the dev stage. Graphcore is fairly mature in constrast. Graphcore is my biggest hope here, but I need a few more experimental picks just to get a sense where the companies are. The last 3 might be duds today, but eventually they will be in the sampling stage. I might be able to make a deal with them at that time.

The subject of the mail should be: "Seeking a sponsor for the Spiral programming language". Even though I am seeking multiple sponsors, I should put "a sponsor" rather than "sponsors" here. Alternative I could put in "sponsorship".

It is really interesting how many photonic companies there are in this field. I am looking at it now, and it seems Fathom does that too.

3pm. Now I need to do the body here. Focus me. This is not a one-to-one conversation, so I can afford to use my brain and think my sentences through to achieve maximum diplomacy.

Focus me. The body:

///

For the past year I've been working on a new version of the [Spiral programming language](https://github.com/mrakgr/The-Spiral-Language). It is ready to be put to use in the real world and I'd like a chance to demonstrate its capabilities. For that I'd like to receive access to your hardware and a monthly stipend.

The selling points are as follows:

* Do you know about Nvidia's Cuda? Nvidia is quite proud of it, but ultimately the C++ language which it is based on is hard to use and learn. Furthermore, C++ compilers are very hard to make. You'd as a company would need to make large investments of both time and money to make this sort of language support viable.

* Spiral is small, quick and well-designed functional language. It can be used as a much better replacement for C++. It can be used a replacement for lower level languages like C. If the only thing you have is Assembly then you could Spiral would allow you to skip making a C compiler and use it directly. By adopting it, you would have a tool capable of doing the low level plumbing while at the same time capable of creating high level ML libraries.

* If you already have a software stack in any language (or stacks of languages), Spiral can be easily adjusted to interop with it. In the old version, Spiral compiled to F# while seamlessly generating Cuda kernels its ML library needed. Do you want the language to interop with the Python ecosystem while producing the necessary code to run your own AI chip. That can be arranged without too much effort. Do you produce much low level repetitive code that you need to interop with high level garbage collected languages? Spiral could be configured to act as a fancy code generator as well.

I am offering to radically cut down on the costs of doing your software stack.

If you as a company have any ambition whatsoever for your chips to be used for general computation please consider Spiral. If your software team has had any positive experiences with functional languages they will love Spiral. Don't let your team grind away using C. Spiral is the competitive edge you will appreciate.

I'd like to hear what the biggest sources of friction in your software stack are. Maybe I would be able to make things smoother.

///

4pm. I am not selling myself, but Spiral instead so I do not need to plug my own personal data or resume here. This is the chad way of life. If the other side wants that info I can go into it.

> I am offering to radically cut down on the costs of doing your software stack.

I am being 100% truthful on this as strange as it is. There is a lot of benefit to be had from using Spiral for others.

Let me put this through the language tool. I had one typo it seems. Ok.

4:15pm. I am thinking. I've cranked up my brain and the above came out. This is the clearest way that I can think of getting my point across. I could into great depth here, but I doubt the guys on the other side want to read a novel in my application. Simple is best here.

4:20pm. Instead of hesitating, let me just fire off the emails here. If this fails, I'll get feedback and make a more appropriate email next time.

First off, let me try Graphcore.

https://www.graphcore.ai/jobs

It seems they are mostly looking for C++ engineers. I need to dig up an email.

> For careers visit our Careers page or email us at:
careers@graphcore.ai

I think this is the email that I need.

4:30pm. I am thinking whether I should adjust the email to more reflect Graphcore's reality. They are using C++, so I can change things a bit...

But if Graphcore is determined to hire as many C++ engineers as it can, then I am not going to be able to make to make headway either way. The fact that Spiral can do high and the low level equally well is a part of its pitch. Let me go with what I have. There is no point in hesitating here.

///

Subject: Seeking a sponsor for the Spiral programming language

---

Link: https://github.com/mrakgr/The-Spiral-Language

For the past year I've been working on a new version of the Spiral programming language. It is ready to be put to use in the real world and I'd like a chance to demonstrate its capabilities. For that I'd like to receive access to your hardware and a monthly stipend.

The selling points are as follows:

* Do you know about Nvidia's Cuda? Nvidia is quite proud of it, but ultimately the C++ language which it is based on is hard to use and learn. Furthermore, C++ compilers are very hard to make. You'd as a company would need to make large investments of both time and money to make this sort of language support viable.

* Spiral is small, quick and well-designed functional language. It can be used as a much better replacement for C++. It can be used as a replacement for lower level languages like C. If the only thing you have is Assembly then you could Spiral would allow you to skip making a C compiler and use it directly. By adopting it, you would have a tool capable of doing the low level plumbing while at the same time capable of creating high level ML libraries.

* If you already have a software stack in any language (or stacks of languages), Spiral can be easily adjusted to interop with it. In the old version, Spiral compiled to F# while seamlessly generating Cuda kernels its ML library needed. Do you want the language to interop with the Python ecosystem while producing the necessary code to run your own AI chip? That can be arranged without too much effort. Do you produce much low level repetitive code that you need to interop with high level garbage collected languages? Spiral could be configured to act as a fancy code generator as well.

I am offering to radically cut down on the costs of doing your software stack.

If you as a company have any ambition whatsoever for your chips to be used for general computation please consider Spiral. If your software team has had any positive experiences with functional languages they will love Spiral. Don't let your team grind away using C. Spiral is the competitive edge you will appreciate.

I'd like to hear what the biggest sources of friction in your software stack are. Maybe I would be able to make things smoother.

///

Google Mail found two more errors. It seems it is better than language tools.

4:35pm. Got an automated reply asking me to note down the job and attach my resume, but I will ignore that. Let me contact the other 3 companies. Graphcore is saying it gets a lot of candidates, but I can't assume they aren't saying that to flatfoot the candidates.

4:40pm. Focus me.

Fathom Computing
Lightelligence
Lightmatter

The next are these 3.

hello@fathomcomputing.com

Let me send one to Fathom.

Next is Lightelligence. I am mostly going by the alphabet here.

Lightelligence rather than direct mail, has a contact form. I'll include the link in text. Maybe I should do it like that for the other mail. Then I do not run the risk of screwing up the link when copy pasting things. Let me move it into the body. That is the way to go here.

4:50pm. Lightmatter is next. Another form. This one expects me to work at a company and have a job title. I'll just put in None in both fields.

5pm. I am done. Whether this works or not does not really matter. I have to contact somebody else as well just to get some advice.

6:30pm. Done with lunch. Let me stop for the day here.

I'll forget the applications for the time being and get started on the docs tomorrow. I'll fire a volley every week or so. Right now it is Wednesday, so that means I'll fire the next batch at that time as well. In a few weeks I will be done with this.

Putting emotion into this won't get me anywhere. I need to execute the plan like a robot and then adjust after that.

6:40pm. Maybe I will take this lul as an opportunity to further improve the language. Maybe I'll study ML during this time. I have to spend this time productively and not get lazy by too much."

---
## [Profakos/tgstation](https://github.com/Profakos/tgstation)@[160175ee8b...](https://github.com/Profakos/tgstation/commit/160175ee8b2df4a6112fb404a2ddab907ca5a54d)
#### Wednesday 2021-01-20 18:22:48 by silicons

pass_flags handling refactor + rewrites a part of projectiles for the n-th time (#54924)

Yeah uhh this'll probably need testmerging even after it's done because yeah it's a bit big.
If y'all want me to atomize this into two PRs (pass flags vs projectiles) tell me please. Pass flags would have to go in first though, in that case, as new projectile hit handling will rely on pass_flags_self.
Pass flags:

Pass flags handling now uses an atom variable named pass_flags_self.
If any of these match a pass_flag on a thing trying to pass through, it's allowed through by default.
This makes overriding CanAllowThrough unnecessary for the majority of things. I've however not removed overrides for very.. weird cases, like plastic flaps which uses a prob(60) for letting PASSGLASS things through for god knows why.
LETPASSTHROW is now on pass_flags_self
Projectiles:

Not finalized yet, need to do something to make the system I have in mind have less unneeded overhead + snowflake

Basically, for piercing/phasing/otherwise projectiles that go through things instead of hitting the first dense object, I have them use pass_flags flags for two new variables, projectile_phasing and projectile_piercing. Anything with pass_flags_self in the former gets phased through entirely. Anything in the latter gets hit, and the projectile then goes through. on_hit will also register a piercing hit vs a normal hit (so things like missiles can only explode on a normal hit or otherwise, instead of exploding multiple times. Not needed as missiles qdel(src) right now but it's nice to have for the future).

I still need to decide what to do for hit handling proper, as Bump() is still preferred due to it not being as high-overhead as something like scanning on Moved(). I'm thinking I'll make Moved() only scan for cases where it needs to hit a non-dense object - a prone human the user clicked on, anything special like that. Don't know the exact specifics yet, which is why this is still WIP.

Projectiles now use check_pierce() to determine if it goes through something and hits it, doesn't hit it, or doesn't go through something at all (should delete self after hitting). Will likely make an on_pierce proc to be called post-piercing something so you can have !fun! things like projectiles that go down in damage after piercing something. This will likely deprecate the process_hit proc, or at least make it less awful.

scan_for_hit() is now used to attempt to hit something and will return whether the projectile got deleted or not. It will delete the projectile if the projectile does hit something and fails to pierce through it.

scan_moved_turf() (WIP) will be used for handling moving onto a turf.

permutated has been renamed to impacted. Ricocheting projectiles get it reset, allowing projectiles to pierce and potentially hit something again if it goes back around.

A new unit test has been added checking for projectiles with movement type of PHASING. This is because PHASING completely causes projectiles to break down as projectiles mainly sense collisions through Bump. The small boost in performance from using PHASING instead of having all pass flags active/overriding check_pierce is in my opinion not worth the extra snowflake in scan_moved_turf() I'd have to do to deal with having to check for hits manually rather than Bump()ing things.
Movement types

UNSTOPPABLE renamed to PHASING to better describe what it is, going through and crossing everything but not actually bumping.
Why It's Good For The Game

Better pass flags handling allows for less proc overrides, bitflag checks are far less expensive in general.

Fixes penetrating projectiles like sniper penetrators

This system also allows for better handling of piercing projectiles (see above) without too much snowflake code, as you'd only need to modify on_pierce() if you needed to do special handling like dampening damage per target pierced, and otherwise you could just use the standardized system and just set pass flags to what's needed. If you really need a projectile that pierces almost everything, override check_pierce(), which is still going to be easier than what was done before (even with snowflake handling of UNSTOPPABLE flag process_hit() was extremely ugly, now we don't rely on movement types at all.)

---
## [payday-restoration/restoration-mod](https://github.com/payday-restoration/restoration-mod)@[58f355c0b4...](https://github.com/payday-restoration/restoration-mod/commit/58f355c0b4a9650b1d9165c849fbc5fde8aaab48)
#### Wednesday 2021-01-20 18:38:06 by Neslon-Poggers

Der City  federales                             :^D

- updated city federales assets  again no i will not go into detail go fuck your self
- removed fixed hat material from bex security because overkill fixed it on their end
- removed unnecessary material configs because we're doing the shared materials meme
- g herbo

---
## [Beorseder/Evolve](https://github.com/Beorseder/Evolve)@[c64c0208f8...](https://github.com/Beorseder/Evolve/commit/c64c0208f81cb03cbe665c840b08a54b5f3aa0d7)
#### Wednesday 2021-01-20 19:32:27 by Beorseder

Numerable Bug Fixes

Storage:
Puchasing a Shed now instantly updates Chrysotile and Crystal caps instead of waiting for the midloop.
Puchasing a Garage now instantly updates many resource caps instead of waiting for the midloop.
Chrysotile now shows up in the Interstellar Warehouse tooltip and cap  is immediately added upon building one.

Smoldering:
With Smoldering, building a Rock Quarry will unlock the Civics -> Industry tab, instead of having to wait to build a Smelter to change Chrysotile Ratio in Industry.
Fixed bug where Lumber was still a fuel option with Smoldering.
Lumber Rituals no longer appear with Smoldering, and any pre-existing Lumber Rituals are purged with Smoldering.
Fixed tooltip bugs with Chrysotile Ratio at 0% and 100%.
Chrysotile now show up in the Garage tooltip during Cataclysm.
Updated the Reclaimer, Axe, and Saw trees' Special Requirements to accomodate new Smoldering effects in the wiki.

Hell:
Fixed bug where having less than 1 Dark Energy in Evil universe would decrease Soul Gem drop rate.
Fixed bug where Mech Lab tab wouldn't load if accessed from Mech Bay.
Vault now has a queue max of 1.
Fixed bug where Sphinx's description would undefined most of the time in the wiki.

Wiki:
Added Extra Requirements in the wiki for CRISPR upgrades that have them.
Bone Tools now has the correct effects in the wiki with Smoldering.
Added the Dark Energy Bomb's waygate2 requirement to the wiki.
Updated Bone/Wooden Tools requirements to accomodate Demonic races in Evil universe.
Added the missing Special Requirements that Republic and Socialist have to the wiki.
Elusive now mentions how it affects Ambush chances and both Elusive and Chameleon now say the % they reduce chances of Ambush by.
Updated Stabilize Blackhole's wiki effects.

Misc:
Fixed bug where the Launch Campaign button in Civics -> Military would still show if a Foreign Power was Annexed or Purchased.
Fixed bug where Celestial evolution option would not reappear upon reloading at the fork after choosing Mammals.
Fixed bug where Demonic races could not be progressed with in Evil.
Sheet Metal is no longer displayed from researching Bayer Process, as not even Aluminum is displayed from it.
Fixed NaN power issue upon researching Oil Powerplant.
Fixed issue with Evil Wendigos regaining Reclaimer techs after getting Kindling Kindred from Fanaticism/Deify.
Updated Pig Latin.

---
## [peff/git](https://github.com/peff/git)@[a5d1186458...](https://github.com/peff/git/commit/a5d1186458edf23b0edb3771e7063cc909d11855)
#### Wednesday 2021-01-20 20:58:31 by Jeff King

refs: switch peel_ref() to peel_iterated_oid()

The peel_ref() interface is confusing and error-prone:

  - it's typically used by ref iteration callbacks that have both a
    refname and oid. But since they pass only the refname, we may load
    the ref value again. This is inefficient, but also means we are open
    to a race if somebody simultaneously updates the ref. E.g., this:

      int some_ref_cb(const char *refname, const struct object_id *oid, ...)
      {
              if (!peel_ref(refname, &peeled))
                      printf("%s peels to %s",
                             oid_to_hex(oid), oid_to_hex(&peeled);
      }

    could print nonsense. It is correct to say "refname peels to..."
    (you may see the "before" value or the "after" value), but mentioning
    both oids may be mixing before/after values.

    Worse, whether this is possible depends on whether the optimization
    to read from the current iterator value kicks in. So it is actually
    not possible with:

      for_each_ref(some_ref_cb);

    but it _is_ possible with:

      head_ref(some_ref_cb);

    which does not use the iterator mechanism (though in practice, HEAD
    should never peel to anything, so this may not be triggerable).

  - it must take a fully-qualified refname for read_ref_full() code path
    to work. Yet we routinely pass it partial refnames from callbacks to
    for_each_tag_ref(), etc. This happens to work when iterating because
    there we do not call read_ref_full() at all, and only use the passed
    refname to check if it is the same as the iterator. But the
    requirements for calling the function are quite unclear.

Instead of taking a refname, let's instead take an oid. That fixes the
race/inefficiency problem. It's a little funny for a "ref" function not
to involve refs at all. The key thing is that it's optimizing under the
hood based on having access to the ref iterator. So let's change the
name to make it clear why you'd want this function versus just
peel_object().

There are two other directions I considered but rejected:

  - we could pass the peel information into the each_ref_fn callback.
    However, we don't know if the caller actually wants it or not. For
    packed-refs, providing it is essentially free. But for loose refs,
    we actually have to peel the object, which would be wasteful in most
    cases. We could likewise pass in a flag indicating whether the
    peeled information is known, but that complicates the callers, who
    then decide whether to manually peel themselves. Plus it requires
    changing the interface of every callback, whether they care about
    peeling or not, of which there are many.

  - we could make a function to return the peeled value of the current
    iterated ref (computing it if necessary), and BUG() otherwise. I.e.:

      int peel_current_iterated_ref(struct object_id *out);

    Each of the current callers is an each_ref_fn callback, so they'd
    mostly be happy. But:

      - we use use those with helpers like head_ref(), which do not use
        the iteration code. So we'd need to handle the fallback case
        there, anyway.

      - it's possible that a caller would want to call into generic code
        that sometimes is used during iteration and sometimes not. This
        encapsulates the logic to do the fast thing when possible, and
        fallback when necessary.

The implementation switch is mostly obvious, but I want to call out a
few things in the patch:

  - the test-tool coverage for peel_ref() is now meaningless, as it all
    collapses to a single peel_object() call (arguably they were pretty
    uninteresting before; the tricky part of that function is the
    fast-path we see during iteration, but these calls didn't trigger
    that). I've just dropped it entirely, though note that some other
    tests relied on the tags we created; I've moved that creation to the
    tests where it matters.

  - we no longer need to take a ref_store parameter, since we'd never
    look up a ref now. We do still rely on a global "current iterator"
    variable which _could_ be kept per-ref-store. But in practice this
    is only useful if there are multiple recursive iterations, at which
    point the more appropriate solution is probably a stack of
    iterators. No caller used the actual ref-store parameter anyway
    (they all call the wrapper that passes the_repository).

  - the original only kicked in the optimization when the "refname"
    pointer matched (i.e., not string comparison). We do likewise with
    the "oid" parameter here, but fall back to doing an actual oideq()
    call. This in theory lets us kick in the optimization more often,
    though in practice no caller cares. It should never be wrong, though
    (peeling is a property of an object, so two refs pointing to the
    same object would peel identically).

  - the original took care not to touch the peeled out-parameter unless
    we found something to put in it. But no caller cares about this, and
    anyway, it is enforced by peel_object() itself. We shorten the code
    and avoid an extra copy by just passing the out-parameter through
    the stack.

---
## [jacklecroy/space-station-13](https://github.com/jacklecroy/space-station-13)@[c5698a21c4...](https://github.com/jacklecroy/space-station-13/commit/c5698a21c411b85a3ad40ea2bffcf1e022a17b42)
#### Wednesday 2021-01-20 21:15:16 by LemonInTheDark

Removes roundstart miasma. Yes, even the gibs that are marked as miasma producers. Fuck you. Carbons now start listening for death at init, then get the component when they die. Gibs behave just as they used to. (#55343)

---
## [google/oss-fuzz](https://github.com/google/oss-fuzz)@[621729ffd7...](https://github.com/google/oss-fuzz/commit/621729ffd7bee88680c376aa4457fe95fce5a9af)
#### Wednesday 2021-01-20 21:57:58 by jonathanmetzman

Run lint on all python files (#5024)

Run lint on all python files. Linting only changed files is incorrect.
This is because an unchanged file can have a linting error from depending on a changed file.

We should do the same for tests as well. But we will skip this for now because:
1. Some tests have weird path hacks and need to be blocklisted.
2. We currently run tests using integration tests which take pretty long (~6 minutes on my desktop, probably longer on CI).
3. Even the unittests are not that fast to run (take about 30 seconds locally, 8 from CIFuzz, ~20 from build).
For now, allow all tests to be run if specified.

Also, lint all files so that presubmit passes.
Fixes https://github.com/google/oss-fuzz/issues/3320
Disable linting of dataflow_tracer.py due to https://github.com/google/oss-fuzz/pull/5024#discussion_r561310796

---
## [sobstel/sobstel](https://github.com/sobstel/sobstel)@[91e921bc6f...](https://github.com/sobstel/sobstel/commit/91e921bc6f73338d5d0ddcb54e6f55c697e3cdf5)
#### Wednesday 2021-01-20 22:07:17 by Przemek Sobstel

Happiness cannot be traveled to, owned, earned, or worn. It is the spiritual experience of living every minute with love, grace & gratitude. - Denis Waitley

---
## [hornegg/baphomation](https://github.com/hornegg/baphomation)@[5c82b50436...](https://github.com/hornegg/baphomation/commit/5c82b5043660a5742dbe5754f45f882b444cca95)
#### Wednesday 2021-01-20 23:25:12 by hornegg

Restore brackets where there are mixed operators.  Fuck you "Prettier"!

---
## [Momonyaro/Scrapper](https://github.com/Momonyaro/Scrapper)@[f6098ba588...](https://github.com/Momonyaro/Scrapper/commit/f6098ba588cdee6d7574f372c88717cc4f0312fe)
#### Wednesday 2021-01-20 23:47:27 by Momonyaro

Added some features to the animator and polished the UI

yeah it's pretty cool, pretty rad if I do say to myself and it's actually really nice that you're reading this little commit-message and shows that you're a person with good karma! Hope you live long and don't become a dung-beetle or whatever due to a bad caste or whatever that Hindu cock-slammering bullwash is and if you're wondering I am totally not just writing whatever I come up with and the fact that you're insinuating that I put no effort into this message makes me actually hope now that you become a dung-beetle you hogwash piece of garbage.

---

# [<](2021-01-19.md) 2021-01-20 [>](2021-01-21.md)

