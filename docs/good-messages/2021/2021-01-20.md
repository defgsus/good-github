# [<](2021-01-19.md) 2021-01-20 [>](2021-01-21.md)

3,078,587 events, 1,423,695 push events, 2,251,642 commit messages, 181,085,811 characters


## [jws85/Dotfiles@5b0f09a301...](https://github.com/jws85/Dotfiles/commit/5b0f09a3013c7fdc3373cefe6d6014bb2b801593)
##### 2021-01-20 03:45:59 by J. W. Smith

Move *everything* into the i3 role

I've been unenthusiastic about my half-stow, half-ansible setup.

I contemplated yeeting ansible, but I'm already "here" with it, and
going to Plain Ol' Bash Scripts would lose a fair bit of pre-made
functionality that I'm getting now "for free."

I'm not getting much from stow that I couldn't already be getting from
moving everything inside ansible; plus I don't have to slavishly
replicate the file structure or worry about config files getting
checked in or whatever.

At some point I'm going to do this to all of my roles and get rid of
stow entirely, and by doing so move the entire playbook directory into
the project root.  Yeah Ansible's the heavyweight, anti-Unix solution
here, but honestly I don't care at this point so long as I have to do
less thinking!

---
## [mrakgr/The-Spiral-Language@42a61e4f49...](https://github.com/mrakgr/The-Spiral-Language/commit/42a61e4f499ee96cb71b43de9d7ec334ae6befa9)
##### 2021-01-20 11:07:11 by Marko GrdiniÄ‡

"10:25am. I am up. Today is the interview day. I am going to start off slowly. I'll mix things up a bit. I won't fire 20 emails to all the different companies all at once. Instead, I'll pick a top tier company like Groq or Graphcore, and 3 or so lesser ones and make that my daily target. Once I get some feedback, I'll tune my pitch for the next try. Rather than emptying my whole clip, I should fire a burst at a time.

Companies like Xanadu, Cornami, and Intel('s neurochip division) are traps, so I'll ignore them for the time being. The ideal place to be in is to have a sponsor or a few, and using hardware that will allow me to leapfrog where I was in 2018. That means, no messing with quantum computers, adaptible hardware or neurochips. I do not want to turn my successful application into a years long research project.

I had a lot of success improving my concurrency skills in 2020, and 2021 should be continuation of that. I should not try to master completely new programming models on too novel hardware, instead chips that have many cores communicating with message passing and local memory is what I should master here. This will be sustainable model.

If my plan of ensemble learning turns out to stabilize RL enough to make me confident to be able to use it in the real world, then I will be able to use it to make the kind of income salaried programmers can only dream about. 100ks per month eventually is not out of the question. This kind of position would be extremely strong too. I'd have top notch programming skills, access to the right hardware, and my fingers on the pulse of the ML community. After poker, there are all sorts of games waiting me to master them too, and that path culminates in me becoming good to tackle real life using AI.

Ensembles are good. Yes, I am picking a lower hanging fruit here. If I was really smart I'd derive some algorithm better than backprop instead of taking the easy road of buffing it. But I think that whatever algorithm will come after backprop will also benefit from ensembles. Ultimately, learning is NP Hard, and no algorithm will be the holy grail. In 2018, offense completely failed me, so I will play defense.

Somewhat ironically, my 2018 ML attempt was quite similar to the 2007-2014 trading attempt, in that the benefits I got from it were not at all what I aimed for.

10:40am. For ensembles, I do in fact need better hardware. GPUs would just choke on them. Local memory is a must.

So I must start applying. I am not sure if Graphcore's chips are commercial yet, or if they will soon be...Amazon search turns out nothing, but even if they were I could not afford them at the moment.

10:45am. Now...

11:10pm. https://news.ycombinator.com/item?id=25821340
The Spiral Language v2

I noticed this thread yesterday, but ignored it.

> What does inlining have to do with heap allocation? I would have thought the opposite of heap allocation was "stack allocation"? In particular, I would expect that inlining would produce no effect on the number or size of heap allocations?

///

If you have a function, there is a certain equivalence (in terms of compilation) where you can either allocate it as a closure at runtime or emulate the effect of that by just tracking it fully at compile time and inlining it a the site of use. If you do the later, you can avoid having to do a heap allocation that having a runtime closure would require.

I said it is an equivalence in terms of compilation because, whether it is allocated as a closure on the heap, or tracked at compile time has no bearing on the correctness of the program. It only affect its memory allocation and performance profile.

If you are a C programmer, or working at a similar level of abstraction, this concern over heap allocations might seem academic, but to a functional programmer such as myself there is a lot of importance because we use function composition for all of our abstractions and don't want them to heap allocate as closures. The more abstract the code we are writing is, the more inlining matters.

The way I am describing this is confusing because inlining is not an event that happens. Rather inlining is the default. Tracking functions at compile time is the default. Heap allocation of them and their conversion into closures is an event, after which the compiler stops tracking variables of a function on an individual basis and keeps track of them at a lower resolution.

> I would have thought the opposite of heap allocation was "stack allocation"?

The way I think about this is not in terms of where the variables are allocated, but by how they are tracked. Compile-time functions track their variables individually, and heap allocating them is a simple operation that can be done at any time assuming the partial evaluator knows what its type is.

///

Should I reply with this. I feel that this will confuse the guy. Let me try something else for that later part.

///

If you have a function, there is a certain equivalence (in terms of compilation) where you can either allocate it as a closure at runtime or emulate the effect of that by just tracking it fully at compile time and inlining it a the site of use. If you do the later, you can avoid having to do a heap allocation that having a runtime closure would require.

I said it is an equivalence in terms of compilation because, whether it is allocated as a closure on the heap, or tracked at compile time has no bearing on the correctness of the program. It only affect its memory allocation and performance profile.

If you are a C programmer, or working at a similar level of abstraction, this concern over heap allocations might seem academic, but to a functional programmer such as myself there is a lot of importance because we use function composition for all of our abstractions and don't want them to heap allocate as closures. The more abstract the code we are writing is, the more inlining matters.

The way I am describing this is confusing because inlining is not an event that happens. Rather inlining is the default. Tracking functions at compile time is the default. Heap allocation of them and their conversion into closures is an event, after which the compiler stops tracking variables of a function on an individual basis and keeps track of them at a lower resolution.

> I would have thought the opposite of heap allocation was "stack allocation"?

      | Stack | Heap
------|-------------
Full  |   x   |
Box   |       |  x

To get a full picture of how Spiral's partial evaluator sees functions and recursive unions, it consider the table above. Spiral is designed so that it is very easy to go between the fully known and boxed. You don't actually control heap and stack allocations explicitly, but instead shift the perspective of the partial evaluator through the dyn patterns and control flow.

It just so happens that a very natural way of generating code for fully known functions is to leave their variables as they are on the stack. If the function needs to be tracked at runtime, then those variables are used to make a closure. The natural way of compiling things that are fully known (functions, unboxed unions) is to put them the stack. While things that are boxed (closures, boxed recursive unions) are on the heap.

This is just on the F# backend. If I were compiling to LLVM for example, I would not use a stack, but the infinite amount of virtual registers instead. And non-recursive union types are compiled as structs, meaning they should be on the stack even in boxed mode.

This view of memory is more complicated than the usual heap vs stack allocation one, because I am playing a game here where I attach a bunch of other concepts to it, but it is very useful and simplifies actual programming.

///

Let me go with this.

Ugh, the table came out so horrible.

https://pastebin.com/G5vBt0cC

12:05pm. Let me read the Mahoako thread and watch Snk

Today is a day for taking it easy it seems. It has been a while since I wrote a longish post online."

---
## [Batman27801/Ashanti@8722acb717...](https://github.com/Batman27801/Ashanti/commit/8722acb7173178581aef9c135b814da1489919ce)
##### 2021-01-20 13:53:09 by Batman27801

added some shit this truly is it boys

It has been a pleasure to lead you fine gentlemen into data structures glory. God knows that i have given it my all.

---
## [LDR-Siren/EmilyC-SamanthaPrater-EruzaArto@f22d1e9a7c...](https://github.com/LDR-Siren/EmilyC-SamanthaPrater-EruzaArto/commit/f22d1e9a7c88f6cb731264a5c52eb967bfa79d8e)
##### 2021-01-20 14:04:04 by LDR

Add files via upload

Oh last night was hilarious! So she got a hold of this lovely repo. And the first thing she attacks is the Aliases. Oh I about died on that. Because she obviously does not know what Alias means: Thank you Webster for this.

"An alias name or AKA (also known as) is any name that has been used by the candidate in the past. Life events such as marriage and divorce result in many candidates with records associated with more than one name. It is possible that criminal records could exist under any prior name." 

In other words, that list is a known list of all her Aliases or AKA's. So while she scribbled all over it(btw breaking the copyright I have on this repo, its on the front page), she proved that we were right on all those names. Sucks to be here.

And in the midst of all this, she goes off on me and this repository. To clarify something. This repository was originally created as a means to see all the harassment coming from her via Notecards, and FLICKR messages, and anything else she wanted to throw at me, so I could see for myself that I was not imagining anything. It has turned into a place to dump all the crap she spews for when we finally need it. But I am not the only one who has started a repository. Squirrel(lovely sarcastic brilliant Squirrel) has done the same.  Its not paranoia or I need a hobby.

I do this for 10 minutes out of every morning. Thats it. The information that often gets thrown in here now, comes from screen grabbers in my discord. There are a lot of us that contribute. So when I say this is a work of love, I just organize things into neat little folders, those girls and guys that hate her guts, do all the work. I have a job, a family, and hobbies, like finding patterns right now for kilts for my husband and son.

Lets touch on that too. She likes to focus on 1 child. My daughter. I have 2. My daughter right now is in that teenage state of only wanting mom when she needs an opinion about her drawing, nibbles, or cuddles(she acts like a cat and I am not against this). My Son, is still a little sprout. And he takes up a lot more time than my daughter does. Not because I favor him more, she doesn't need me right now as much as he does, and she will tell me when she needs me. So while I find it funny Emily only focuses on my daughter, I have 2 children. 

Speaking of my daughter, and this has come up in the past, many of us feel it is because Cheshire is Autistic, that Emily focuses so hard on her and not my son(who has a learning disability as well). She tries to associate herself with Cheshire not realizing, Cheshire and her are NOTHING alike and using Cheshire as a means to get me on her(Emily's) side only does the opposite.  Cheshire is a beautiful, loving, empathetic teenager with immense amount of raw artistic talent that we have been helping focus her with for ages. She is smarter than Emily will ever be, kinder, doesn't bully people, not even her brother, and knows how to treat people. She understands the words no, and leave me alone, stop, and not right now. She does not push anything on anyone, but will make a pretty decent argument when she has to. She doesn't need to spam me or her father to get something she wants, she simply asks the right way the First TIme! Unlike Emily who is a complete Nightmare of a person.

IQ! HOLY HELLS I woke up to this and damn near laughed my ass off. So she tried to say that her chromosomes can not lead to her having a low IQ. Lets clarify this, I am bringing in the words of the wise person I know who knows all about this.

"She has a microdeletion of a small portion of a chromosome. I also already explained that to her long ago when she was whining in a voice chat about being missing chromosomes and I explained exactly what 22Q is and what tiny fraction of a chromosome is damaged. If she was missing an entire chromosome, much less several like she says, she wouldn't have been born alive. And IQ isn't compared to chromosomal count at all. Maybe because of the Q in 22q so...her usual being a moron and not able to read properly." (This conversation can be found above in today's commit)

She has also gone off recently, about having her IQ tested by her doctors when she was a kid, hence, they took into consideration her mental incapability's at the time of the test. Unless she did one online, then the odds were already stacked against her. And its been stated by several renowned websites and professionals, that IQ deteriorates over age.  So her age has likely lowered that number as well further. The damn thing about this is, its not her IQ that we base a lot of our Idiot comments off of, frankly its her actions. 

And the last 4 images is indicator she is in the apology phase again. I think this is 3 times in the past 2 weeks. Honestly we have in the Dibney Cru simply laughed it off. Its not sincere she doesn't mean it, and we have heard it and seen it so many times, its just words.  Now if she actually stopped her drama mongering, shut up about everyone and I mean everyone, this whole thing would have died ages ago. But she simply can not. Again that leads back to the Narcissism that is prevalent in her actions. And her own words for that matter. She needs this attention.

Oh a quick things: We found her tiktok thanks to her blasting that when she doodled on the aliases page, if I am not mistaken, most of us on TikTok now have her blocked. I know I do. 

Have a good day folks!

---
## [mrakgr/The-Spiral-Language@c1f506fddc...](https://github.com/mrakgr/The-Spiral-Language/commit/c1f506fddc05f4072e65c532ed62312d48a63248)
##### 2021-01-20 17:43:36 by Marko GrdiniÄ‡

"1:25pm. Ex-Arm and then I'll do the chores. After that I'll get composing.

I am going to have to do some things while I wait for the replies. The first thing I should do is fill out the core library docs. I should put in the comments for every top level function.

I am not sure what to do apart from that, maybe I'll take a look a look at the docs for some of these devices and see if they have an emulator.

Whatever I do, I should not see this period as an oppotunity to do nothing.

Today I've been feeling a bit nervous and relaxed myself. Once it is time to resume I should pick up the tension.

A smallish vacation every once in a while is not bad.

2:10pm. Enough fooling around. Let me do the chores here. After that comes composing the mails. After that I'll get started on documenting the library functions. There isn't that much to document at the moment actually. I'll have it easy. But getting to this point is what I've been hard at work. So this situation I am in right now is my reward. A slight lul in the frenzy is what I've earned.

2:45pm. Done with chores. Let me start.

First let me pick 4 targets.

Graphcore
Fathom Computing
Lightelligence
Lightmatter

The last 3 are in the dev stage. Graphcore is fairly mature in constrast. Graphcore is my biggest hope here, but I need a few more experimental picks just to get a sense where the companies are. The last 3 might be duds today, but eventually they will be in the sampling stage. I might be able to make a deal with them at that time.

The subject of the mail should be: "Seeking a sponsor for the Spiral programming language". Even though I am seeking multiple sponsors, I should put "a sponsor" rather than "sponsors" here. Alternative I could put in "sponsorship".

It is really interesting how many photonic companies there are in this field. I am looking at it now, and it seems Fathom does that too.

3pm. Now I need to do the body here. Focus me. This is not a one-to-one conversation, so I can afford to use my brain and think my sentences through to achieve maximum diplomacy.

Focus me. The body:

///

For the past year I've been working on a new version of the [Spiral programming language](https://github.com/mrakgr/The-Spiral-Language). It is ready to be put to use in the real world and I'd like a chance to demonstrate its capabilities. For that I'd like to receive access to your hardware and a monthly stipend.

The selling points are as follows:

* Do you know about Nvidia's Cuda? Nvidia is quite proud of it, but ultimately the C++ language which it is based on is hard to use and learn. Furthermore, C++ compilers are very hard to make. You'd as a company would need to make large investments of both time and money to make this sort of language support viable.

* Spiral is small, quick and well-designed functional language. It can be used as a much better replacement for C++. It can be used a replacement for lower level languages like C. If the only thing you have is Assembly then you could Spiral would allow you to skip making a C compiler and use it directly. By adopting it, you would have a tool capable of doing the low level plumbing while at the same time capable of creating high level ML libraries.

* If you already have a software stack in any language (or stacks of languages), Spiral can be easily adjusted to interop with it. In the old version, Spiral compiled to F# while seamlessly generating Cuda kernels its ML library needed. Do you want the language to interop with the Python ecosystem while producing the necessary code to run your own AI chip. That can be arranged without too much effort. Do you produce much low level repetitive code that you need to interop with high level garbage collected languages? Spiral could be configured to act as a fancy code generator as well.

I am offering to radically cut down on the costs of doing your software stack.

If you as a company have any ambition whatsoever for your chips to be used for general computation please consider Spiral. If your software team has had any positive experiences with functional languages they will love Spiral. Don't let your team grind away using C. Spiral is the competitive edge you will appreciate.

I'd like to hear what the biggest sources of friction in your software stack are. Maybe I would be able to make things smoother.

///

4pm. I am not selling myself, but Spiral instead so I do not need to plug my own personal data or resume here. This is the chad way of life. If the other side wants that info I can go into it.

> I am offering to radically cut down on the costs of doing your software stack.

I am being 100% truthful on this as strange as it is. There is a lot of benefit to be had from using Spiral for others.

Let me put this through the language tool. I had one typo it seems. Ok.

4:15pm. I am thinking. I've cranked up my brain and the above came out. This is the clearest way that I can think of getting my point across. I could into great depth here, but I doubt the guys on the other side want to read a novel in my application. Simple is best here.

4:20pm. Instead of hesitating, let me just fire off the emails here. If this fails, I'll get feedback and make a more appropriate email next time.

First off, let me try Graphcore.

https://www.graphcore.ai/jobs

It seems they are mostly looking for C++ engineers. I need to dig up an email.

> For careers visit our Careers page or email us at:
careers@graphcore.ai

I think this is the email that I need.

4:30pm. I am thinking whether I should adjust the email to more reflect Graphcore's reality. They are using C++, so I can change things a bit...

But if Graphcore is determined to hire as many C++ engineers as it can, then I am not going to be able to make to make headway either way. The fact that Spiral can do high and the low level equally well is a part of its pitch. Let me go with what I have. There is no point in hesitating here.

///

Subject: Seeking a sponsor for the Spiral programming language

---

Link: https://github.com/mrakgr/The-Spiral-Language

For the past year I've been working on a new version of the Spiral programming language. It is ready to be put to use in the real world and I'd like a chance to demonstrate its capabilities. For that I'd like to receive access to your hardware and a monthly stipend.

The selling points are as follows:

* Do you know about Nvidia's Cuda? Nvidia is quite proud of it, but ultimately the C++ language which it is based on is hard to use and learn. Furthermore, C++ compilers are very hard to make. You'd as a company would need to make large investments of both time and money to make this sort of language support viable.

* Spiral is small, quick and well-designed functional language. It can be used as a much better replacement for C++. It can be used as a replacement for lower level languages like C. If the only thing you have is Assembly then you could Spiral would allow you to skip making a C compiler and use it directly. By adopting it, you would have a tool capable of doing the low level plumbing while at the same time capable of creating high level ML libraries.

* If you already have a software stack in any language (or stacks of languages), Spiral can be easily adjusted to interop with it. In the old version, Spiral compiled to F# while seamlessly generating Cuda kernels its ML library needed. Do you want the language to interop with the Python ecosystem while producing the necessary code to run your own AI chip? That can be arranged without too much effort. Do you produce much low level repetitive code that you need to interop with high level garbage collected languages? Spiral could be configured to act as a fancy code generator as well.

I am offering to radically cut down on the costs of doing your software stack.

If you as a company have any ambition whatsoever for your chips to be used for general computation please consider Spiral. If your software team has had any positive experiences with functional languages they will love Spiral. Don't let your team grind away using C. Spiral is the competitive edge you will appreciate.

I'd like to hear what the biggest sources of friction in your software stack are. Maybe I would be able to make things smoother.

///

Google Mail found two more errors. It seems it is better than language tools.

4:35pm. Got an automated reply asking me to note down the job and attach my resume, but I will ignore that. Let me contact the other 3 companies. Graphcore is saying it gets a lot of candidates, but I can't assume they aren't saying that to flatfoot the candidates.

4:40pm. Focus me.

Fathom Computing
Lightelligence
Lightmatter

The next are these 3.

hello@fathomcomputing.com

Let me send one to Fathom.

Next is Lightelligence. I am mostly going by the alphabet here.

Lightelligence rather than direct mail, has a contact form. I'll include the link in text. Maybe I should do it like that for the other mail. Then I do not run the risk of screwing up the link when copy pasting things. Let me move it into the body. That is the way to go here.

4:50pm. Lightmatter is next. Another form. This one expects me to work at a company and have a job title. I'll just put in None in both fields.

5pm. I am done. Whether this works or not does not really matter. I have to contact somebody else as well just to get some advice.

6:30pm. Done with lunch. Let me stop for the day here.

I'll forget the applications for the time being and get started on the docs tomorrow. I'll fire a volley every week or so. Right now it is Wednesday, so that means I'll fire the next batch at that time as well. In a few weeks I will be done with this.

Putting emotion into this won't get me anywhere. I need to execute the plan like a robot and then adjust after that.

6:40pm. Maybe I will take this lul as an opportunity to further improve the language. Maybe I'll study ML during this time. I have to spend this time productively and not get lazy by too much."

---
## [Profakos/tgstation@160175ee8b...](https://github.com/Profakos/tgstation/commit/160175ee8b2df4a6112fb404a2ddab907ca5a54d)
##### 2021-01-20 18:22:48 by silicons

pass_flags handling refactor + rewrites a part of projectiles for the n-th time (#54924)

Yeah uhh this'll probably need testmerging even after it's done because yeah it's a bit big.
If y'all want me to atomize this into two PRs (pass flags vs projectiles) tell me please. Pass flags would have to go in first though, in that case, as new projectile hit handling will rely on pass_flags_self.
Pass flags:

Pass flags handling now uses an atom variable named pass_flags_self.
If any of these match a pass_flag on a thing trying to pass through, it's allowed through by default.
This makes overriding CanAllowThrough unnecessary for the majority of things. I've however not removed overrides for very.. weird cases, like plastic flaps which uses a prob(60) for letting PASSGLASS things through for god knows why.
LETPASSTHROW is now on pass_flags_self
Projectiles:

Not finalized yet, need to do something to make the system I have in mind have less unneeded overhead + snowflake

Basically, for piercing/phasing/otherwise projectiles that go through things instead of hitting the first dense object, I have them use pass_flags flags for two new variables, projectile_phasing and projectile_piercing. Anything with pass_flags_self in the former gets phased through entirely. Anything in the latter gets hit, and the projectile then goes through. on_hit will also register a piercing hit vs a normal hit (so things like missiles can only explode on a normal hit or otherwise, instead of exploding multiple times. Not needed as missiles qdel(src) right now but it's nice to have for the future).

I still need to decide what to do for hit handling proper, as Bump() is still preferred due to it not being as high-overhead as something like scanning on Moved(). I'm thinking I'll make Moved() only scan for cases where it needs to hit a non-dense object - a prone human the user clicked on, anything special like that. Don't know the exact specifics yet, which is why this is still WIP.

Projectiles now use check_pierce() to determine if it goes through something and hits it, doesn't hit it, or doesn't go through something at all (should delete self after hitting). Will likely make an on_pierce proc to be called post-piercing something so you can have !fun! things like projectiles that go down in damage after piercing something. This will likely deprecate the process_hit proc, or at least make it less awful.

scan_for_hit() is now used to attempt to hit something and will return whether the projectile got deleted or not. It will delete the projectile if the projectile does hit something and fails to pierce through it.

scan_moved_turf() (WIP) will be used for handling moving onto a turf.

permutated has been renamed to impacted. Ricocheting projectiles get it reset, allowing projectiles to pierce and potentially hit something again if it goes back around.

A new unit test has been added checking for projectiles with movement type of PHASING. This is because PHASING completely causes projectiles to break down as projectiles mainly sense collisions through Bump. The small boost in performance from using PHASING instead of having all pass flags active/overriding check_pierce is in my opinion not worth the extra snowflake in scan_moved_turf() I'd have to do to deal with having to check for hits manually rather than Bump()ing things.
Movement types

UNSTOPPABLE renamed to PHASING to better describe what it is, going through and crossing everything but not actually bumping.
Why It's Good For The Game

Better pass flags handling allows for less proc overrides, bitflag checks are far less expensive in general.

Fixes penetrating projectiles like sniper penetrators

This system also allows for better handling of piercing projectiles (see above) without too much snowflake code, as you'd only need to modify on_pierce() if you needed to do special handling like dampening damage per target pierced, and otherwise you could just use the standardized system and just set pass flags to what's needed. If you really need a projectile that pierces almost everything, override check_pierce(), which is still going to be easier than what was done before (even with snowflake handling of UNSTOPPABLE flag process_hit() was extremely ugly, now we don't rely on movement types at all.)

---
## [grapl-security/grapl@6137fd7042...](https://github.com/grapl-security/grapl/commit/6137fd704231e48a4f29229018c140658f8ad181)
##### 2021-01-20 23:40:41 by wimax-grapl

Begin to migrate python S3/SQS clients to a FromEnv equivalent (#541)

* On the road to Rust-like Fargate Stuff

yeah sure whatever

Fixed up typechecks

blep blep

It should work, but it doesn't.

I think it should work potentially

It fucking succeeded asdfgh

Yes yes it works yes

e2e works

sysmon works

okay time to rip out more garbage

it work

* readd removed logging driver none thing

* woops two tabs

* Remove the thing that caused pytype failure

* Lock test requirements

* change some prints to logger calls

---
## [Momonyaro/Scrapper@f6098ba588...](https://github.com/Momonyaro/Scrapper/commit/f6098ba588cdee6d7574f372c88717cc4f0312fe)
##### 2021-01-20 23:47:27 by Momonyaro

Added some features to the animator and polished the UI

yeah it's pretty cool, pretty rad if I do say to myself and it's actually really nice that you're reading this little commit-message and shows that you're a person with good karma! Hope you live long and don't become a dung-beetle or whatever due to a bad caste or whatever that Hindu cock-slammering bullwash is and if you're wondering I am totally not just writing whatever I come up with and the fact that you're insinuating that I put no effort into this message makes me actually hope now that you become a dung-beetle you hogwash piece of garbage.

---

# [<](2021-01-19.md) 2021-01-20 [>](2021-01-21.md)

