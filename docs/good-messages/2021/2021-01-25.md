# [<](2021-01-24.md) 2021-01-25 [>](2021-01-26.md)

2,957,026 events, 1,433,614 push events, 2,288,761 commit messages, 183,144,021 characters


## [sileshn/android_kernel_samsung_msm8930-common@8a3ed31a69...](https://github.com/sileshn/android_kernel_samsung_msm8930-common/commit/8a3ed31a69665d81bc9a9e84d28bcede76eb7f70)
##### 2021-01-25 00:59:12 by KOSAKI Motohiro

mqueue: don't use kmalloc with KMALLOC_MAX_SIZE

KMALLOC_MAX_SIZE is not a good threshold.  It is extremely high and
problematic.  Unfortunately, some silly drivers depend on this and we
can't change it.  But any new code needn't use such extreme ugly high
order allocations.  It brings us awful fragmentation issues and system
slowdown.

Signed-off-by: KOSAKI Motohiro <mkosaki@jp.fujitsu.com>
Acked-by: Doug Ledford <dledford@redhat.com>
Acked-by: Joe Korty <joe.korty@ccur.com>
Cc: Amerigo Wang <amwang@redhat.com>
Cc: Serge E. Hallyn <serue@us.ibm.com>
Cc: Jiri Slaby <jslaby@suse.cz>
Cc: Joe Korty <joe.korty@ccur.com>
Cc: Manfred Spraul <manfred@colorfullife.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

---
## [STRIX-Project/STRIX_kernel_xiaomi-sdm660@8f6be9938b...](https://github.com/STRIX-Project/STRIX_kernel_xiaomi-sdm660/commit/8f6be9938baf76a2d55b59709f0453cd29ca1220)
##### 2021-01-25 06:53:40 by George Spelvin

lib/sort: make swap functions more generic

Patch series "lib/sort & lib/list_sort: faster and smaller", v2.

Because CONFIG_RETPOLINE has made indirect calls much more expensive, I
thought I'd try to reduce the number made by the library sort functions.

The first three patches apply to lib/sort.c.

Patch #1 is a simple optimization.  The built-in swap has special cases
for aligned 4- and 8-byte objects.  But those are almost never used;
most calls to sort() work on larger structures, which fall back to the
byte-at-a-time loop.  This generalizes them to aligned *multiples* of 4
and 8 bytes.  (If nothing else, it saves an awful lot of energy by not
thrashing the store buffers as much.)

Patch #2 grabs a juicy piece of low-hanging fruit.  I agree that nice
simple solid heapsort is preferable to more complex algorithms (sorry,
Andrey), but it's possible to implement heapsort with far fewer
comparisons (50% asymptotically, 25-40% reduction for realistic sizes)
than the way it's been done up to now.  And with some care, the code
ends up smaller, as well.  This is the "big win" patch.

Patch #3 adds the same sort of indirect call bypass that has been added
to the net code of late.  The great majority of the callers use the
builtin swap functions, so replace the indirect call to sort_func with a
(highly preditable) series of if() statements.  Rather surprisingly,
this decreased code size, as the swap functions were inlined and their
prologue & epilogue code eliminated.

lib/list_sort.c is a bit trickier, as merge sort is already close to
optimal, and we don't want to introduce triumphs of theory over
practicality like the Ford-Johnson merge-insertion sort.

Patch #4, without changing the algorithm, chops 32% off the code size
and removes the part[MAX_LIST_LENGTH+1] pointer array (and the
corresponding upper limit on efficiently sortable input size).

Patch #5 improves the algorithm.  The previous code is already optimal
for power-of-two (or slightly smaller) size inputs, but when the input
size is just over a power of 2, there's a very unbalanced final merge.

There are, in the literature, several algorithms which solve this, but
they all depend on the "breadth-first" merge order which was replaced by
commit 835cc0c8477f with a more cache-friendly "depth-first" order.
Some hard thinking came up with a depth-first algorithm which defers
merges as little as possible while avoiding bad merges.  This saves
0.2*n compares, averaged over all sizes.

The code size increase is minimal (64 bytes on x86-64, reducing the net
savings to 26%), but the comments expanded significantly to document the
clever algorithm.

TESTING NOTES: I have some ugly user-space benchmarking code which I
used for testing before moving this code into the kernel.  Shout if you
want a copy.

I'm running this code right now, with CONFIG_TEST_SORT and
CONFIG_TEST_LIST_SORT, but I confess I haven't rebooted since the last
round of minor edits to quell checkpatch.  I figure there will be at
least one round of comments and final testing.

This patch (of 5):

Rather than having special-case swap functions for 4- and 8-byte
objects, special-case aligned multiples of 4 or 8 bytes.  This speeds up
most users of sort() by avoiding fallback to the byte copy loop.

Despite what ca96ab859ab4 ("lib/sort: Add 64 bit swap function") claims,
very few users of sort() sort pointers (or pointer-sized objects); most
sort structures containing at least two words.  (E.g.
drivers/acpi/fan.c:acpi_fan_get_fps() sorts an array of 40-byte struct
acpi_fan_fps.)

The functions also got renamed to reflect the fact that they support
multiple words.  In the great tradition of bikeshedding, the names were
by far the most contentious issue during review of this patch series.

x86-64 code size 872 -> 886 bytes (+14)

With feedback from Andy Shevchenko, Rasmus Villemoes and Geert
Uytterhoeven.

Link: http://lkml.kernel.org/r/f24f932df3a7fa1973c1084154f1cea596bcf341.1552704200.git.lkml@sdf.org
Signed-off-by: George Spelvin <lkml@sdf.org>
Acked-by: Andrey Abramov <st5pub@yandex.ru>
Acked-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Reviewed-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Cc: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Cc: Geert Uytterhoeven <geert@linux-m68k.org>
Cc: Daniel Wagner <daniel.wagner@siemens.com>
Cc: Don Mullis <don.mullis@gmail.com>
Cc: Dave Chinner <dchinner@redhat.com>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Dede Dindin Qudsy <xtrymind@gmail.com>

---
## [trueroad/lilypond@1e667555cf...](https://github.com/trueroad/lilypond/commit/1e667555cf8bbbfffee34c91d2b133d064c453ec)
##### 2021-01-25 10:39:08 by Jean Abou Samra

CG: Revise Git documentation

This completely reshapes CG section 3, "Working with source code".

- Remove obsolete and duplicate parts. This includes how to deal with
  git-formatted patches, for example (since our new workflow doesn't
  use them).
- Reorganise the rest entirely. Make it simpler and more straightforward.
  Also remove unnecessary technical details (these belong to external
  documentation).
- Drop the bit of instructions for using git-gui on Windows. A terminal
  was needed anyway. Instead, link to a list of Git GUIs on the official
  Git website. This is more likely to make new contributors happy since
  it seems those GUIs are more complete, elaborate and user-friendly.

The new structure is:
* Setting up
* Git cheat sheet
* Lifecycle of a Merge Request
* Common Git procedures
* Commit acces
* Further Git documentation resources
* Repository directory structure
* Other repositories

---
## [ilammy/product-docs@f967ba8407...](https://github.com/ilammy/product-docs/commit/f967ba84074f9d9f434b2aa3c6d947430ef53669)
##### 2021-01-25 10:51:04 by Alexei Lozovsky

Reference implementation of Soter container

Okay, here's my stupid idea. In addition to specs with prose, provide
users with a reference implementation of whatever is described. Some
people are better at understanding concepts through code. Plus, this
provides an "executable specification" and tests. I have found this
invaluable when writing Secure Cell spec: that caught quite a few
mistakes and misconceptions that I had about its implementation.

(History-savvy people here could have found parallels between this and
the concept of "literate programming". Indeed, if only Knuth's ideas
caught up, this would have been a perfect opportunity for that approach.
Unfortunately, it's not really popular to have good tooling.)

The reference implementation is written in Go. Aside from an obvious
reasons having to do with Cossack Labs being a Go shop, this choice has
a number of other benefits:

  - very good standard library, with a lot of cryptographic primitives
    available which will come very handy later

  - readable to most programmers who are familiar with C syntax

  - almost immediately executable if you copy-paste the sample code,
    thanks to "push to GitHub to publish a package" approach

  - reference implementation can actually reuse its own code for
    different cryptosystems

Unfortunately, you can't run this on Go Playground without much hassle,
but that would have been amazing.

Now, note that "reference implementation" is different from the
"official GoThemis source code". The overriding objective here is to
illustrate key points in Themis algorithms. Readability and correctness
are the main focus of the reference implementation. Performance,
usability, good error reporting, feature completeness -- all of this can
be sacrificed for the sake of brevity and clarity of the code.

Themis Core's C code is anything but easy to understand cryptography.
Since even its maintainers make mistakes when deciphering code paths
leading to arcane OpenSSL invocations, any cryptography audit would be
pretty expensive for it. Hopefully, this reference implementation can
serve as a better way to understand the cryptography behind Themis.

Now... Here's an implementation of Soter container for starters.

---
## [pxseu/powercord-weather@ef4520d8a4...](https://github.com/pxseu/powercord-weather/commit/ef4520d8a4f2c18b2b9edc1f5971a0871c0509da)
##### 2021-01-25 11:28:50 by pxseu

ðŸ“‹README changed a bit

im really angry. i read somewhere in a psychology article that people dont approach really attractive people because they are too intimidated. but wtf no girls are even approaching me, it's not my fault that my biceps are so large. this is becoming really problematic to me. didnt really look for a gf, because i'm above that but like nothings happening and im frustrated (no advice needed, i dont think i can change my face to become less attractive) ONE OF THEM EVEN SAID IM UGLY. MANIPULATIVE BITCH IS JUST TRYING TO LOWER MY SELF ESTEEM SO I GET WITH HER. FUCK, WOMEN CAN BE MANIPULATIVE SOMETIMES.

---
## [mrakgr/The-Spiral-Language@2f15792aa1...](https://github.com/mrakgr/The-Spiral-Language/commit/2f15792aa1baa609779a4c99d5f390b8b0b4d47a)
##### 2021-01-25 19:37:27 by Marko GrdiniÄ‡

"2pm. Done with breakfast and chores, but I was so busy yesterday I did not even do my morning reading. Let me just fire that bank email and I'll take a proper break.

2:15pm. Time for a break.

3:15pm. Time to resume.

Focus me.

```
(base) PS C:\Users\Marko\Source\Repos\The Spiral Language\VS Code Plugin> cythonize
Usage: cythonize [options] [sources and packages]+

cythonize: error: no source files provided
```

I saw this in an Nvidia article yesterday.

https://developer.nvidia.com/blog/accelerating-python-on-gpus-with-nvc-and-cython/

`cythonize -i cppsort.pyx`

Instead of doing that `setup.py` I could have just used this.

```
cdef int range(int fron, int nearTo):
    cdef int loop(int s, int i):
        if i < nearTo: return loop(s+i,i+1)
        else: return s
    loop(0,fron)

range(0,100000)
```

It is telling me that the nested function is not allowed there.

```
(base) PS C:\Users\Marko\Source\Repos\The Spiral Language\Spiral Compilation Tests\cython_experiments\test2> python tail_rec.cp38-win_amd64.pyd
  File "tail_rec.cp38-win_amd64.pyd", line 1
SyntaxError: Non-UTF-8 code starting with '\x90' in file tail_rec.cp38-win_amd64.pyd on line 1, but no encoding declared; see http://python.org/dev/peps/pep-0263/ for details
```

How annoying.

3:35pm.

```fs
cdef int loop(int s, int i, int nearTo):
    if i < nearTo: return loop(s+i,i+1,nearTo)
    else: return s
cpdef int sequence(int fron, int nearTo):
    return loop(0,fron,nearTo)
```

Yes, this does get TCO'd.

```fs
cdef int loop(int s, int i, int nearTo):
    if i < nearTo: return loop(s+i,i+1,nearTo)
    else: return s
cpdef int sequence_tailrec(int fron, int nearTo):
    return loop(0,fron,nearTo)

cdef int loop(int i, int nearTo):
    if i < nearTo: return i + loop(i+1,nearTo)
    else: return s
cpdef int sequence(int fron, int nearTo):
    return loop(0,fron,nearTo)
```

Let me try this. Though for all I know the C compiler might be good enough to transform this as well.

Yeah, it is.

What if I just do a def?

Actually, no I fucked up the above.

```
cdef int loop(int i, int nearTo):
    if i < nearTo: return i + loop(i+1,nearTo)
    else: return 0
```

Let me do it like this.

```
import tail_rec
print(tail_rec.sequence(0,2_000_000_000))
```

Ah, wait, nothing is getting printed when I do this.

```
print(tail_rec.sequence(0,2_000_0))
```

If I add another zero to the end, it stack overflows silently in the background.

```
import tail_rec
print(tail_rec.sequence_tailrec(0,2_000_000_000))
```

The tail recursive version works just fine. Ok.

Let me do that automatic Cython import. It was in the docs.

> Use Pyximport, importing Cython .pyx files as if they were .py files (using setuptools to compile and build in the background). This method is easier than writing a setup.py, but is not very flexible. So youâ€™ll need to write a setup.py if, for example, you need certain compilations options.

3:50pm.

```
import pyximport
pyximport.install()
import tail_rec
print(tail_rec.sequence_tailrec(0,2_000_000_000))
```

This works, but it does not produce a residual that I could use. Because of that, `import tail_rec` is an import error in the editor.

Ok...

What happens if I try passing a string into the Cython function that expects an int?

```
(base) PS C:\Users\Marko\Source\Repos\The Spiral Language\Spiral Compilation Tests\cython_experiments\test2> python run.py
Traceback (most recent call last):
  File "run.py", line 4, in <module>
    print(tail_rec.sequence_tailrec(0,"2_000_000_000"))
  File "tail_rec.pyx", line 4, in tail_rec.sequence_tailrec
    cpdef int sequence_tailrec(int fron, int nearTo):
TypeError: an integer is required
```

Not bad. Ok.

```
import pyximport
pyximport.install(language_level=3)
import tailrec
# print(tail_rec.sequence(0,2_000_000_000)) # Diverges
print(tailrec.sequence_tailrec(0,2_000_000_000))
```

Figured out how to set the language level as well.

Ok...

4:05pm. I am thinking.

At this point there is nothing really stoping me from starting work on the backend. If I start now, it won't take long at all.

Yes...

Before I start let me just figure out what the type of python objects is.

https://cython.readthedocs.io/en/latest/src/userguide/language_basics.html

Also before I start making a compiler backend, I should at least study the basics of the language I am targetting.

https://cython.readthedocs.io/en/latest/src/userguide/language_basics.html#c-variable-and-type-definitions

Oh, it has C unions!

This will make it a lot easier to implement union types.

>  Arrays use the normal C array syntax, e.g. int[10], and the size must be known at compile time for stack allocated arrays. Cython doesnâ€™t support variable length arrays from C99.

Interesting. I wonder why this is so?

But I won't by using C arrays, but Python ones instead as the default.

> declares a parameter called int which is a Python object. You can also use object as the explicit return type of a function, e.g.:

Ah, I see.

```
cpdef object test_obj((object,object) x):
    a,b = x
    return a + b

cpdef object qwe(object a, object b):
    cdef (object, object) x = a,b
    return test_obj(x)
```

> tuple_test.pyx:6:9: Tuple types can't (yet) contain Python objects.

Ah crap.

4:45pm. Let me not give up here. What about structs?

4:50pm.

```
cdef struct QWE:
    object a
    object b
```

This is so useless of it.

4:55pm. Let me not get too pessimistic here. I'll try installing the prerelease and seeing how that goes.

https://pypi.org/project/Cython/#history

How do I install the prerelease using conda?

https://docs.conda.io/projects/conda/en/latest/user-guide/getting-started.html#managing-packages

It is not on the conda package list. What do I do here?

https://pypi.org/search/?q=cython

I don't think it is possible to install the prerelease through pip either.

5:30pm. https://github.com/cython/cython/issues/

Opened issue 3985 here requesting to support Python objects in cdef structs, unions and tuples.

5:35pm. This was actually quite a shock to me. It wrecked my compilation plan. This is definitely a point in favor of doing a direct C/Python backend.

5:40pm. The thing I had in mind would have been extremely performant, but I'll have to lower my expectations here.

Ah, forget it. I'll give it an extra week. I need to study the way Python works before I make a decision.

6:10pm.

https://cython.readthedocs.io/en/latest/src/tutorial/cdef_classes.html

Let me try out if structs work in `cdef classes`.

```
cdef class Qwe:
    cdef object x
    def __init__(self, q):
        self.x = q

cpdef object test_obj(object x):
    q,w = x
    return q+w

cpdef object qwe(object a, object b):
    x = a,b
    cdef Qwe z = Qwe(x)
    return z #test_obj(x)
```

Oh, it does work in cdef classes.

6:20pm. No this is not what I need. Obviously I won't start work on the backend today. Let me take a look at embedding Python section of its documentation.

I think I am going to put in some overtime today. I really need more time in the day. Today I literally only started at 3pm for some reason. It is all the winter's fault making me stay in bed until the fire gets started.

https://docs.python.org/3/extending/embedding.html

6:20pm.

```cpp
#define PY_SSIZE_T_CLEAN
#include <Python.h>

int
main(int argc, char *argv[])
{
    wchar_t *program = Py_DecodeLocale(argv[0], NULL);
    if (program == NULL) {
        fprintf(stderr, "Fatal error: cannot decode argv[0]\n");
        exit(1);
    }
    Py_SetProgramName(program);  /* optional but recommended */
    Py_Initialize();
    PyRun_SimpleString("from time import time,ctime\n"
                       "print('Today is', ctime(time()))\n");
    if (Py_FinalizeEx() < 0) {
        exit(120);
    }
    PyMem_RawFree(program);
    return 0;
}
```

I can't tell at all how much of these are macros and how much are actual function calls. If these are not macros, then is the Python interpreter state global? That is shit. I guess I now know why the GIL is necessary. I was expecting the interpreter to be passed as a pointer, but it is nowhere to be found.

https://docs.python.org/3/extending/index.html

Let me go through this all in turn. I need to focus on this. It is not a given that I am going to use Cython. I want the best possible option.

...If I am just doing the Python backend in C, assuming I can accept it being global, then I can see how it would make things easier.

7:15pm. https://docs.python.org/3/c-api/refcounting.html#c.Py_DECREF

Having to do reference counting manually in a direct backend would be pain itself.

8:05pm. Let me stop here for the day.

I've decided. Despite the recent blow, I can't deal with reference counting. Neither can I deal calling Python library functions manually. This C style code is absolutely attrocious. Even if I could deal with ref counting, I cannot possibly subject the user to this.

If something like Cython did not exist, I'd compile to straight Python instead. I should be glad that I at least have it.

8:20pm. Got a reply. I do not understand why structs and tuples would get treated differently. Nevermind that for now.

Let me close here. I need to unwind.

Tomorrow I will start work on the Cython backend. It won't be hard. I've preped my mind for the task, and I just need to execute it. In fact, Cython not having some of the vital stuff that I'd need for Spiral's compilation will actually make implementing those features easier. I am thinking of unions here. Both the recursive and the non-recursive unions would need to be heap allocated in Cython. I have no choice, but to do this here.

I am guessing that tuples will land in Cython at some point, until then I'll just compile the compound types containing objects to objects. I'll deal with it that way.

It won't be hard.

8:30pm. I am going to make a dent in that backend tomorrow. I'll have something to show for it next month."

---
## [equwal/thefuck@d03df1dd75...](https://github.com/equwal/thefuck/commit/d03df1dd75d5da3af6ac7002262ffb74a06b01f1)
##### 2021-01-25 20:56:50 by Spenser Truex

Allow multiple alias arguments

This change makes up somewhat for thefuck's >100ms time to print the
aliases.

Some profiling shows that 50% of that time is spent loading a bunch of
unsued packages, and the other 50% is unavoidable overhead for starting
a python script.

These are valid:
thefuck --alias f k fuck fk # new!
thefuck --alias fk # one arg form
thefuck --alias # uses fuck by default still (backward compatibility)
thefuck --alias fk --enable-experimental-instant-mode # also supported!

Before, setting 10 aliases meant a 1second shell startup. Now:

$ time thefuck --alias a b c d e f g h i j
thefuck --alias a b c d e f g h i j  0.20s user 0.04s system 96% cpu 0.256 total

Not bad!

---
## [Empow-PAT/fall2020game@829fa68516...](https://github.com/Empow-PAT/fall2020game/commit/829fa685162a9285b982f192cbfa67804e84c116)
##### 2021-01-25 21:48:52 by kijavnash

To be, or not to be, that is the question:
Whether 'tis nobler in the mind to suffer
The slings and arrows of outrageous fortune,
Or to take arms against a sea of troubles
And by opposing end them. To dieâ€”to sleep,
No more; and by a sleep to say we end
The heart-ache and the thousand natural shocks
That flesh is heir to: 'tis a consummation
Devoutly to be wish'd. To die, to sleep;
To sleep, perchance to dreamâ€”ay, there's the rub:
For in that sleep of death what dreams may come,
When we have shuffled off this mortal coil,
Must give us pauseâ€”there's the respect
That makes calamity of so long life.
For who would bear the whips and scorns of time,
Th'oppressor's wrong, the proud man's contumely,
The pangs of dispriz'd love, the law's delay,
The insolence of office, and the spurns
That patient merit of th'unworthy takes,
When he himself might his quietus make
With a bare bodkin? Who would fardels bear,
To grunt and sweat under a weary life,
But that the dread of something after death,
The undiscovere'd country, from whose bourn
No traveller returns, puzzles the will,
And makes us rather bear those ills we have
Than fly to others that we know not of?
Thus conscience does make cowards of us all,
And thus the native hue of resolution
Is sicklied o'er with the pale cast of thought,
And enterprises of great pitch and moment
With this regard their currents turn awry
And lose the name of action.

---
## [grapl-security/grapl@6137fd7042...](https://github.com/grapl-security/grapl/commit/6137fd704231e48a4f29229018c140658f8ad181)
##### 2021-01-25 22:58:47 by wimax-grapl

Begin to migrate python S3/SQS clients to a FromEnv equivalent (#541)

* On the road to Rust-like Fargate Stuff

yeah sure whatever

Fixed up typechecks

blep blep

It should work, but it doesn't.

I think it should work potentially

It fucking succeeded asdfgh

Yes yes it works yes

e2e works

sysmon works

okay time to rip out more garbage

it work

* readd removed logging driver none thing

* woops two tabs

* Remove the thing that caused pytype failure

* Lock test requirements

* change some prints to logger calls

---

# [<](2021-01-24.md) 2021-01-25 [>](2021-01-26.md)

