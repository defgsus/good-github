# [<](2021-02-06.md) 2021-02-07 [>](2021-02-08.md)

2,083,539 events, 1,160,914 push events, 1,662,772 commit messages, 104,148,342 characters


## [kaciyn/aulare@a255756a78...](https://github.com/kaciyn/aulare/commit/a255756a780bdf9ed59eaa8c30c817a14edde589)
##### 2021-02-07 01:20:20 by sectumsemper

OH MY GOD I FIGURED IT OUT I THINK
thanks felix angeLov(e) for my life, the problem was this guy:

return BlocProvider<AuthenticationBloc>.value(
        value: BlocProvider.of<AuthenticationBloc>(context),

 + also added the !=null asserts for the providers in the blocs & added the missing "@" for the spoofer email

---
## [mrakgr/The-Spiral-Language@01a03a7d8e...](https://github.com/mrakgr/The-Spiral-Language/commit/01a03a7d8ec2bfffacf3b98683e9cd0df2c3d30f)
##### 2021-02-07 10:38:08 by Marko Grdinić

"9:10am. Right now I am chilling. But I'll get to start early today either way.

9:20am. Well, let me have some fun for a while. The papers can wait.

The truth is, I did think about doing pure Python for a while, but seeing those 500 lines models in the OpenSpiel repo is what changed my mind. I have to use Spiral if nothing else, but for top-down typing.

9:45am. A lot of my follows are out today. Why do both Ex-Arm and Crow Record have such low res scans?

10:05am. Enough slacking. It is time to get into the mood for this.

It has been ages since I read ML papers last.

Though it seems like a waste not to use the OpenSpiel library directly, as far as the algorithms themselves are concerned, I can borrow their skeleton and imitate their form in my own work. That will speed up my own work significantly. The C++ games I'll have to do on my own though - that code is too low quality to use as reference. The UI stuff will be my innovation, but I am not sure how GUIs will work on Python. I am worried the GIL lock might make a mess of everything.

I know that Python has Rx as a library, but not much more than that. I really hope Python has something better for GUIs than Gtk. That one is pure garbage and I know that it is the main GUI library.

10:15am. Focus me. Let me start this thing.

This is my usual pace when I am not waking up at 11am.

Think me. Where do I start today?

How about with Noah Brown's stuff?

https://arxiv.org/abs/2007.10442
Unlocking the Potential of Deep Counterfactual Value Networks

I am looking him up on Arxiv.

https://www.cs.cmu.edu/~noamb/research.html

Here is his personal page.

Let me start with the DCVN paper and then I will move from there.

> These improvements include an equilibrium-finding algorithm that achieves a far better empirical convergence rate than past algorithms, an efficient GPU-based implementation of this algorithm, more iterations resulting in much closer convergence to an equilibrium when conducting search, a larger search space, and far more training data

> an efficient GPU-based implementation of this algorithm

Yeah, this is what I need. I should just go with this. Although OpenSpiel has a lot of stuff, a lot of it is outdated despite being a year old.

> We measure the impact of each of these changes in the benchmark game of HUNL

Heads Up No Limit? Yes, exactly what I want. This is the one thing I need to master first. This paper should serve as the foothold.

> Our reimplementation of DeepStack closely follows what was described in the paper

I bet I could find a DeepStack PyTorch implementation somewhere.

> Supremus has several improvements over existing methods, including our modified CFR variant DCFR+, neural networks on all lookahead trees, and a complete end-to-end GPU implementation.

End-to-end? What does that mean?

> Specifically, we modify the DCFR algorithm so that rather than having iteration t receive a weight of t2 when computing the average policy, it instead receives a weight of max{0, t − d}

This is an interesting way of doing the weighting.

> Surprisingly, we observed faster convergence when updating both players simultaneously rather than alternating when a counterfactual value network is used at leaf nodes, while the opposite has historically been observed when not using counterfactual value networks.

> Supremus is a custom implementation written in CUDA with C++ to run entirely on a GPU. It has custom kernels optimized to achieve optimal performance and throughput. It has a single on-ramp to load the initial tree into GPU memory and an off-ramp when DCFR+ is complete. This allows the software to never move memory in and out of the GPU, greatly reducing the memory latency during run-time. When comparing the speed of the two implementations using the same action abstraction on the flop, Supremus completes 1,000 iterations in 0.8 seconds, over 6x faster than DeepStack. The faster GPU implementation combined with the use of DCFR+ results in Supremus achieving an exploitability of 3 mbb/g over 5,000x faster on the same hardware.

Maybe I will be making that Cuda backend. Though I wonder if there will be code for this paper. Noah Brown does not provide it, but maybe this group will though it is unlikely.

10:50am. Ok, I've read the paper, and where are the actual details of the methods? There are just a bunch of benchmarks here.

10:55am. Supremus uses this or that rather then the regular thing? This is not a description of the algorithm. What a crappy paper. The authors did not even leave their email for me to contact them.

Nevermind this advert for Minimal AI. Maybe I will find a way to get the author's email if I am particularly desperate.

Let me move to Brown's stuff.

DREAM - Deep Regret Minimization with Advantage Baselines and Model-free Learning
https://arxiv.org/pdf/2006.10410.pdf

> However, in order to deploy tabular CFR in domains with very large state spaces, domain-specific abstraction techniques that bucket similar states together are needed [11, 3]. While these abstraction techniques have been successful in poker, they require extensive domain knowledge to construct and are not applicable to all games. This has motivated the development of CFR algorithms that use neural network function approximation to generalize with far less domain knowledge.

Yes, this is why I want to use NNs.

> However, the existing forms of neural CFR only perform well with an exact simulator of the game, which allows them to sample and explore multiple actions at a decision point and thereby reduce variance. We show they perform poorly if only a single action is sampled, which is necessary in a model-free setting.

And this is what I was afraid of if I just picked Deep CFR.

2/14. I'll parse this formal stuff more in depth later. I used to be familiar with this, and need to reinit myself.

> Deep CFR is a fully parameterized variant of CFR that requires no tabular sampling [4]. Deep CFR substantially outperformed NFSP (which in turn outperforms or closely matches competing algorithms [31]). Single Deep CFR (SD-CFR) [32] removed the need for an average network in Deep CFR and thereby enabled better convergence and more time- and space-efficient training. However, both Deep CFR and Single Deep CFR rely on a perfect simulator of the game to explore multiple actions at each decision point.

So it explores multiple actions, but not necessarily all of them? Something like that could be expected.

11:10am. 4/14. Here the paper mentions VR-MC-CFR. Did they manage to integrate these advancements into this NN version?

This paper is a great review. It really gives me a lot to work with. I'll make it my target then. Deep CFR already exists in the OpenSpiel repo, and this will accelerate me getting up to speed.

> In this section, we will describe DREAM, (D)eep (RE)gret minimization with (A)dvantage Baselines and (M)odel-free learning. The primary contribution of this paper is to effectively combine a deep neural network approximation of outcome sampling CFR with learned baselines.

Yes, this is what I need.

> Potential adverse applications most prominently include providing easy access to tools that aid cheating in online imperfect-information games with our open-sourced implementation of DREAM.

They provide an implementation of this? Let me see if I can find it.

https://arxiv.org/abs/2006.10410

Ah, there is a code section here!

https://github.com/EricSteinberger/DREAM

Here it is. Since the CFR guys are Facebook, they should be using PyTorch as well.

...Nope, the previous paper I've read has no code.

https://github.com/EricSteinberger/PokerRL

Change of plans yet again. This guy has everything, from the algorithm to the environment.

I was mentally ready to do things on my own, but I swore to myself to change my attitude, so I'll use this for the time being.

https://github.com/EricSteinberger/DREAM#dream-on-your-local-machine

It supports only Linux officially.

11:35am. Ok, let me clone this repo and then I will take a break.

After that is done, I'll move to studying it. After that I'll focus on getting it to run.

I'll decide what do I want to do after that."

---
## [davidnewhall/unpackerr@c1ca403f79...](https://github.com/davidnewhall/unpackerr/commit/c1ca403f79fbbe20d16cbd2a7e5ca92ac2e40227)
##### 2021-02-07 11:06:55 by Marissa

Update unpackerr.conf.example

Added a #comment to lidarr and readarr bc oh my god i hate myself and spent a lil bit too much time figuring out why the program doesnt work

---
## [Tenryumi/VOREStation@fc91485466...](https://github.com/Tenryumi/VOREStation/commit/fc91485466cb1b6be160150b67edefc31d8f5737)
##### 2021-02-07 17:29:48 by Wickedtemp

ML3M Rebalancing

Originally, the ML3M was intended to be a little bit stronger. The healing values for the Brute, Burn, Omni, Toxin, and Antirad cells, have been adjusted according to what was initially planned. 
Base Tier's now heal 10 per shot, for a total of 40 damage healed, up from 20.
Second Tier's now heal 20, instead of 10.
Third Tier's heal 40, instead of 20. 

Omni 1 heals 5's for brute, burn, and toxin, and 30 for oxy, up from half those values. Omni 2, is 10's and 60, and Omni 3 is 20's and 120. 

Antirad Cell had its toxin heal bumped up from 2.5 to 5, and its radiation-heal from 150, to 350. I wasn't originally going to touch this one, but the text said "It's 150 because that's equal to five units of arithrazine", and... it wasn't. So, I bumped it up to actually be equal to 5u of Arithrazine's worth of radiation healing.

Stabilizer Cell, CorpseMend, Resistance, Haste, and the size-changing cells, were not touched.
The reasons for this are as follows:

- The healing laser was simply not strong enough to ever tend to more than one patient. Healing 20-40 damage per cell just isn't enough, even if you had several clips full of cells, it just wasn't viable.
- As a result of this, it was seldom if ever used. Field Medics rarely if ever took it with them. In nearly every round I've played, it was left exactly where it was spawned, collecting dust. 
- I'd like to make it a more proper treatment option. It wouldn't be equal to reagents used in your usual Medbay setting, or surgical repair, but if it's modified to actually fulfill its niche as a rapid, contact-free treatment option, it could be relied on more by Field Medics. There is so much potential for this device as an "in the field" healing tool, and I'd like to see it done well. We have no shortage of people who would like to see non-chemical-based treatment options. We might as well make it useful enough to actually use.

Here are a few issues people brought up in Discord when I floated this idea.
"But, Tempest, you're doubling everything? That's a huge change! Won't this result in the ML3M overshadowing other treatment options?"
Certainly not. Currently, with tier-2 cells that only heal up to 40 damage, this is actually worse than basic first-aid in terms of raw healing ability, as the cutoff for first aid healing is 50 damage on a limb. First aid and reagents will still be the most convenient, most readily available, and overall most-used manner of treatment for injuries that can be treated using those methods. All this change would do is allow the ML3M to also have its uses, and stop being overshadowed by everything else. 

"Okay, but what if it DOES actually become The New Meta and becomes the favored tool for healing?"
I wouldn't see it as an issue if Chemistry gets dethroned, in all honesty. They'd both take quite a bit of prep-work to use. You have to make multiples of every chem if you want a solid stock, and you'd need multiples of every cell if you want proper coverage and healing-ability, since even with these changes you're expending 1-3 cells per patient. And, unless you get multiple ML3M's made, only folks who are gonna have one are the CMO, and whoever nabs the spawned one first. 

"But wouldn't this result in less departmental cooperation between Medical and Science now that Medical will require fewer cells?"
Most likely, no. If anything, I'd think there would be an increase, round-to-round, if this becomes a more viable and wanted tool, more people will ask for cells. Personally, my list of requested cells would stay the same, but I'd be sending that request in more often since I know it'll actually be useful rather than having it just to have it. Tier 2 cells are still going to be desirable, and I'm still probably not going to order Tier 3's because of the cost, but that's just me. It's still going to be incredibly weak at roundstart, and better cells will be that much nicer to obtain.

"But Tempest! If you get the highest tiers of cells, and a lot of them, you could fix anything that doesn't require surgery!"
Well, if Science had the time and mats, then sure, you could gather up a large enough collection of cells, and you probably could indeed do this for one or two badly injured patients... ... ...and I could accomplish the same goal if I'm given 20 seconds in a chem-lab. The ML3M is more costly to use, the cells cost resources, have to be recharged after 4 shots, and you only start with a base tier Burn, Brute, and Stabilizer cell. Each shot from a base level burn/brute cell is the equivalent of 1.25u of bicaridine or kelotane. This change would make it 2.5. Base level cells are still going to be next to useless for anything other than the most minor of injuries. Chemistry will still be the dominating powerhouse it always has been, but at least you can use this tool, provided the PR goes through, instead, more often.

"Tempest, this thing just wasn't intended to be used to fully heal people..."
A couple people have said this, and to be honest, it's silly. In our medical system, there's very little distinction between what can "heal a little bit" and what can "heal fully", because it all comes down to the fact that everything works off of damage values. If Option A heals 5 damage, and Option B heals 50... Both are capable of "healing fully" if you have enough Option A, it's just a question as to whether or not that's practical. Currently, the ML3M's healing values can't really even be used to even partially heal injuries, unless you have a large number of cells. You'd expend all of your charges on one patient and then you've got a paperweight taking up storage space until you can get to a recharger. 

Now, as for issues that I personally see? Biggest one is probably the Toxin cell. If I remlember correctly, the base Toxin cell is the same tech requirement as the Second Tier Brute/Burn cells. This PR doesn't fix that, and I don't really see it as a huge priority since I don't think anyone uses the toxin cells as it is, but yeah. Might need to be fixed at some point if this PR goes through.

And, absolute worst case scenario, let's say that this PR screws everything up, turns the Tether upside down, and now Medbay is dominated by a bunch of blue laser beams flying everywhere like it's the new Star Wars Trilogy (but actually better because those movies kinda set a low bar)... this PR was really easy to do. The only long part about it was typing all of this up. We can just bump the numbers down if this ends up sucking really bad, ezpz.

Thank you for coming to my ted talk.

---
## [mrakgr/The-Spiral-Language@6cbfd1ca83...](https://github.com/mrakgr/The-Spiral-Language/commit/6cbfd1ca83b4a92edd2e49e344d64e3abe7fa214)
##### 2021-02-07 17:42:12 by Marko Grdinić

"12:45pm. Let me resume. Done with breakfast and chores. Let me make a tour of the DREAM repo. I need to do an evaluation of how much of the code is usable straight up.

...Ok, I do not see Tensorflow in the requirements. It uses Torch. This is good.

1pm. I am looking at `EvalAgentDeepCFR.py`. It is 470 lines long.

Honestly, if I was writing Python I don't know whether I would be able to do better than this. I just don't.

But I am going to have to pick this stuff apart and reimplement it on my own. I can only use this as reference.

1:15pm. I am looking at `_HighLevelAlgo.py`.

This stuff is so complex. It is quite amazing.

1:35pm. Let me finish the tour quickly and then I will gather my thoughts. I am not really studying this. Right now I am just seeing the sights.

1:45pm. Let me think.

People worry about AI taking over the world, but in the case of poker, can you imagine anybody just taking this and going on a rampage? I sure can't!

Life is not that easy. Reading the DREAM paper, you'd think it would be an easy thing to write, but the amount of code associated with the paper is enormous. I can't deal with this.

My only choice is to rebuild it on my own. Only then would I be able to master this.

As a kid part of the reason I did not want to become a programmer is because of this. It requires so much dedication and there are no shortcuts to success.

But at least it gives me a target.

1:50pm. With that paper, I have no reason to fail at the task of making a good poker agent apart from lack of perseverance.

Maybe I will get nowhere in 2021. But I am sure that 2021 will be the year where I pay my dues to Python. I ignored and looked down on it far too much. The language might get bashed, but none in the world opposed it as much as I did. I put so much of my time in making Spiral, so I would not need to use it.

Now is the time to open my mouth and take a bite.

1:55pm. I'll have to pay a price in the time spent doing this.

2pm. After seeing that codebase, I do not feel like starting with the agent itself after all. Instead I will start with the game.

```fs
    member t.Add(x: 'a): ConsedNode<'a> =
        let hkey = hash x &&& Int32.MaxValue
        let table = table
        let bucket = table.[hkey % Array.length table]
        let sz = bucket.Count
```

My thoughts are wondering. I started thinking about serialization.

```fs
    member t.Add(x: 'a): ConsedNode<'a> =
        let hkey = hash x
        let table = table
        let bucket = table.[(hkey &&& Int32.MaxValue) % Array.length table]
```

It would be better if I hashed it like so. No need to throw out the last bit.

```fs
open System
let x = Int32.MinValue |> abs
```

Yeah, this throws an exception.

I'll have to test this change. I'll do it later. I am decently sure it will work. The hash cons table has not changed for years, funny how improvements can come to mind.

2:10pm. I need a short break.

I should start work on Leduc, but I am actually depressed now. I started out quite eager, but whether it is DREAM or OpenSpiel, there is so much I do not understand in them.

In constrast, right now I could be working on things like the Cuda backend or a C backend which would be a lasting benefit for the language.

Instead I have to tackle this great challenge. The fact that there are game libraries changes nothing. I have to adapt it for myself.

2:35pm. There is no helping it. Let me just start. Let me test the latest change.

...It crashes.

```fs
let bucket = table'.[hash a % table_length']
```

It is probably because of this. Now it works fine. This will be a decent optimization for the `HashCons` table. Ok.

I'll hold off making this a patch. Instead let me start work on a HU poker game. I'll pick Leduc poker.

...Actually, let me just push this out. Now I don't need to think about this.

2:40pm. Who knows what kinds of compiler bugs I'll find in the future. This work on a game will be my chance to stress test Spiral further. And who knows, I might be able to use this chance to make some articles and raise my profile.

In two days I'll make some time to take a trip to the bank at around 4pm.

This is destiny. Let me get cracking.

2:45pm. Right now my mood is at the bottom, it is a complete difference to yesterday's aggressive demeanor, but I will get things back on track.

In the first place, I was not expecting that I would be able to just copy paste these things.

Of course doing this would take time. And of course I am going to do it.

2:50pm. Let me do a week of this and then I'll get back to interviewing.

2:55pm. Focus me. What are the rules for Leduc poker.

https://medium.com/ai-in-plain-english/building-a-poker-ai-part-8-leduc-holdem-and-a-more-generic-cfr-algorithm-in-python-9dd036bf9a30

What is this?

> It is played with 6 cards: 2 Jacks, 2 Queens, and 2 Kings.

It is not what I thought it was. I thought it was Holdem without 2-10 cards.

> The game we will play this time is Leduc Hold’em, which was first introduced in the 2012 paper “Bayes’ Bluff: Opponent Modelling in Poker”. It is played with 6 cards: 2 Jacks, 2 Queens, and 2 Kings. The suits don’t matter, so let us just use hearts (h) and diamonds (d). Each player gets dealt a hole card and posts a 1$ ante. There will be 2 betting rounds, each with a maximum of 2 raise actions. So the possible actions are raise or check if acting first in a betting round, re-raise/call/fold if faced with a raise, and call or fold if faced with a re-raise. The raise sizes are 2$ in the first betting round and 4$ in the second betting round. After the first betting round, a community card will be revealed.

This seems like a decent article.

3:05pm. Let me take some time to go through this series.

3:10pm. The article ended with saying that it will show how to do Hold'Em next, but did not come out, and probably won't at this rate.

Well, nevermind. It got me the rules of Leduc poker at least.

I just have to get to work on implementing it.

3:30pm. I am thinking about it. Usually, my aggression would be higher, but now my mood is low. Think about it for a bit will help me get into it.

Let me open a new file.

```
nominal card = u8

type player_hole_cards = P1: card P2: card
union state_first_round =
    | HoleCards: player_hole_cards

inl main() =
    ()
```

If I want to be able to make a function of `state * action -> state'` I need to represent the entire state using an union type.

3:50pm.

```
nominal card = u8

union response3 next = Fold | Call: next
union response2 next = Fold | Call: next | Reraise: response3 next
union response1 next = Call: next | Raise: response2 next
union action next = Check: response1 next | Raise: response2 next
type state_second_round = CommunityCard: card Action: action ()
type state_first_round = HoleCards: (P1: card P2: card ) Action: action state_second_round

inl main() =
    ()
```

I get it.

3:55pm. I need to get my aggressive demeanor and confidence back on track. I was brilliant while I was working on that Cython ref counting pass.

This on the other hand is nothing in terms of difficulty.

Let me make the transition function.

4:05pm. Now I am thinking how to sample from an array.

6:05pm. Done with lunch. It is not like I am being lazy here, but once I set my mind on the problem of doing the game and later integrating it, I went deep into thought. The screen in front of me went black twice while I was thinking.

I know what the problem is.

I am going back to my past experiences of doing CFR and ML, but those experiences aren't what I need here. Those are the wrong experiences! The right one is my work on editor support for Spiral. I spent plenty of time thinking how to chain together communicating servers and then I figured out how to reason on about the problem in terms of gradual transformations.

Up to now, once I started work on Leduc poker, just because the game is easy I started thinking that the whole task should be easy, but that is not it. The game itself is like 10% of the whole job.

It is just like working on compiler. It is easy enough to do some compiler pass, but having to deal with the residuals of that like errors and editor support, makes things a lot harder.

6:15pm. With Leduc poker, it is easy enough to imagine the state transitions in the game and even implement it.

But the game is absolutely secondary here. I want the game to produce data that NNs can use.

I need a functional architecture here. I need to go back to my experiences of implementing streams.

When I was doing those CFR games, I had an easy time because I CPS'd everything, but that is not the right thing to do here. I need to invert that.

6:20pm. The benefit of all of this will be that I will be doing things those ML library authors cannot even imagine. I can see the potential of this. Doing this is not something that would be easy without top-down typing or functional programming features.

I am going to make it so that the purpose of a game is to produce a list of observations for both of the players.

Now, compared to tabular RL there are extra requirements for NNs. When it comes to serialization I mean. And I need to think about how to batch the data. I can't do it one at a time like in 2018.

All these transformations do amount to essentially being compiler passes. And that is the ideal way to model them.

I wonder if Python has immutable maps and such. I'll need to get them from somewhere. At worst, I'll dig them out of the F# repo.

Right now, I basically have nothing of the standard library. I don't even have Python's tuples, the fact that I have my custom made ones hurts interop. For the time being though, I'll go the route of implementing my own sampling functions and such.

6:30pm. With hashing...I am going to have to put the ops back in. Or rather, I need a check to make sure they operate only on primitives. I do not want Python reference types to mix with structurals.

```
            elif prototype_has `(`a) hashable then hashable `(`a) a
            else error_type "The input must be hashable."
```

6:35pm. Yes, this is right.

...

The issues I am thinking about here are really not related to the game in front of me at all. The same architectural problems is something I would need to deal with in any future games. Leduc poker is dead simple, but that does not change the architectural challenges at all. No wonder that guy gave up on Texas Holdem. It is easy enough to do CFR on a toy. NNs on a larger game are a different ball game.

If you pick the wrong approach and just start hacking, the complexity will drown you.

This is where real skill comes into play. It allows you to abstract the unneeded.

6:40pm. Maybe I will have article material in the future. I am going to take this challenge.

Today was full of ups and downs. I was really happy in the morning when I saw that DREAM has a code repo. Than I was sad once I looked at it. Then I had to talk myself into just doing the game. But now that I am thinking about the challenges here, I see that they are worthy of me."

---
## [aambrioso01/aambrioso01.github.io@3326e4b099...](https://github.com/aambrioso01/aambrioso01.github.io/commit/3326e4b0995ef61d02d881d9ba7b94cec3de659f)
##### 2021-02-07 23:53:25 by mjarvis1997

updated stream links

 - alley song -> that boy needs therapy
- god damn -> used to it
- quick with a wrist -> removed

- ragtag video -> new life

---

# [<](2021-02-06.md) 2021-02-07 [>](2021-02-08.md)

