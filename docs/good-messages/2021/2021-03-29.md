# [<](2021-03-28.md) 2021-03-29 [>](2021-03-30.md)

3,333,815 events, 1,525,609 push events, 2,380,687 commit messages, 185,420,458 characters


## [deletionday/awesome-humane-tech@7e89709c75...](https://github.com/deletionday/awesome-humane-tech/commit/7e89709c75844f094bd3c4b010d430c2af7f60bb)
##### 2021-03-29 00:56:55 by April 4th is Deletion Day!

Add Deletion Day

- [x] I have referred the list and did not find this submission already added.
- [x] I have read the contribution guidelines [here](https://github.com/humanetech-community/awesome-humane-tech/blob/main/contributing.md)
- [x] I have read the code of conduct and I agree to adhere to the same [here](https://github.com/humanetech-community/awesome-humane-tech/blob/main/code-of-conduct.md)
- [x] I have added my entry as the latest (last dotted point) under a topic, not at the beginning, not interleaved. 

If your suggested entry is code project:

- [x] I have checked that the project is open source and has a [FSF-approved](https://www.gnu.org/licenses/license-list.html) license.

Deletion Day is [licensed under the GNU GPL v3](https://github.com/deletionday/site/blob/master/COPYING)

### Name of my software/tool/service/technology/project:

[**Deletion Day**](https://deletionday.com)

### Explain why it's a Humane Technology

Deletion Day directly opposes the privacy and security overreaches perpetrated by today’s tech industry.

### Sourcecode is available…

[…on Github](https://github.com/deletionday/site/)

### Is there a similar software/tool etc., that already exists?

I’ve found instances of one-off data deletion events, for instance:

- [The International Association of Privacy Professionals Deletion Day (2018)](https://iapp.org/news/a/data-deletion-day/)
- [Montgomery Public Schools’ “Data Deletion Week”](https://www.theguardian.com/education/2019/dec/05/schools-monitor-students-online-activity)

…but as far as I know, this is the first effort to form a recurring awareness campaign around this issue.

### Motivations, goals, and purpose

Excerpt from [deletionday.com](https://deletionday.com):

> New technologies have the power to reshape civilization. Transformative developments like the calendar and the printing press not only reorganized society; they fundamentally changed how individuals thought. Today, digital storage is cheap and abundant. As it pervades everyday life, it has shifted our expectations about permanence. In this age of internet-connectedness and cheap digital storage, we no longer need to forget.
>
> We encode our heart rates, travel plans, and friendships into permanent storage. We welcome each minor convenience, and assume that sharing and storing are positive forces – or at least, that it may come in handy later.
>
> It’s worth considering who this benefits.
>
> Industries exist with the sole purpose of scraping photos and information about you to store, analyze, and sell. Advertisers, insurance companies, and police departments profile you based on your browsing history. Photos, video, and audio recordings can be used to generate realistic “deepfakes”. Doxing and harassment campaigns are on the rise.
>
> The data you store online does not belong to you.
>
> You may be aware of this reality from the news, or just a feeling in your gut. But it can be hard to know how to respond when so much of our attention and identity are wrapped up in the Internet.
>
> On the topic of identity, it’s worth asking if uploading this much of ourselves to an unsympathetic, persistent medium was ever a good idea. As people, we grow and change. Maintaining a consistent personal brand may hamper our ability to grow as people; digital footprints don’t fade.
>
> Deletion Day challenges the prevailing notion that “more is more”. In a culture that strives for permanence, we celebrate ephemerality, growth, and change. On April 4th, a chorus of Delete keys will ring out across the world. We hope you’ll join us.

---
## [Dropshotz/PFStation@fc91485466...](https://github.com/Dropshotz/PFStation/commit/fc91485466cb1b6be160150b67edefc31d8f5737)
##### 2021-03-29 03:35:49 by Wickedtemp

ML3M Rebalancing

Originally, the ML3M was intended to be a little bit stronger. The healing values for the Brute, Burn, Omni, Toxin, and Antirad cells, have been adjusted according to what was initially planned. 
Base Tier's now heal 10 per shot, for a total of 40 damage healed, up from 20.
Second Tier's now heal 20, instead of 10.
Third Tier's heal 40, instead of 20. 

Omni 1 heals 5's for brute, burn, and toxin, and 30 for oxy, up from half those values. Omni 2, is 10's and 60, and Omni 3 is 20's and 120. 

Antirad Cell had its toxin heal bumped up from 2.5 to 5, and its radiation-heal from 150, to 350. I wasn't originally going to touch this one, but the text said "It's 150 because that's equal to five units of arithrazine", and... it wasn't. So, I bumped it up to actually be equal to 5u of Arithrazine's worth of radiation healing.

Stabilizer Cell, CorpseMend, Resistance, Haste, and the size-changing cells, were not touched.
The reasons for this are as follows:

- The healing laser was simply not strong enough to ever tend to more than one patient. Healing 20-40 damage per cell just isn't enough, even if you had several clips full of cells, it just wasn't viable.
- As a result of this, it was seldom if ever used. Field Medics rarely if ever took it with them. In nearly every round I've played, it was left exactly where it was spawned, collecting dust. 
- I'd like to make it a more proper treatment option. It wouldn't be equal to reagents used in your usual Medbay setting, or surgical repair, but if it's modified to actually fulfill its niche as a rapid, contact-free treatment option, it could be relied on more by Field Medics. There is so much potential for this device as an "in the field" healing tool, and I'd like to see it done well. We have no shortage of people who would like to see non-chemical-based treatment options. We might as well make it useful enough to actually use.

Here are a few issues people brought up in Discord when I floated this idea.
"But, Tempest, you're doubling everything? That's a huge change! Won't this result in the ML3M overshadowing other treatment options?"
Certainly not. Currently, with tier-2 cells that only heal up to 40 damage, this is actually worse than basic first-aid in terms of raw healing ability, as the cutoff for first aid healing is 50 damage on a limb. First aid and reagents will still be the most convenient, most readily available, and overall most-used manner of treatment for injuries that can be treated using those methods. All this change would do is allow the ML3M to also have its uses, and stop being overshadowed by everything else. 

"Okay, but what if it DOES actually become The New Meta and becomes the favored tool for healing?"
I wouldn't see it as an issue if Chemistry gets dethroned, in all honesty. They'd both take quite a bit of prep-work to use. You have to make multiples of every chem if you want a solid stock, and you'd need multiples of every cell if you want proper coverage and healing-ability, since even with these changes you're expending 1-3 cells per patient. And, unless you get multiple ML3M's made, only folks who are gonna have one are the CMO, and whoever nabs the spawned one first. 

"But wouldn't this result in less departmental cooperation between Medical and Science now that Medical will require fewer cells?"
Most likely, no. If anything, I'd think there would be an increase, round-to-round, if this becomes a more viable and wanted tool, more people will ask for cells. Personally, my list of requested cells would stay the same, but I'd be sending that request in more often since I know it'll actually be useful rather than having it just to have it. Tier 2 cells are still going to be desirable, and I'm still probably not going to order Tier 3's because of the cost, but that's just me. It's still going to be incredibly weak at roundstart, and better cells will be that much nicer to obtain.

"But Tempest! If you get the highest tiers of cells, and a lot of them, you could fix anything that doesn't require surgery!"
Well, if Science had the time and mats, then sure, you could gather up a large enough collection of cells, and you probably could indeed do this for one or two badly injured patients... ... ...and I could accomplish the same goal if I'm given 20 seconds in a chem-lab. The ML3M is more costly to use, the cells cost resources, have to be recharged after 4 shots, and you only start with a base tier Burn, Brute, and Stabilizer cell. Each shot from a base level burn/brute cell is the equivalent of 1.25u of bicaridine or kelotane. This change would make it 2.5. Base level cells are still going to be next to useless for anything other than the most minor of injuries. Chemistry will still be the dominating powerhouse it always has been, but at least you can use this tool, provided the PR goes through, instead, more often.

"Tempest, this thing just wasn't intended to be used to fully heal people..."
A couple people have said this, and to be honest, it's silly. In our medical system, there's very little distinction between what can "heal a little bit" and what can "heal fully", because it all comes down to the fact that everything works off of damage values. If Option A heals 5 damage, and Option B heals 50... Both are capable of "healing fully" if you have enough Option A, it's just a question as to whether or not that's practical. Currently, the ML3M's healing values can't really even be used to even partially heal injuries, unless you have a large number of cells. You'd expend all of your charges on one patient and then you've got a paperweight taking up storage space until you can get to a recharger. 

Now, as for issues that I personally see? Biggest one is probably the Toxin cell. If I remlember correctly, the base Toxin cell is the same tech requirement as the Second Tier Brute/Burn cells. This PR doesn't fix that, and I don't really see it as a huge priority since I don't think anyone uses the toxin cells as it is, but yeah. Might need to be fixed at some point if this PR goes through.

And, absolute worst case scenario, let's say that this PR screws everything up, turns the Tether upside down, and now Medbay is dominated by a bunch of blue laser beams flying everywhere like it's the new Star Wars Trilogy (but actually better because those movies kinda set a low bar)... this PR was really easy to do. The only long part about it was typing all of this up. We can just bump the numbers down if this ends up sucking really bad, ezpz.

Thank you for coming to my ted talk.

---
## [noeinan/DoL-World-Expansion-Mod@154613d3cd...](https://github.com/noeinan/DoL-World-Expansion-Mod/commit/154613d3cdfc4c97fc4ce09e5d0d315b7bef0d02)
##### 2021-03-29 05:47:54 by Purity

Contributed Scenes, Avery Dismissal

Features:

- Exhibitionist players can now strip and wait in a stall for an audience in the park restrooms. Promiscuous players can take it further. Written in collaboration with Kinky_One.
(Note: Currently, this can only be done at dusk or night time. Feel free to remove that constraint if you deem it appropriate. It would only require the deletion of a single check.)
- Exhibitionist players can now leave the lake while exposed without making a plant top or skirt.
- Avery can now be dismissed at very high rage. Written in collaboration with ArachneSilk.
- The game will now remove a love interest from the list of selectable love interests if they are dismissed, and tell the player when they are dismissed.

Fixes:

- Fixed cases of Robin and Avery being initialized manually, resulting in their .state variable being an empty string instead of "active" after initialization.
- Fixed an oversight in the robin_location widget, hopefully we can use this for Robin's schedule soon, we need bathtime with Robin damn it!
- The player will no longer warp to the men's restroom after washing their face in the women's restroom, like some kind of cheesy horror game opening scene.
- Fixed a line of text describing the player thrusting out their breasts during a flaunting event that would never appear because of an extra underscore that was greedy for attention.
- Fix for NPCs telling a crossdressing player that it's their fault for looking like a boy or a girl, but referring to the player incorrectly as the gender they were crossdressing as instead of their actual gender.
- Fix for a wolf pair event saving the same wolf twice.

---
## [mrakgr/The-Spiral-Language@37d8c0a18a...](https://github.com/mrakgr/The-Spiral-Language/commit/37d8c0a18abd96b6e577c3376cf4a48ba1cd9a1f)
##### 2021-03-29 11:11:35 by Marko Grdinić

"11:05am. I got up really late today, but at least I slept properly during the night. Let me start.

11:10am.

```
inl view dispatch (state : rx.observable state) =
    inl (~+) x = +state x
    floatlayout [
        @on_pos (fun _,x => dispatch (UpdateTablePos: x))
        @on_size (fun _,x => dispatch (UpdateTableSize: x))
        children [
            label [
                +pos (fun {table={cords={x width y height}}} => x + width * 0.075, y + height * 0.075)
                +text (fun {table={myPot={chips}}} => a64.join' "" ;["Stack: "; $"str(!chips)"])
                -size_hint (None, None)
                -font_size 30
                +size (fun {table={myStack={texture_size}}} => texture_size)
                @on_texture_size (fun _,x => dispatch (UpdateMyStackTextureSize: x))
                ]
            ]
        ]
```

I still have some sand in my eye. Let me start by explaining what I want to do here.

```
union msg =
    | UpdateTablePos: f64 * f64
    | UpdateTableSize: f64 * f64
    | UpdateMyStackTextureSize: f64 * f64
    | Action: string * array leduc.action * (leduc.action -> ())
    | StartGame

type cords = { x : f64; y : f64; width : f64; height : f64 }
type texture_size = f64 * f64
type stack = { cords : cords; texture_size : texture_size; chips : i32 }
type card = { cords : cords; texture_size : texture_size; text : string }
type table = {
    cords : cords
    myStack : stack; myCard : card; myPot : stack
    opStack : stack; opCard : card; opPot : stack
    }
type state = {
    table : table
    actions : array leduc.action
    cont : leduc.action -> ()
    trace : string
    }

inl init_state () : state =
    inl cords = {x=90; y=90; width=90; height=90}
    inl texture_size = 0,0
    inl stack = {cords texture_size chips=10}
    inl pot = {stack with chips=0}
    inl card = {cords texture_size text=" "}
    inl table = {
        cords
        myStack = stack; myCard = card; myPot = pot
        opStack = stack; opCard = card; opPot = pot
        }
    {
    table
    actions = ;[]
    cont = fun _ => ()
    trace = ""
    }

inl model (s : state) = function
    | UpdateTablePos: x,y => {s.table.cords with x y}
    | UpdateTableSize: width,height => {s.table.cords with width height}
    | UpdateMyStackTextureSize: (a,b) & texture_size => {s.table.myStack with texture_size}
    | StartGame => s
```

I did this yesterday, but this is in no way what I want the stop level state to be.

When it comes to placing coordinates, I feel like what Kivy does with its properties is the right way to go. Yet, seeingly the only way to get the same effect using my own method is to go in this direction.

This forces me to write too much boilerplate.

That I did not know how to deal with it was making me stressed. I constantly keep making comparisons to Svelte. I keep thinking about reactivity in terms of observables, but that is wrong. I need to think about it in terms of properties.

I want to internalize a new way of doing things. First let me start with the top level state.

```
type player = { pot : i32; stack : i32; card : string }
type state = {
    me : player
    opp : player
    community_card : option string
    actions : array leduc.action
    cont : leduc.action -> ()
    trace : string
    }
```

This is more along the lines of what I had in mind.

The front end state should not be used for keeping track of actual player weights and such. The continuation for the game should be the fanciest part.

The front end is just for the displayable part of the state.

The back end state is where I should do all the actual functionality. Forget mixing up the front end and the backend.

11:20am. The reason why I am finding Kivy confusing is because it actually has a simple property system that I'd want to use. In Avalonia I did all my thinking in terms of observables. So I am not used to it.

```
inl init_state () : state = {
    me = {pot=0; stack=0; card=" "}
    opp = {pot=0; stack=0; card=" "}
    community_card = Some: "J"
    actions = ;[]
    cont = fun _ => ()
    trace = ""
    }
```

Much better.

```
union msg =
    | Action: string * array leduc.action * (leduc.action -> ())
    | StartGame

type player = { pot : i32; stack : i32; card : string }
type state = {
    me : player
    opp : player
    community_card : option string
    actions : array leduc.action
    cont : leduc.action -> ()
    trace : string
    }

inl init_state () : state = {
    me = {pot=0; stack=0; card=" "}
    opp = {pot=0; stack=0; card=" "}
    community_card = Some: "J"
    actions = ;[]
    cont = fun _ => ()
    trace = ""
    }
```

This is good.

```
type obj = $"object"
nominal widget = obj
nominal layout_widget = obj
nominal app = obj
nominal prop a = {
    read : () -> a
    set : a -> ()
    subscribe : (a -> ()) -> rx.disposable
    }

inl (<<;) (prop a) (prop b) = prop {
    read = fun () => a.read(), b.read()
    set = fun a',b' => a.set a' . b.set b'
    subscribe = fun f =>
        inl f _ = f (a.read(), b.read())
        inl c = rx.disposablem.composite()
        rx.push c (a.subscribe f) . rx.push c (b.subscribe f)
        rx.toDisposable c
    }
```

Let me revisit this a little. I need it to read the property during the first subscription.

```
inl prop1 forall m. (event_name : string) (f : obj -> ()) (x : m) =
    inl f (x : tuple) = f $"!x[1]"
    inl uid : obj = $"!x.fbind(!event_name,!f)"
    disposablem.create fun () => $"!x.unbind_uid(!event_name,!uid)"
```

Huh, I am confused. Where is that suppose to come in? Here?

11:50am.

```
inl (<<;) (prop a) (prop b) = prop {
    read = fun () => a.read(), b.read()
    set = fun a',b' => a.set a' . b.set b'
    subscribe = fun f =>
        inl f _ = f (a.read(), b.read())
        inl c = rx.disposablem.composite()
        rx.push c (a.subscribe f) . rx.push c (b.subscribe f)
        rx.toDisposable c
    }
```

I am thinking about this.

No, I did not think this through properly yesterday. The way to deal with properties is to make them behavior subjects. Then they should be combined using combineLatest.

https://ninmesara.github.io/RxPY/api/operators/combine_latest.html

```
inl combineLatest2 forall a b. (a : observable a) (b : observable b) : observable (a * b) =
    !!!!Import("rx")
    $"rx.observable_latest(!a,!b)"
inl combineLatest3 forall a b c. (a : observable a) (b : observable b) (c : observable c) : observable (a * b * c) =
    !!!!Import("rx")
    $"rx.observable_latest(!a,!b,!c)"
inl combineLatest4 forall a b c d. (a : observable a) (b : observable b) (c : observable c) (d : observable d) : observable (a * b * c * d) =
    !!!!Import("rx")
    $"rx.observable_latest(!a,!b,!c,!d)"
inl combineLatest5 forall a b c d e. (a : observable a) (b : observable b) (c : observable c) (d : observable d) (e : observable d) : observable (a * b * c * d * e) =
    !!!!Import("rx")
    $"rx.observable_latest(!a,!b,!c,!d,!e)"
```

Let me do a few of these like so.

```
nominal prop a = {
    get : () -> a
    set : a -> ()
    obs : rx.observable a
    }
```

Let me do it like this.

```
inl size_hint_x forall t {toWidget}. (x : t) =
    inl m x = if $"!x is None" then None else Some: x
    inl get () : option f64 = m $"!x.size_hint_x"
    prop {
        get
        set = fun (v : option f64) =>
            match v with
            | Some: v => $"!x.size_hint_x = !v"
            | None => $"!x.size_hint_x = None"
        obs = fun () =>
            rx.create (fun f =>
                rx.onNext f (get())
                bind1 "size_hint_x" (fun _,b => rx.onNext f (m $"!b")) x
                )
        }
```

Yeah, it is more along these lines.

But damn is writing these properties complicated

```
            rx.create (fun f =>
                rx.onNext f (get())
                bind1 "size_hint_y" (fun _,b => rx.onNext f (m $"!b")) x
                )
```

Let me not paste this everywhere.

```
inl prop1 event_name get m x () =
    create (fun f =>
        rx.onNext f (get())
        bind1 event_name (fun _,b => rx.onNext f (m $"!b")) x
        )
```

```
inl size_hint_x forall t {toWidget}. (x : t) =
    inl m x = if $"!x is None" then None else Some: x
    inl get () : option f64 = m $"!x.size_hint_x"
    prop { get set = function
            | Some: v => $"!x.size_hint_x = !v"
            | None => $"!x.size_hint_x = None"
        obs = prop1 "size_hint_x" get m x
        }
```

Let me abstract this even more.

No it is fine.

```
obs : rx.observable a
```

Ah, screw it. Let me do it like this.

```
inl x forall t {toWidget}. (x : t) =
    prop {
        set = fun (v : f64) => $"!x.x = !v"
        read = fun () => $"!x.x"
        subscribe = fun f => bind1 "x" (fun _,b => f $"!b") x
        }
```

You know what, screw this.

I do not feel like making all these shitty wrappers.

The amount of work involved in making Rx work for all of this is huge, and the end result will be worse than what Kivy language offers me.

I just could not stop obsessing about it. I had to know how to implement all that I needed in Rx.

The answer is...

```
nominal prop a = {
    get : () -> a
    set : a -> ()
    obs : rx.observable a
    }
```

Make use of properties.

Now let me leave this aside.

```
packages: |core-
modules:
    types-
    r64
    serialization/
        dense/
            array
        sparse/
            int
    utils-
    torch/
        utils-
    sampling
    nodes/
        utils-
        cps
        main-
    leduc
    agent/
        utils-
        uniform_random
        neural_random
        human
    cps_test
    main
```

Let me go to this previous plan.

https://fsprojects.github.io/Fabulous/Fabulous.XamarinForms/

```fs
/// The view function giving updated content for the page
let view (model: Model) dispatch =
    View.ContentPage(
        content=View.StackLayout(
            children=[
                if model.Pressed then
                    yield View.Label(text="I was pressed!")
                else
                    yield View.Button(text="Press Me!", command=(fun () -> dispatch Pressed))
            ]
        )
    )
```

That having said, I really am curious how diffing is done for commands here.

12:35pm. No forget this.

I can't believe I essentially wasted the last two weeks. I did great work during the first two in fixing the editor support of Spiral, but I literally haven't move a step closer towards my goals.

This is despite me wanting to!

March just went by in the blink of an eye. This is just too scary.

I feel like I could work for another month on the Rx based UI library.

Ahhh, why is this happening? Looking at the last 3 month more broadly, my progress has been a lot slower than it should.

```
root = Builder.load_string('''
<Table@FloatLayout>:
    canvas:
        Line:
            width: 2
            rectangle: self.x, self.y, self.width, self.height
    Stack: # Stack
        id: my_stack
        canvas:
            Line:
                rectangle: self.x, self.y, self.width, self.height
        text: 'Stack: ' + str(self.chips)
        x: root.x + root.width * 0.075
        y: root.y + root.height * 0.075
        font_size: sp(30)
        size_hint: None, None
        size: self.texture_size
```

Let me focus back on this.

Doing this was great. Could I replace this with a `pos_hint`?

```
    Stack: # Stack
        id: my_stack
        canvas:
            Line:
                rectangle: self.x, self.y, self.width, self.height
        text: 'Stack: ' + str(self.chips)
        pos_hint: {'x': 0.075, 'y': 0.075}
        font_size: sp(30)
        size_hint: None, None
        size: self.texture_size
```

Oh great, it does work!

```
        x: root.x + root.width * 0.6
        y: root.y + root.height * 0.925 - self.height
```

What about this?

```
pos_hint: {'x': 0.6, 'top': 0.925}
```

Yeah, this does work.

```
        x: op_card.right + dp(20)
        top: op_card.top
```

This works as well. Why did I have to subtract the height manually last time?

```
        x: root.center_x - self.width/2
        y: root.center_y - self.height/2
```

Let me smooth this out as well.

```
pos_hint: {'center_x': 0.5, 'center_y': 0.5}
```

Yeah, these are the kinds of improvements I should have been focusing on.

```
        x: root.center_x - self.width / 2
        y: root.y + root.height / 4
```

This should come next.

```
        pos_hint: {'center_x': 0.5}
        y: community_card.top + dp(10)
```

I have no idea why top and right were not working for me previously, but it does not matter.

1:05pm. Everything is fine as long as you have the language. Kivy's reactive language is exactly what I needed.

As far as size is concerned, it is ideally designed without having to go the lengths of Svelte. It really takes advantage of Python's OO capabilities.

Yes, Svelte is better, but how much effort going that length would take if Kivy's designers decided to do it?

It is really a pity I was too dumb to take advantage of this back in 2016 when I was using WPF, but things are fine.

1:05pm. Now focus me. What I need to think about is the back-end and the front-end state.

The front end state should just be the back-end state projected to it. The communication in the opposite direction should be done via callbacks.

1:10pm. Let me stop here so I can have breakfast."

---
## [wincent/liferay-portal@2e93e2433f...](https://github.com/wincent/liferay-portal/commit/2e93e2433f50abedde930ff418296273293e56cd)
##### 2021-03-29 17:50:26 by Greg Hurrell

LPS-129801 Port "render.es.js" to TS

Note this requires some horrible ugly casts for `Liferay`, because
globals are nasty and all that. Figuring out how to declare that as an
ambient type in some central location in the context of project
references is going to be complicated enough, based on my reading of:

    https://github.com/microsoft/TypeScript/issues/29002

that I am going to leave it for a separate commit.

There are a couple of `any` in here too, which I don't like (we've
mostly been able to get away without any `any` at all in
`frontend-js-react-web`) but I want to close up shop for the day so I am
going to commit this and push what I have.

---
## [nem0-z/ARI@585d4f886c...](https://github.com/nem0-z/ARI/commit/585d4f886c97f828c472fd2154e44cb881b1caee)
##### 2021-03-29 20:21:45 by Zlatan Radovanovic

what the fuck

This code looks like shit, but at least it's something. Committing
before I forgot something or my laptop crashed xd.

Basic functionality is there but have to make this not look like 5 yo
wrote it and handle cases when someone leaves the call (stasisend,
hangup, whatever)

---
## [nkoroste/rules_kotlin@15dd1de6dd...](https://github.com/nkoroste/rules_kotlin/commit/15dd1de6dd1431c5d2f7d2d7f1179a951d63a328)
##### 2021-03-29 22:47:48 by Christian Edward Gruber

Expose kotlinc's -Xfriend-paths to all jvm/android kt rules under the attribute 'assocates=' (#465)

Associates lets a library associate it self to other libraries, making them part of the same module. This is constrained such that while multiple libraries may be associated, they must all shard the same module, and so cannot associate to anything that is part of a different module. These module relationships are in the bazel build graph, not the contents of the jars as such.

This module membership is transitive (within the above-mentioned constraint), though strict-deps would stop that. Also, only kotlin targets can be associated.

Per discussions across several media, the name "associates" was chosen over "friends" (despite the kotlinc flag being -Xfriend-paths) as that is the terminology used in the gradle kotlin plugin, which is kotlin's primary delivery vehicle, and to avoid confusion with the C++ friends concepts. The pre-existing "friends" attribute is preserved for backward compatibility with a warning. Future PR will add a flag to turn off that support, and then we'll delete it.

kt_jvm_import does not include this facility, but these can just set their module_name in common to participate.

Android should work, but because kt_android_* is a macro not a rule, the implicit target //my/android/library:mytarget_kt should be friended, since it has a KtJvmInfo. The //my/android/library will macro-resolve into an android_library. Until the android rules get the right kind of love, such that we can make a rule that has KtJvmInfo AND android-whatever providers, this simply is a known limitation we'll have to live with.

Also, the prior implementation shoved the full transitive closure (all jars, kotlin or no) of the friend= into the -Xfriends-paths flag, which is awful. This PR does break that, in case people were relying on that by some oddity. The fix is to just add the targets directly.

Fixes #211

---

# [<](2021-03-28.md) 2021-03-29 [>](2021-03-30.md)

