# [<](2021-01-12.md) 2021-01-13 [>](2021-01-14.md)

2,818,117 events, 1,402,342 push events, 2,220,842 commit messages, 180,362,274 characters


## [BenDriller/bendriller.github.io@2306281c4f...](https://github.com/BenDriller/bendriller.github.io/commit/2306281c4f9b9937bb9acb51358a3a2c6807e5ca)
##### 2021-01-13 05:40:47 by BenDriller

fucking shit fucking fuck

I swear to fucking God I hate fucking merge conflicts.

---
## [dchacke/git-blog@d3d27d2a44...](https://github.com/dchacke/git-blog/commit/d3d27d2a4473a673bbfe8ee8e91a6b7d6b98479d)
##### 2021-01-13 08:30:29 by Dennis C Hackethal

# Want to Learn about AGI? Read These Chapters from "The Beginning of Infinity"

There is no bad chapter in David Deutsch's [*The Beginning of Infinity*](https://www.amazon.com/Beginning-Infinity-Explanations-Transform-World/dp/0670022756/). But if you're looking specifically for AGI-related content, here are the chapters you should read, in that order:

1.  Chapter 1: *The Reach of Explanations*

    You'll hit the ground running learning about how the growth of knowledge was traditionally understood and why that's wrong, and how we learn instead: through conjectures and refutations. When taken seriously, this chapter alone will allow you to refute much of present-day "AGI research."

    > Empiricism said that we derive it from sensory experience. This is false. The real source of our theories is conjecture, and the real source of our knowledge is conjecture alternating with criticism.

2.  Chapter 4: *Creation*

    The growth of knowledge is an evolutionary process. There is literally evolution happening in our minds. That means an AGI is an *evolutionary algorithm*. In this chapter, Deutsch explains the traditional misconceptions surrounding evolution, including creationism and Lamarckism, and lays out our current best explanation of evolution: neo-Darwinism.

    > [Both] human knowledge and biological adaptations are abstract replicators: forms of information which, once they are embodied in a suitable physical system, tend to remain so while most variants of them do not.

3.  Chapter 6: *The Jump to Universality*

    As Deutsch explains in this chapter, sometimes systems undergo a sudden change from being able to solve a narrow range of problems in a given domain to all of them. That's the *jump* to universality. Deutsch argues that AGI will be achieved in a similar jump. Current research programs aimed at gradual emulation of human abilities must fail for several reasons, and this is one of them.

    > All knowledge growth is by incremental improvement, but in many fields there comes a point when one of the incremental improvements in a system of knowledge or technology causes a sudden increase in reach, making it a universal system in the relevant domain.

4.  Chapter 7: *Artificial Creativity*

    This chapter is perhaps the most important of the AGI-related ones. Deutsch refutes the applicability of the Turing test and explains what the focus of research efforts should be: understanding how the mind works. The absence of this focus is also why there has been no progress in the field, Deutsch argues. Think artificial evolution has already been achieved? According to Deutsch, this is not the case, despite appearances.

    > The field of artificial (general) intelligence has made no progress because there is an unsolved philosophical problem at its heart: we do not understand how creativity works. Once that has been solved, programming it will not be difficult.

5.  Chapter 10: *A Dream of Socrates*

    In a beautiful, fictional dialog between Socrates and the Greek god Hermes, Deutsch masterfully explores the inner workings of the mind and explains that our experience is a "waking dream of reality":

    > *Our experience of the world is indeed a form of virtual-reality rendering which happens wholly inside the brain.*

6.  Chapter 16: *The Evolution of Creativity*

    Brains have no way of downloading ideas from other brains directly. Nor can minds acquire ideas through imitation, Deutsch argues citing Popper. But they *can* replicate memes through creativity. And, according to Deutsch, that is why our species exists.

    > Complex memes do not mandate specific bodily actions, but rules. We can see the actions, but not the rules, so how do we replicate them? We replicate them by creativity.

Read [*The Beginning of Infinity*](https://www.amazon.com/Beginning-Infinity-Explanations-Transform-World/dp/0670022756/) to learn more about AGI (and so much more). If you take the ideas seriously, I am confident you will know more than 90% of researchers in the field.

---
## [LDR-Siren/EmilyC-SamanthaPrater-EruzaArto@2b67e49efa...](https://github.com/LDR-Siren/EmilyC-SamanthaPrater-EruzaArto/commit/2b67e49efab81b6acea436c567f2d2307b92dbc0)
##### 2021-01-13 14:30:57 by LDR

Add files via upload

Here we go again. More James. Look if you read through this, James's words are in here. He doesn't bring her up unless she out right attacks his home and life. Most cases, we do not hear from him unless she sends the cops at him, or other people. Which she has done, she screams she doesn't but, she has. And no one in the Dibney Cru believes her lies. Because again, it has changed. Her story has changed again. It always does. She is back to screaming James knew her at 9. Lisa nixed that quickly and said no James didn't come into their lives till she was into her later years like 19teen 20 years old. So no one is believing her BS.

Hacked. Lord help us, we know she was not hacked. We have a lot of the proof that WillowtheWay or whatever the Willow name is, was not hacked. Because we found all of it. So again, its a load of BS. She does this, as one of the girls said in the discord, that she screams hacked when she is caught being abusive. Which is every day. 

We all know she is crazy but I want to bring up something I find hysterical. So she keeps bringing up her IQ. She has admitted that she had it done in her late teens and it was a Mensa score of 77... Yeah. At the height of when those tests are often taken, she scored a 77. Which makes her a moron. An idiot. Average is 85 to 95-120 depending on who you take the test through.  So again she is a moron. We are not calling her an Idiot because its an opinion, we are calling her an idiot because it is fact. Comparatively against many of us in the discord we run IQ scores from 95 to 162.  Mine is 132 which to give you an idea this is what that means 

"A score of 116 or more is considered above average. A score of 130 or higher signals a high IQ. Membership in Mensa, the High IQ society, includes people who score in the top 2 percent, which is usually 132 or higher." Jan 28, 2020 

Her score of 77 puts her here "70 to 84: Borderline mental disability." which we know. Also "Borderline intellectual functioning, also called borderline mental retardation (in the ICD-8), is a categorization of intelligence wherein a person has below average cognitive ability (generally an IQ of 70–85), but the deficit is not as severe as intellectual disability (below 70)." So not retarded, but not smart either.

We know for a fact, she googles everything, and often does not comprehend all she reads, twisting it to fit her narrative. We have seen it time and time again. I have seen it when she attacked me before the Dibney Cru was formed.  It is like a synapse is not firing right to allow her to comprehend what she is reading does not always apply to her or can be used by her. Take law for instance.

But I am rattling. Anyways. That is the past 24 hours.

---
## [xlab-si/xopera-opera@2584c4dfbc...](https://github.com/xlab-si/xopera-opera/commit/2584c4dfbc9eea67b350a9ab4e6a049aa51a7b1a)
##### 2021-01-13 19:16:24 by anzoman

Jingle all the way with opera tab completion

It's time to fulfil our quest that was desired to be done from times
of yore (#56). And since Christmas is about giving back and caring
about others, we decided to bring merry to all our users and enable
tab completion for opera CLI arguments.

One can almost get enchanted when looking at a CLI that has a
nice-working tab completion. Shell completion can be hard to
comprehend sometimes because there's many ways to support it.
Since opera uses argparse we had to find a tab completion package
that's compatible with it. The love on first sight would be
argcomplete Python package which was designed for completing argparse
commands and their arguments. However, when we tried it, it didn't turn
out so well. Most of the time we were unable to get it working with our
subparsers and on the other hand we didn't want to activate completion
globally. So we almost gave up with that. But then we remembered that
failure only happens when you give up. Hoper and determination fuel
the true champions. So we found shtab as a possible solution. The
package is still very young and some features will probably be worked
on in the future.

We were able to use shtab in our code to generate a shell completion
script. And we don't even need a separate command to do that since
shtab supports defining a global optional argument that will print
out the completion script for the main parser. We used that and
defined --shell-completion/-s flag which receives a shell type to
generate completion for. Shtab currently supports bash and zsh so those
are the options. So, after running `opera -s bash|zsh` the generated
tab completion script will be printed out. To activate it you must
source the contents which can be done with `eval "$(opera -s bash)"`
or you can save it to a file and then source it. The procedure will
be fully explained in the opera documentation.

First thoughts about tab completion also included a possibility to
pre-install it for the user. For that we would need to do the sourcing
within the installation. There was also a suggestion to have a
separate opera shell-completion command that would have a --install
switch to install tab completion on user's system. We didn't want to
upset the users by installing something into their environment that
they might not want. We also didn't want to modify their ~/.bashrc file
and add our completion as that could bring a lot of problems. At the
end, we  decided to just print out the generated completion script and
then the user can decide how to continue for himself.

The new completion feature will give aid to those opera users who seek
it. Since opera CLI is evolving and growing, new and new commands and
CLI options are being introduced. So it's easy to make a mistake while
you're using the CLI. And that's when tab completion comes in handy.

---
## [xlab-si/xopera-opera@afee592e22...](https://github.com/xlab-si/xopera-opera/commit/afee592e22b69acd26bbd58fbce9a52093380b5f)
##### 2021-01-13 19:20:02 by anzoman

Jingle all the way with opera tab completion

It's time to fulfil our quest that was desired to be done from times
of yore (#56). And since Christmas is about giving back and caring
about others, we decided to bring merry to all our users and enable
tab completion for opera CLI arguments.

One can almost get enchanted when looking at a CLI that has a
nice-working tab completion. Shell completion can be hard to
comprehend sometimes because there's many ways to support it.
Since opera uses argparse we had to find a tab completion package
that's compatible with it. The love on first sight would be
argcomplete Python package which was designed for completing argparse
commands and their arguments. However, when we tried it, it didn't turn
out so well. Most of the time we were unable to get it working with our
subparsers and on the other hand we didn't want to activate completion
globally. So we almost gave up with that. But then we remembered that
failure only happens when you give up. Hope and determination fuel
the true champions. So we found shtab as a possible solution. The
package is still very young and some features will probably be worked
on in the future.

We were able to use shtab in our code to generate a shell completion
script. And we don't even need a separate command to do that since
shtab supports defining a global optional argument that will print
out the completion script for the main parser. We used that and
defined --shell-completion/-s flag which receives a shell type to
generate completion for. Shtab currently supports bash and zsh so those
are the options. So, after running `opera -s bash|zsh` the generated
tab completion script will be printed out. To activate it you must
source the contents which can be done with `eval "$(opera -s bash)"`
or you can save it to a file and then source it. The procedure will
be fully explained in the opera documentation.

First thoughts about tab completion also included a possibility to
pre-install it for the user. For that we would need to do the sourcing
within the installation. There was also a suggestion to have a
separate opera shell-completion command that would have a --install
switch to install tab completion on user's system. We didn't want to
upset the users by installing something into their environment that
they might not want. We also didn't want to modify their ~/.bashrc file
and add our completion as that could bring a lot of problems. At the
end, we  decided to just print out the generated completion script and
then the user can decide how to continue for himself.

The new completion feature will give aid to those opera users who seek
it. Since opera CLI is evolving and growing, new and new commands and
CLI options are being introduced. So it's easy to make a mistake while
you're using the CLI. And that's when tab completion comes in handy.

---
## [SquidDev-CC/CC-Tweaked@1255bd00fd...](https://github.com/SquidDev-CC/CC-Tweaked/commit/1255bd00fd21247a50046020d7d9a396f66bc6bd)
##### 2021-01-13 22:26:38 by Jonathan Coates

Fix mounts being usable after a disk is ejected

This probably fails "responsible disclosure", but it's not an RCE and
frankly the whole bug is utterly hilarious so here we are...

It's possible to open a file on a disk drive and continue to read/write
to them after the disk has been removed:

    local disk = peripheral.find("drive")
    local input = fs.open(fs.combine(disk.getMountPath(), "stream"), "rb")
    local output = fs.open(fs.combine(disk.getMountPath(), "stream"), "wb")
    disk.ejectDisk()

    -- input/output can still be interacted with.

This is pretty amusing, as now it allows us to move the disk somewhere
else and repeat - we've now got a private tunnel which two computers can
use to communicate.

Fixing this is intuitively quite simple - just close any open files
belonging to this mount. However, this is where things get messy thanks
to the wonderful joy of how CC's streams are handled.

As things stand, the filesystem effectively does the following flow::
 - There is a function `open : String -> Channel' (file modes are
   irrelevant here).

 - Once a file is opened, we transform it into some <T extends
   Closeable>. This is, for instance, a BufferedReader.

 - We generate a "token" (i.e. FileSystemWrapper<T>), which we generate
   a week reference to and map it to a tuple of our Channel and T. If
   this token is ever garbage collected (someone forgot to call close()
   on a file), then we close our T and Channel.

 - This token and T are returned to the calling function, which then
   constructs a Lua object.

The problem here is that if we close the underlying Channel+T before the
Lua object calls .close(), then it won't know the underlying channel is
closed, and you get some pretty ugly errors (e.g. "Stream Closed"). So
we've moved the "is open" state into the FileSystemWrapper<T>.

The whole system is incredibly complex at this point, and I'd really
like to clean it up. Ideally we could treat the HandleGeneric as the
token instead - this way we could potentially also clean up
FileSystemWrapperMount.

BBut something to play with in the future, and not when it's 10:30pm.

---

All this wall of text, and this isn't the only bug I've found with disks
today :/.

---
## [Arthurb101/web-homework@0d92f91617...](https://github.com/Arthurb101/web-homework/commit/0d92f91617a7d298419dd1665ace8713867b3864)
##### 2021-01-13 23:37:02 by Tyler Hawkins

sorry for the long commit message I relaise this would have been easier with mutiple commits with the different parts of my code, like I would do in proffesional environment.
I havnt coded using pheonix before so I ended up breaking alot of things and just making everything work was an accomplishment in itself.

objectives:
frontend:
-added transaction modal to add transactions
-added a transaction table to show the transactions
-added bulma css library to give the site style and life
-added a UI and generated several graphql hooks to query and mutate the database
-added a currency rate functionality to allow user's to convert the currency in the transactions table. this uses an API to pull the latest currency conversion rates.
backend:
-added a method to seed the database useing seeds.ex file, however it only seeds companies, users, and merchants the UI should be used to create transactions
-added the companies schema
-added amount type in ./homework/transactions/amount to allow users to enter a transaction with decimals.

bonus:
-fixed the bug in transactions to allow users to add credit and update to credit. I resolved this bug by adding credit to the transactions changeset
-fixed; this may or may not be a bug but in elixir route you have it set up to accept requests from '/graphiql' but on the frontend apollo client you have it setup to
 request from '/graphql'

Notes:
elixir and graphql were fairly new to me so I may have done some things without using best practices or done in the hardest way. I did this project in elixir vs Node to show
that I'm a quick learner and not my experience with elixier, so keep that in mind. One last item I spent quite a bit of time on this project but can only spend so much time. So
there are alot of functionality missing from this project mainly error catching that I would always have on a production site, just keep that in mind. Other than that enjoy and
feel free to ask me question regarding this project when we chat.

---

# [<](2021-01-12.md) 2021-01-13 [>](2021-01-14.md)

