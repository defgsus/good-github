# [<](2021-02-26.md) 2021-02-27 [>](2021-02-28.md)

2,040,792 events, 1,156,965 push events, 1,664,734 commit messages, 105,886,453 characters


## [tburghart/otp@092584bb2e...](https://github.com/tburghart/otp/commit/092584bb2e0635bfbf73931c61c95d0b178caeb4)
##### 2021-02-27 00:00:34 by John Högberg

re: Document [:ascii:] character class deficiency

The regex library we use can work either in locale-specific mode,
or unicode mode. The locale-specific mode uses a pregenerated
table to tell which characters are printable, numeric, and so on.

For historical reasons, OTP has always used Latin-1 for this table,
so characters like `ö` are considered to be letters. This is fine,
but the library has two quirks that don't play well with each
other:

* The locale-specific table is always consulted for code points
  below 256 regardless of whether we're in unicode mode or not,
  and the `ucp` option only affects code points that aren't
  defined in this table (zeroed).
* The character class `[:ascii:]` matches characters that are
  defined in the above table.

This is fine when the regex library is built with its default ASCII
table: `[:ascii:]` only matches ASCII characters (by definition)
and the library documentation states that `ucp` is required to
match characters beyond that with `\w` and friends.

Unfortunately, we build the library with the Latin-1 table so
`[:ascii:]` matches Latin-1 characters instead, and we can't change
the table since we've documented that `\w` etc work fine with
Latin-1 characters, only requiring `ucp` for characters beyond
that.

At this point you might be thinking that this is a bug in how the
regex library handles `[:ascii:]`. Well, yes, POSIX says it should
match all code points between 0-127, but that's misleading since
it's only true for strict supersets of ASCII: should `[:ascii:]`
match 0x5C if the table is Shift-JIS? It would be just as wrong as
matching `ö`. :-(

Why not try to do the right thing and mark ASCII-compatibility for
each code point, since (for instance) 0x41 is `A` both in ASCII and
Shift-JIS? There's no way to ask a locale whether a code point
refers to the same character in ASCII, so the users would need to
manually go through the tables after generating them. Happy fun
times.

I've settled for documenting this mess since we can't fix this
on our end without breaking people's code, and there's not much
point in reporting this upstream since it'll either be misleading
or far too much work for the user, and PCRE-8.x is nearing the
very end of its life.

---
## [AllyTally/VVVVVV@83976016c7...](https://github.com/AllyTally/VVVVVV/commit/83976016c7d56f1d62429384277620720f7f272b)
##### 2021-02-27 16:12:48 by Misa

Refactor level dir listing to not use STL data marshalling

Note that level dir listing still uses plenty of STL (including the end
product - the `LevelMetaData` struct - which, for the purposes of 2.3,
is okay enough (2.4 should remove STL usage entirely)); it's just that
the initial act of iterating over the levels directory no longer takes
four or SIX(!!!) heap allocations (not counting reallocations and other
heap allocations this patch does not remove), and no longer does any
data marshalling.

Like text splitting, and binary blob extra indice grabbing, the current
approach that FILESYSTEM_getLevelDirFileNames() uses is a temporary
std::vector of std::strings as a middleman to store all the filenames,
and the game iterates over that std::vector to grab each level metadata.
Except, it's even worse in this case, because PHYSFS_enumerateFiles()
ALREADY does a heap allocation. Oh, and
FILESYSTEM_getLevelDirFileNames() gets called two or three times. Yeah,
let me explain:

1. FILESYSTEM_getLevelDirFileNames() calls PHYSFS_enumerateFiles().

2. PHYSFS_enumerateFiles() allocates an array of pointers to arrays of
   chars on the heap. For each filename, it will:

   a. Allocate an array of chars for the filename.

   b. Reallocate the array of pointers to add the pointer to the above
      char array.

      (In this step, it also inserts the filename in alphabetically -
      without any further allocations, as far as I know - but this is a
      COMPLETELY unnecessary step, because we are going to sort the list
      of levels by ourselves via the metadata title in the end anyways.)

3. FILESYSTEM_getLevelDirFileNames() iterates over the PhysFS list, and
   allocates an std::vector on the heap to shove the list into. Then,
   for each filename, it will:

   a. Allocate an std::string, initialized to "levels/".

   b. Append the filename to the std::string above. This will most
      likely require a re-allocation.

   c. Duplicate the std::string - which requires allocating more memory
      again - to put it into the std::vector.

      (Compared to the PhysFS list above, the std::vector does less
      reallocations; it however will still end up reallocating a certain
      amount of times in the end.)

4. FILESYSTEM_getLevelDirFileNames() will free the PhysFS list.

5. Then to get the std::vector<std::string> back to the caller, we end
   up having to reallocate the std::vector again - reallocating every
   single std::string inside it, too - to give it back to the caller.

And to top it all off, FILESYSTEM_getLevelDirFileNames() is guaranteed
to either be called two times, or three times. This is because
editorclass::getDirectoryData() will call editorclass::loadZips(), which
will unconditionally call FILESYSTEM_getLevelDirFileNames(), then call
it AGAIN if a zip was found. Then once the function returns,
getDirectoryData() will still unconditionally call
FILESYSTEM_getLevelDirFileNames(). This smells like someone bolting
something on without regard for the whole picture of the system, but
whatever; I can clean up their mess just fine.

So, what do I do about this? Well, just like I did with text splitting
and binary blob extras, make the final for-loop - the one that does the
actual metadata parsing - more immediate.

So how do I do that? Well, PhysFS has a function named
PHYSFS_enumerate(). PHYSFS_enumerateFiles(), in fact, uses this function
internally, and is basically just a wrapper with some allocation and
alphabetization.

PHYSFS_enumerate() takes in a pointer to a function, which it will call
for every single entry that it iterates over. It also lets you pass in
another arbitrary pointer that it leaves alone, which I use to pass
through a function pointer that is the actual callback.

So to clarify, there are two callbacks - one callback is passed through
into another callback that gets passed through to PHYSFS_enumerate().

The callback that gets passed to PHYSFS_enumerate() is always the same,
but the callback that gets passed through the callback can be different
(if you look at the calling code, you can see that one caller passes
through a normal level metadata callback; the other passes through a zip
file callback).

Furthermore, I've also cleaned it up so that if editorclass::loadZips()
finds a zip file, it won't iterate over all the files in the levels
directory a third time. Instead, the level directory only gets iterated
over twice - once to check for zips, and another to load every level
plus all zips; the second time is when all the heap allocations happen.

And with that, level list loading now uses less STL templated stuff and
much less heap allocations.

Also, ed.directoryList basically has no reason to exist other than being
a temporary std::vector, so I've removed it. This further decreases
memory usage, depending on how many levels you have in your levels
folder (I know that I usually have a lot and don't really ever clean it
up, lol).

Lastly, in the callback passed to PhysFS, `builtLocation` is actually no
longer hardcoded to just the `levels` directory, since instead we now
use the `origdir` variable that PhysFS passes us. So that's good, too.

---
## [crawl/crawl@b9714ae4ff...](https://github.com/crawl/crawl/commit/b9714ae4ffb485d0aa57cb81685dab814fc5f86d)
##### 2021-02-27 16:30:57 by Edgar A. Bering IV

Reforge the Chains VII: Grouped skill bonuses

After initial playtesting feedback, completely random skills had some
interesting upsides (when the stars aligned and a triply-cursed skill
could also be utlized it was a good moment) they were also frustrating
and had bad gamefeel:

- multiple melee skills when a player is probably only using one (maybe
  two)
- hard to roll relevant magic skills
- occasionally taking a "useless" or "not that useful" curse was fun but
  it was happening too often.

This commit changes the skill bonuses to be granted in the following
skill groupings, more fine grained than the old ash skill categories but
not as broad as totally random skilling:

Melee: all melee combat skills
Ranged: all ranged combat skills
Fortitude: Armour and Shields
Cunning: Dodging and Stealth
Elements: Air, Earth, Fire, and Ice Magic
Alchemy: Transmutations and Poison Magic
Beguiling: Conjurations, Hexes, and Translocations
Companions: Necromancy and Summonings
Self: Fighting and Spellcasting
Evocations: Evocations.

Each curse offers two out of these ten categories chosen at random and
without weight. This will hopefully allieviate some of the bad feelings
from totally random skill boosts while retaining the character shaping
aspects of the narrower bonus granting.

In lieu of save compatibility, since this has only been live on trunk
briefly, this commit just switches to a new prop key for the new curses.

---
## [VOREStation/VOREStation@fc91485466...](https://github.com/VOREStation/VOREStation/commit/fc91485466cb1b6be160150b67edefc31d8f5737)
##### 2021-02-27 18:23:17 by Wickedtemp

ML3M Rebalancing

Originally, the ML3M was intended to be a little bit stronger. The healing values for the Brute, Burn, Omni, Toxin, and Antirad cells, have been adjusted according to what was initially planned. 
Base Tier's now heal 10 per shot, for a total of 40 damage healed, up from 20.
Second Tier's now heal 20, instead of 10.
Third Tier's heal 40, instead of 20. 

Omni 1 heals 5's for brute, burn, and toxin, and 30 for oxy, up from half those values. Omni 2, is 10's and 60, and Omni 3 is 20's and 120. 

Antirad Cell had its toxin heal bumped up from 2.5 to 5, and its radiation-heal from 150, to 350. I wasn't originally going to touch this one, but the text said "It's 150 because that's equal to five units of arithrazine", and... it wasn't. So, I bumped it up to actually be equal to 5u of Arithrazine's worth of radiation healing.

Stabilizer Cell, CorpseMend, Resistance, Haste, and the size-changing cells, were not touched.
The reasons for this are as follows:

- The healing laser was simply not strong enough to ever tend to more than one patient. Healing 20-40 damage per cell just isn't enough, even if you had several clips full of cells, it just wasn't viable.
- As a result of this, it was seldom if ever used. Field Medics rarely if ever took it with them. In nearly every round I've played, it was left exactly where it was spawned, collecting dust. 
- I'd like to make it a more proper treatment option. It wouldn't be equal to reagents used in your usual Medbay setting, or surgical repair, but if it's modified to actually fulfill its niche as a rapid, contact-free treatment option, it could be relied on more by Field Medics. There is so much potential for this device as an "in the field" healing tool, and I'd like to see it done well. We have no shortage of people who would like to see non-chemical-based treatment options. We might as well make it useful enough to actually use.

Here are a few issues people brought up in Discord when I floated this idea.
"But, Tempest, you're doubling everything? That's a huge change! Won't this result in the ML3M overshadowing other treatment options?"
Certainly not. Currently, with tier-2 cells that only heal up to 40 damage, this is actually worse than basic first-aid in terms of raw healing ability, as the cutoff for first aid healing is 50 damage on a limb. First aid and reagents will still be the most convenient, most readily available, and overall most-used manner of treatment for injuries that can be treated using those methods. All this change would do is allow the ML3M to also have its uses, and stop being overshadowed by everything else. 

"Okay, but what if it DOES actually become The New Meta and becomes the favored tool for healing?"
I wouldn't see it as an issue if Chemistry gets dethroned, in all honesty. They'd both take quite a bit of prep-work to use. You have to make multiples of every chem if you want a solid stock, and you'd need multiples of every cell if you want proper coverage and healing-ability, since even with these changes you're expending 1-3 cells per patient. And, unless you get multiple ML3M's made, only folks who are gonna have one are the CMO, and whoever nabs the spawned one first. 

"But wouldn't this result in less departmental cooperation between Medical and Science now that Medical will require fewer cells?"
Most likely, no. If anything, I'd think there would be an increase, round-to-round, if this becomes a more viable and wanted tool, more people will ask for cells. Personally, my list of requested cells would stay the same, but I'd be sending that request in more often since I know it'll actually be useful rather than having it just to have it. Tier 2 cells are still going to be desirable, and I'm still probably not going to order Tier 3's because of the cost, but that's just me. It's still going to be incredibly weak at roundstart, and better cells will be that much nicer to obtain.

"But Tempest! If you get the highest tiers of cells, and a lot of them, you could fix anything that doesn't require surgery!"
Well, if Science had the time and mats, then sure, you could gather up a large enough collection of cells, and you probably could indeed do this for one or two badly injured patients... ... ...and I could accomplish the same goal if I'm given 20 seconds in a chem-lab. The ML3M is more costly to use, the cells cost resources, have to be recharged after 4 shots, and you only start with a base tier Burn, Brute, and Stabilizer cell. Each shot from a base level burn/brute cell is the equivalent of 1.25u of bicaridine or kelotane. This change would make it 2.5. Base level cells are still going to be next to useless for anything other than the most minor of injuries. Chemistry will still be the dominating powerhouse it always has been, but at least you can use this tool, provided the PR goes through, instead, more often.

"Tempest, this thing just wasn't intended to be used to fully heal people..."
A couple people have said this, and to be honest, it's silly. In our medical system, there's very little distinction between what can "heal a little bit" and what can "heal fully", because it all comes down to the fact that everything works off of damage values. If Option A heals 5 damage, and Option B heals 50... Both are capable of "healing fully" if you have enough Option A, it's just a question as to whether or not that's practical. Currently, the ML3M's healing values can't really even be used to even partially heal injuries, unless you have a large number of cells. You'd expend all of your charges on one patient and then you've got a paperweight taking up storage space until you can get to a recharger. 

Now, as for issues that I personally see? Biggest one is probably the Toxin cell. If I remlember correctly, the base Toxin cell is the same tech requirement as the Second Tier Brute/Burn cells. This PR doesn't fix that, and I don't really see it as a huge priority since I don't think anyone uses the toxin cells as it is, but yeah. Might need to be fixed at some point if this PR goes through.

And, absolute worst case scenario, let's say that this PR screws everything up, turns the Tether upside down, and now Medbay is dominated by a bunch of blue laser beams flying everywhere like it's the new Star Wars Trilogy (but actually better because those movies kinda set a low bar)... this PR was really easy to do. The only long part about it was typing all of this up. We can just bump the numbers down if this ends up sucking really bad, ezpz.

Thank you for coming to my ted talk.

---
## [al1216/ydms_HackVerse2.0@f1be5f286f...](https://github.com/al1216/ydms_HackVerse2.0/commit/f1be5f286ff7ce1fc6fdd4592dda56537fe12921)
##### 2021-02-27 20:05:07 by Aditya Kumar Gupta

Add files via upload

Title of the hack - YOUR DATABASE MANAGEMENT SYSTEM

Description-
1) While taking into the consideration the impact of this cute, sweet project on society that each person can make a track of his daily routine essential works such as learning coding, dieting, earning money (each day), physical fitness, one's knowledge each day with date. Anyone can keep track of it and improve themselves as they want in any spheres of their life.
2) in this hack , I (the admin) makes contribution on writing the codes in "frontend.py" and structuring the website (using HTML) in which we are going to host the our code and output of each option we created in our Project.
My teammate Himanshu handles the coding in "backend.py" and beautifying our website using CSS and Bootstrap and makes his fabulous contribution in this project.
3) The main challenges we face is to connect frontend and backend, and deleting the records if user wants to delete it. But soon after we both are able to figure it out  the bug and did what we planned successfully.
4) The system design implementation includes tkinter and sqlite3 with Python Coding. We basically connects the frontend and backend using connect() command and stores the information in rountine.db for later use. We try to make it as sweet and cute as possible. 

Tech stack used in the hack- 
Python, tkinter, sqlite3

Libraries and dependencies-
module- tkinter and sqlite3

Installation steps: -
just install 3 files given namely "frontend.py", "backend.py" and "routine.db" and run in any preferred idle such as Visual Studio Code, Pythons'Idle etc.
After installing just enter the information that asked there and select "ADD" button or you if you entered wrong details just select "Delete date" or want to search something select "Search" with anyone of the field you want and enjoy our project.

---

# [<](2021-02-26.md) 2021-02-27 [>](2021-02-28.md)

