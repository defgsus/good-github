# [<](2021-03-10.md) 2021-03-11 [>](2021-03-12.md)

3,652,220 events, 1,636,956 push events, 2,562,051 commit messages, 191,735,452 characters


## [neoJINXD/MilleniumArts@34d7fb91f6...](https://github.com/neoJINXD/MilleniumArts/commit/34d7fb91f6d074138fd6c7d42021e0a206dcb9f3)
##### 2021-03-11 02:17:56 by neoJINXD

god fucking damnit unity stop changing my settings :hkStare:

---
## [deepwaterooo/KCWangSherryWang@5daceae0b1...](https://github.com/deepwaterooo/KCWangSherryWang/commit/5daceae0b19cfc4cddc4e9b39edaff1404594ccd)
##### 2021-03-11 04:59:11 by deepwaterooo

KC Wang\'s evil: He chose to cooperate with dark cycle from the very beginning and cheated me from the very beginning while he abnormally dialed 911 to hurt others He own me an apologize for ever during his rest of life

---
## [isvilen/otp@092584bb2e...](https://github.com/isvilen/otp/commit/092584bb2e0635bfbf73931c61c95d0b178caeb4)
##### 2021-03-11 10:35:47 by John Högberg

re: Document [:ascii:] character class deficiency

The regex library we use can work either in locale-specific mode,
or unicode mode. The locale-specific mode uses a pregenerated
table to tell which characters are printable, numeric, and so on.

For historical reasons, OTP has always used Latin-1 for this table,
so characters like `ö` are considered to be letters. This is fine,
but the library has two quirks that don't play well with each
other:

* The locale-specific table is always consulted for code points
  below 256 regardless of whether we're in unicode mode or not,
  and the `ucp` option only affects code points that aren't
  defined in this table (zeroed).
* The character class `[:ascii:]` matches characters that are
  defined in the above table.

This is fine when the regex library is built with its default ASCII
table: `[:ascii:]` only matches ASCII characters (by definition)
and the library documentation states that `ucp` is required to
match characters beyond that with `\w` and friends.

Unfortunately, we build the library with the Latin-1 table so
`[:ascii:]` matches Latin-1 characters instead, and we can't change
the table since we've documented that `\w` etc work fine with
Latin-1 characters, only requiring `ucp` for characters beyond
that.

At this point you might be thinking that this is a bug in how the
regex library handles `[:ascii:]`. Well, yes, POSIX says it should
match all code points between 0-127, but that's misleading since
it's only true for strict supersets of ASCII: should `[:ascii:]`
match 0x5C if the table is Shift-JIS? It would be just as wrong as
matching `ö`. :-(

Why not try to do the right thing and mark ASCII-compatibility for
each code point, since (for instance) 0x41 is `A` both in ASCII and
Shift-JIS? There's no way to ask a locale whether a code point
refers to the same character in ASCII, so the users would need to
manually go through the tables after generating them. Happy fun
times.

I've settled for documenting this mess since we can't fix this
on our end without breaking people's code, and there's not much
point in reporting this upstream since it'll either be misleading
or far too much work for the user, and PCRE-8.x is nearing the
very end of its life.

---
## [mrakgr/The-Spiral-Language@f02c1d1121...](https://github.com/mrakgr/The-Spiral-Language/commit/f02c1d11216a83eb0525da38245e31f2da216c09)
##### 2021-03-11 10:36:41 by Marko Grdinić

"9:10am. I am up. This morning I've been thinking about incremental partial evaluation, and I've elaborated my previous scheme for it. I can see it more clearly now.

Yeah, it is all easy. Spiral is essentially done and nothing will stop me from enjoying its benefits.

9:15am. If I drop dead ahead of schedule, I can rest assured that somebody will take the baton. Join points will live on in perpetuity.

As strange as it sounds, this was always one of my motivations.

Now that I've come to this point, I can finally pursue more selfish goals.

9:20am. Now if only the Internet would come back online.

...It is not coming back no matter how much I fiddle. Sigh. Imagine if this happened while my agents were trying to play online poker in the background. What will I do about this? I have no idea. Is there anything I can do?

9:25am. Forget this. Let me see if I can get some work done in the morning. I really hate to do this so forcefully, but I have no choice.

* Update the `PackageEnv` after validating the `SchemaEnv` based on the order.
* Do the schema loader.
* Update the mirror graph based on the order.

I have the key functions for the first one.

9:35pm.

```fs
    let modules pid =
        let x = modules.[pid]
        let state = proj_file_get_input x.files.uids_file x.files.files
        fun mid path -> pid, mid, path, state.[path]
```

Oh, it is interesting that mid here is a generic parameter. This gave trouble before.

9:40am.

```fs
let inline dirty_nodes_template funs (ids : Map<string, PackageId>) (packages : SchemaEnv) modules
        (state : Map<PackageId,_>) (dirty_packages : string HashSet) =
    let d = Dictionary<string,_ [] * ProjFiles>()
    dirty_packages |> Seq.iter (fun path ->
        let pid = ids.[path]
        match Map.tryFind pid state with
        | Some x ->
            let modules = modules pid
            let files = proj_file_from_schema packages.[path].schema
            let state =
                let state = proj_file_get_input x.files.uids_file x.files.files
                proj_file_make_input (fun mid path ->
                    match state.TryGetValue(path) with
                    | true, x -> wdiff_file_update_input funs x (modules mid path)
                    | false, _ -> funs.init (modules mid path)
                    ) files
            d.Add(path,(state,files))
        | None ->
            ()
        )
    d

let dirty_nodes_tc (ids : Map<string, PackageId>) (packages : SchemaEnv) (modules : ModuleEnv)
        (state : Map<PackageId,ProjStateTC>) (dirty_packages : string HashSet) =
    dirty_nodes_template file_tc_funs ids packages (fun pid mid path -> pid, mid, modules.[path].bundler) state dirty_packages

open WDiff.Prepass
let dirty_nodes_prepass (ids : Map<string, PackageId>) (packages : SchemaEnv) (modules : Map<PackageId,ProjStateTC>)
        (state : Map<PackageId,ProjStatePrepass>) (dirty_packages : string HashSet) =
    let modules pid =
        let x = modules.[pid]
        let state = proj_file_get_input x.files.uids_file x.files.files
        fun (mid : ModuleId) path -> pid, mid, path, state.[path].result
    dirty_nodes_template file_prepass_funs ids packages modules state dirty_packages
```

The internet came back, but now I am into it. I'll leave chilling for the break.

9:45am. I feel like slacking. Let me do that update function and then I will do so.

10:05am.

```fs
let wdiff_projenvr_update_packages_tc ids packages modules (state : ResultMap<PackageId,_>) (dirty_packages, order) =
    let state = wdiff_projenvr_sync_schema funs_proj_package_tc funs_proj_file_tc ids packages state order
    let dirty_packages = dirty_nodes_tc ids packages modules state.ok dirty_packages
    {state with ok=projenv_update_packages funs_proj_package_tc funs_proj_file_tc ids packages state.ok (dirty_packages, order)}
```

With this the bullet point has finally been resolved.

Let me chill.

10:45am. Let me start.

* Update the `PackageEnv` after validating the `SchemaEnv` based on the order.
* Do the schema loader.
* Update the mirror graph based on the order.

```fs
let wdiff_projenvr_update_packages_tc ids packages modules (state : ResultMap<PackageId,_>) (dirty_packages, order) =
    let state = wdiff_projenvr_sync_schema funs_proj_package_tc funs_proj_file_tc ids packages state order
    let dirty_packages = dirty_nodes_tc ids packages modules state.ok dirty_packages
    {state with ok=projenv_update_packages funs_proj_package_tc funs_proj_file_tc ids packages state.ok (dirty_packages, order)}

let wdiff_projenvr_update_packages_prepass ids packages modules (state : ResultMap<PackageId,_>) (dirty_packages, order) =
    let state = wdiff_projenvr_sync_schema funs_proj_package_prepass funs_proj_file_prepass ids packages state order
    let dirty_packages = dirty_nodes_prepass ids packages modules state.ok dirty_packages
    {state with ok=projenv_update_packages funs_proj_package_prepass funs_proj_file_prepass ids packages state.ok (dirty_packages, order)}
```

Should I do it like this, or should I abstract more?

```fs
let wdiff_projenvr_update_packages dirty_nodes funs_proj_package funs_proj_file
        ids packages modules (state : ResultMap<PackageId,_>) (dirty_packages, order) =
    let state = wdiff_projenvr_sync_schema funs_proj_package funs_proj_file ids packages state order
    let dirty_packages = dirty_nodes ids packages modules state.ok dirty_packages
    {state with ok=projenv_update_packages funs_proj_package funs_proj_file ids packages state.ok (dirty_packages, order)}

let wdiff_projenvr_update_packages_tc ids packages modules state (dirty_packages, order) =
    wdiff_projenvr_update_packages dirty_nodes_tc funs_proj_package_tc funs_proj_file_tc
        ids packages modules state (dirty_packages, order)

let wdiff_projenvr_update_packages_prepass ids packages modules state (dirty_packages, order) =
    wdiff_projenvr_update_packages dirty_nodes_prepass funs_proj_package_prepass funs_proj_file_prepass
        ids packages modules state (dirty_packages, order)
```

Abstract more. I had not counted on using a ResultMap for the prepass, but it is fine. The more code I reuse, the easier it will be to maintain.

* Update the `PackageEnv` after validating the `SchemaEnv` based on the order.
* Do the schema loader.
* Update the mirror graph based on the order.

With this, the first bullet point is done.

```fs
let wdiff_projenv_update_module funs_packages funs_files (s : Map<PackageId,ProjState<'file_input,'file,'state>>) (uid,x,tail) =
    let s = Map.add uid (wdiff_proj_update_files funs_packages funs_files s.[uid] x) s
    Array.fold (fun s (uid,l) ->
        let l = l |> List.map (fun (a,b) -> a, (Map.find b s).result)
        Map.add uid (wdiff_proj_update_packages funs_packages funs_files s.[uid] l) s
        ) s tail
```

I'll probably never get a chance to use this. Let me just comment it out.

```fs
// TODO: Make a version for updating just a single file.
```

I'll also get rid of this comment. Who feels like optimizing single file updates. Not me.

Here is the overall plan for what happens on the package side. This is my mental model of it.

1) `.spiproj` file gets parsed into a `Schema`.
2) It gets loaded along with its dependent modules and packages
3) They got converted to `SchemaState`, validated and moved into their relevant env.
4) Typechecker envs get updated.
5) That gets sent to the attention server.

When a single module is changed or opened, things are similar, except there is an extra step of loading the parent proj file.

I have that first point done. The third point is done as well. And I just got the fourth one dealt with.

The attention server will come last.

Now I have to deal with the loading of packages and modules.

Hmmm...what about updating the mirrored graph? The dirty packages are easy, but what should the order be based on? The pre update or post update? When should the update be done?

...

The update should be done between steps 2 and 3. And the order should be based on the post update. Package changes shouldn't affect the reverse links, not unless they are recursive. And that is the erroneous case that will take care of itself.

Updating the graph won't be hard. Let me just focus on loading the packages for today.

11:20am. Writing the above out has made me realize that I am further along than I though I was. I am probably between 60-70% finished.

Let me take a look at the package loader from the previous time.

```fs
let package_update errors (s : SupervisorState) package_dir text =
    let queue : LoadResult Task Queue = Queue()
    let rec load_module package_dir s l =
        List.fold (fun s -> function
            | FileHierarchy'.File((r, path as p),name,exists) ->
                match Map.tryFind path s.modules with
                | Some _ -> if exists then s else {s with modules = Map.remove path s.modules}
                | None ->
                    if exists then
                        File.ReadAllTextAsync(path).ContinueWith(fun (x : _ Task) ->
                            try let uri = Utils.file_uri path
                                let x = (module' (tokenizer_error errors uri) (parser_error errors uri) (is_top_down path)).Run(DocumentAll(Utils.lines x.Result))
                                LoadModule(package_dir,p,Ok(x))
                            with e -> LoadModule(package_dir,p,Error e.Message)
                            ) |> queue.Enqueue
                    s
            | FileHierarchy'.Directory(name,l) ->
                load_module package_dir s l
            ) s l

    let load_package s package_dir text =
        match Map.tryFind package_dir s.packages.intra_schemas, text with
        | _, Some text -> // Parse and validate the schema using the provided string.
            Task.Run(fun () -> LoadPackage(package_dir, Ok(schema_parse_then_validate package_dir text)))
            |> queue.Enqueue
            s
        | Some(Ok x), None -> // Rather than reloading from disk, just revalidate it.
            Task.Run(fun () -> LoadPackage(package_dir, Ok(schema_validate package_dir x.schema)))
            |> queue.Enqueue
            s
        | _ -> // Load from disk and validate it.
            let p = Path.Combine(package_dir,"package.spiproj")
            if File.Exists(p) then
                File.ReadAllTextAsync(p).ContinueWith(fun (x : _ Task) ->
                    try LoadPackage(package_dir, Ok(schema_parse_then_validate package_dir x.Result))
                    with e -> LoadPackage(package_dir, Error e.Message)
                    ) |> queue.Enqueue
                s
            else {s with packages={s.packages with intra_schemas=Map.add package_dir (Error "The package file does not exist.") s.packages.intra_schemas}}

    let main (s : SupervisorState) = function
        | LoadPackage(dir,x) ->
            let s = {s with packages={s.packages with intra_schemas=Map.add dir x s.packages.intra_schemas}}
            match x with
            | Ok x -> List.fold (fun s (r,x) -> load_package s x None) (load_module dir s x.files) x.packages
            | Error _ -> s
        | LoadModule(_,(_,path),Ok x) -> {s with modules=Map.add path x s.modules}
        | LoadModule(package_dir,(r,_),Error er) ->
            match Map.tryFind package_dir s.packages.intra_schemas with
            | Some (Ok x) -> {s with packages={s.packages with intra_schemas=Map.add package_dir (Ok {x with errors = (r,er) :: x.errors}) s.packages.intra_schemas}}
            | _ -> failwith "Compiler error: The package should be present and valid in the map."

    let mutable s = load_package s package_dir text
    while 0 < queue.Count do s <- main s (queue.Dequeue().Result)
    s
```

11:30am. Maybe I made a mistake turning on that router as I am just getting distracted by browsing on the side. But right now, let me have that breakfast.

The above thing really is as complicated as it appears. The above is definitely amateur quality code. Everything is bound together and intervowen."

---
## [JJawesomeJJ/jjawesome-3d@701eed3b5c...](https://github.com/JJawesomeJJ/jjawesome-3d/commit/701eed3b5cce87830d1794e4cae95b4c8ff5a4da)
##### 2021-03-11 13:02:51 by zhaolijie

-water----normal life --
--single life how long will continue
--No mater how sadness of the life remember you are petty unique boy
--fight young man the futher may be darkness but don't be fear,remember the beauty will always wait for you in the some which is not far away --2020-12-15

---
## [lowpez/wordpress-themeforest@85f3e5bcc1...](https://github.com/lowpez/wordpress-themeforest/commit/85f3e5bcc1ee5c7ef19216241b3e5fb64903f22c)
##### 2021-03-11 13:03:17 by lowpez

AppArt - Creative WordPress Theme For Apps Saas 

AppArt Creative App Landing WordPress Theme. It is 100% responsive and looks stunning on all types of screens and devices. You can use Appart as a better way to present and promote your start-up mobile apps, saas applications, software, digital products. Users will love your site because it gives them a unique user experience (UX), clean, modern & beautiful design

---
## [deepwaterooo/KCWangSherryWang@fc58f4e131...](https://github.com/deepwaterooo/KCWangSherryWang/commit/fc58f4e131cb7af93ff6b3bbe08e45a9e7517fb7)
##### 2021-03-11 17:17:37 by deepwaterooo

KC Wang's evil: He chose to cooperate with dark cycle from the very beginning and cheated me from the very beginning while he abnormally dialed 911 to hurt others on propose He own me an forever apology forever during his rest of life

---
## [PotatoDevices/kernel_oneplus_onyx@1e75fe16f5...](https://github.com/PotatoDevices/kernel_oneplus_onyx/commit/1e75fe16f58bf1f8f3c5364149b7379d28397d57)
##### 2021-03-11 19:15:51 by Michal Hocko

proc, oom: drop bogus task_lock and mm check

Series "Handle oom bypass more gracefully", V5

The following 10 patches should put some order to very rare cases of mm
shared between processes and make the paths which bypass the oom killer
oom reapable and therefore much more reliable finally.  Even though mm
shared outside of thread group is rare (either vforked tasks for a short
period, use_mm by kernel threads or exotic thread model of
clone(CLONE_VM) without CLONE_SIGHAND) it is better to cover them.  Not
only it makes the current oom killer logic quite hard to follow and
reason about it can lead to weird corner cases.  E.g.  it is possible to
select an oom victim which shares the mm with unkillable process or
bypass the oom killer even when other processes sharing the mm are still
alive and other weird cases.

Patch 1 drops bogus task_lock and mm check from oom_{score_}adj_write.
This can be considered a bug fix with a low impact as nobody has noticed
for years.

Patch 2 drops sighand lock because it is not needed anymore as pointed
by Oleg.

Patch 3 is a clean up of oom_score_adj handling and a preparatory work
for later patches.

Patch 4 enforces oom_adj_score to be consistent between processes
sharing the mm to behave consistently with the regular thread groups.
This can be considered a user visible behavior change because one thread
group updating oom_score_adj will affect others which share the same mm
via clone(CLONE_VM).  I argue that this should be acceptable because we
already have the same behavior for threads in the same thread group and
sharing the mm without signal struct is just a different model of
threading.  This is probably the most controversial part of the series,
I would like to find some consensus here.  There were some suggestions
to hook some counter/oom_score_adj into the mm_struct but I feel that
this is not necessary right now and we can rely on proc handler +
oom_kill_process to DTRT.  I can be convinced otherwise but I strongly
think that whatever we do the userspace has to have a way to see the
current oom priority as consistently as possible.

Patch 5 makes sure that no vforked task is selected if it is sharing the
mm with oom unkillable task.

Patch 6 ensures that all user tasks sharing the mm are killed which in
turn makes sure that all oom victims are oom reapable.

Patch 7 guarantees that task_will_free_mem will always imply reapable
bypass of the oom killer.

Patch 8 is new in this version and it addresses an issue pointed out by
0-day OOM report where an oom victim was reaped several times.

Patch 9 puts an upper bound on how many times oom_reaper tries to reap a
task and hides it from the oom killer to move on when no progress can be
made.  This will give an upper bound to how long an oom_reapable task
can block the oom killer from selecting another victim if the oom_reaper
is not able to reap the victim.

Patch 10 tries to plug the (hopefully) last hole when we can still lock
up when the oom victim is shared with oom unkillable tasks (kthreads and
global init).  We just try to be best effort in that case and rather
fallback to kill something else than risk a lockup.

This patch (of 10):

Both oom_adj_write and oom_score_adj_write are using task_lock, check for
task->mm and fail if it is NULL.  This is not needed because the
oom_score_adj is per signal struct so we do not need mm at all.  The code
has been introduced by 3d5992d2ac7d ("oom: add per-mm oom disable count")
but we do not do per-mm oom disable since c9f01245b6a7 ("oom: remove
oom_disable_count").

The task->mm check is even not correct because the current thread might
have exited but the thread group might be still alive - e.g.  thread group
leader would lead that echo $VAL > /proc/pid/oom_score_adj would always
fail with EINVAL while /proc/pid/task/$other_tid/oom_score_adj would
succeed.  This is unexpected at best.

Remove the lock along with the check to fix the unexpected behavior and
also because there is not real need for the lock in the first place.

Link: http://lkml.kernel.org/r/1466426628-15074-2-git-send-email-mhocko@kernel.org
Signed-off-by: Michal Hocko <mhocko@suse.com>
Reviewed-by: Vladimir Davydov <vdavydov@virtuozzo.com>
Acked-by: Oleg Nesterov <oleg@redhat.com>
Cc: David Rientjes <rientjes@google.com>
Cc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Change-Id: Id5b29755e8dbc70fc104263e207bb54de5eeb6ee

---
## [sahajsinghsachdeva/FnCMart@a6f84ac1a5...](https://github.com/sahajsinghsachdeva/FnCMart/commit/a6f84ac1a5a7d268f2a50a2fabbaa5cd23ba5282)
##### 2021-03-11 20:09:00 by sahajsinghsachdeva

Love you code!! Don't be like Jerry, I cant run behind you for fixing your fucking shit. Footer

---
## [CrashCringle12/Simply-Love-SM5@a9156fbdaf...](https://github.com/CrashCringle12/Simply-Love-SM5/commit/a9156fbdaf76e847f0b7b765e518b2c8b76a59f0)
##### 2021-03-11 20:37:24 by Lamar Cooley

Seems we've reached an Impasse

The point before point of no return. I've mixed feelings about proceeding from here. You finally beat the game, but are you sure you want to go to NewGame+? No no.... You've finally finished the first chapter of the main quest, but proceeding any futher in the story will take you to a new area. Are you sure you wish to leave? Your favorite show has ended and it holds a great amount of nostalgia in your heart. The spin off airs now, but part of you worries.

I think, I think this is a good spot to remain for now.

This is a completely exaggerated example of the moral dilemma
https://youtu.be/ks5DFEwZoHw?t=472

Can't quite remember everything about the episode but I remember this part at 7:52. While the Krusty Krab technically by modern standards is "better", I mean look at all the cool new stuff it has: Omg a freaking pool table? Sign me up. And I mean it is also a lot more efficient. They're able to pump out patties left and right and they've got the automated cash register. Putting the overt grossness of the patties aside (as i'm sure that's not the case here) that is pretending that the patties taste fine if not better. Well actually either way, the customer's are content. But it still just feels off. Where's the Love? Love truly is something magical and I think it's an important ingredient to any truly great product. This is more of an extreme dystpoian fear of things down the line. I hope that love is included in every commit.

Anywho, will I proceed from here? Mmm possibly eventually? Perhaps if there's some grand new feature that twiddles my heartstrings. But not knowing the folks reduces my immediate trust, this is probably something I should always do but i'll probs hold off on blindly merging beta builds. Eh I'm starting to ramble now.

We'll see what happens from here I suppose. Even if I become an SL-Boomer, I think tho whoever replaces me will likely eventually continue regardless of I stopped or not. Rightfully so. For now, in grand conclusion, we'll be resting here for a decent bit.

---

# [<](2021-03-10.md) 2021-03-11 [>](2021-03-12.md)

