# [<](2021-01-07.md) 2021-01-08 [>](2021-01-09.md)

2,595,468 events, 1,324,338 push events, 2,091,069 commit messages, 165,067,031 characters


## [Mojave-Sun/mojave-sun-13@cbf69db2da...](https://github.com/Mojave-Sun/mojave-sun-13/commit/cbf69db2da7c0fa99a7dd4bde6308b232f5e02a0)
##### 2021-01-08 00:13:25 by ms-mirror-bot

[MIRROR] NOTELEPORT checks that were atomized out of the medieval shuttle (#122)

* NOTELEPORT errywhere (#55973)

These prevent some cheats or really low effort ways to get to where you really shouldn't be.

Mappers seriously fucking hate jaunting and phasing mechs, as they let you bypass their custom crafted ruins and the like. But it'll also stop more general "you shouldn't be here" stuff.

* NOTELEPORT checks that were atomized out of the medieval shuttle

Co-authored-by: tralezab <40974010+tralezab@users.noreply.github.com>

---
## [arnfred/Kind@2a66cd1fa0...](https://github.com/arnfred/Kind/commit/2a66cd1fa047146babcec77a69b9266e6fa08d44)
##### 2021-01-08 00:54:54 by Jonas Arnfred

Add type-checking

This change adds type-checking to the kind compiler. The principle of
the type-checker (and of the scanner module it replaces) is to compute
the possible outputs of a function given a subset of possible inputs. We
do this by interpreting the function syntax tree and track:

 a) The possible values of any expression in the function body
 b) Whether the possible values of an expression can be satisfied by a pattern

Part a) gives us a `domain` function, which given input domains can tell
us the output domain of a function or type. Part b) gives us a
type-checker in that we can check at compile time if there are patterns
that can't be satisfied by the expressions assigned to them.

Current issues
--------------

This logic was already to a large part implemented in the `scanner`
module, but adding type-checking proved difficult because of several
issues:

- Logical errors in generated types: There might have been several
  issues (and I suspect there was), but one that comes to mind is that
  pattern matching as implemented by `pattern_gen` didn't work correctly
  for types. In code execution, the pattern would be evaluated top to
  bottom, and the first pattern which is a subset of the input domain
  would be returned. However for a type, the result is a sum of _all_ the
  patterns that are a subset of the input type.
- Code rot: The `scanner` module passed unit tests, but I had never wired it in
  to the compiler in a way that exercised the code paths and the code was
  no longer up to date
- Error ambiguity: The scanner was ambigious in what it considered a
  type error. There are several different error interpretations, all
  useful at different times, but the interpretation I had implemented in
  the scanner was a mixture and suited none of the actual use cases
- Scanner didn't type-check type functions: While `defs` where scanned and checked for
  errors, types (which are fundamentally equally complex) weren't because
  of architectural limitations.

Specification
=============

Kind type checks expressions by computing the domain of all possible
values the expression can possibly evaluate to at run-time. Any patterns
in the expression serve to checking if the domain is valid. In the
strictest sense, "valid" means that the possible domain of values is a
subset of the pattern domain.

Types in kind are expressions that are replaced by their domain at
compile time.

Types are either type constants or type constructors. A type constant is
a value like any other. Any value is equivalent to the domain of said
value. Type constructors are partial functions that define domains. That
means that when you call a type constructor it will return a domain,
unless it's undefined for the arguments. In this case, the type checker
will return an error.

Defs like types are also partial functions. During compile time, we find
any invocation of a def and compute the resulting domain. If the def is
not defined for its arguments, an error is thrown by the typechecker.

Domain traversal
----------------

The typechecker computes the output of a def or type constructor by
traversing the AST of the function and tracking the domains of
all variables. A variable is assigned the `any` domain if nothing else
is known about it, but if this variable is matched in a pattern, the
domain is constrained to the values of the pattern. When the variable is
later referenced in an expression, the domain of the variable known so
far is used to compute the domain of the expression. For function calls,
this behavior is repeated recursively.

Error Modes
-----------

The typechecker defines three error modes:

- Strict: The domain of a matched expression should be a subset of the
  matching pattern
- Normal: The domain of a matched expression should intersect the
  matching pattern
- Lenient: When the domain of a matched expression doesn't intersect a
  matched pattern, the `none` domain is returned instead of an error.

The `strict` error mode guarantees that the partial function of a def or
type constructor will never see an undefined value. It does so by
throwing an error if there's any values in a variable domain for which a
pattern isn't defined. This strictness mode is useful for answering the
question: "Is my function defined for this value and what is the output
domain?"

The `normal` error mode (in lack of a better name), is more permissible.
It allows us to compute the output domain as long as the partial
function for def or type constructor is defined for _some_ values in the
input domain. This more permissive mode of type scanning is suitable for
answering the question of "For any permissive value in this domain, what
is the output domain of this function" and still see an error if no
values were permissible.

Finally the `lenient` error mode will return the domain `none` instead of
returning an error. This is useful in cases where we want to understand
the domain of a partial function, but don't wish to return any errors.

Applying type checking
----------------------

A big limitation in this particular approach to type checking is the
fact that there is no language for specifying the general type of a def.
It's very straightforward to define a partial function where only
certain combinations of arguments are valid. In fact, parameter
combinations that the author of the code didn't anticipate or design
their function for is often the cause of undefined behavior or runtime
errors, and it's often non-trivial to capture these constraints in a
type system that considers the parameter types as independent. However,
the implication is that it's often non-trivial to fully specify the
valid inputs to a function.

It's feels like it should be possible with a smarter algorithm than the
one I've fashioned, but as for now, we don't have an easy way to
determine which combinations of input values are valid.

As a consequence we lack the means of running a strict type-check on a
function, since we don't know the domain for which it is defined.
Instead we find the output domain when the input given is `any` and run
the type checker in `normal` mode, much to my chagrin.

Erlang interop
--------------

For the case of erlang functions the type checker will return the output
domain of `any` without errors, except if the follwing criteria are met:

- The domain inputs are all value domains (i.e. normal values)
- The erlang function in question has been whitelisted as pure

In this case the output domain of the erlang function is computed by
running it at compile time on the given input.

Implementation
==============

We run the type checker at compile time and run it on the Kind language
AST. In theory it should be straight forward to implement a pass where
all types are evaluated and contain no unapplied type constructors.
However in practice I haven't implemented this pass, and as a
consequence we need to be able to evaluate the domain of type functions
(which in turn might call normal functions for which we'll need to
evaluate the domain as well).

Because any type constructor can call any other type constructor and
because the domain of a type constructor can only be decided given the
type parameters, we need an environment of domain functions when we
evaluate a domain, including of course the domain function for the
domain we're currently evaluating in case there's a recursive call.

Before this refactor we implemented this environment at compile time by
creating an environment of clojures covering over the code and paramters
needed to compute domain functions. It was gnarly as fuck, hard to
understand, and quite need in a code-machochistic sort of way.

Because of the requirement to be able to run domain functions at
run-time, we need to compile the domain functions to erlang core and
compile them to beam modules. This provides a much simpler solution to
the recursive environment problem, since we can just call the compiled
functions at runtime.

Implementing the typechecker responsible for computing domains in erlang
core would have been a slow and error prone process though. I'm possibly
speaking from an ignorant perspective, but errors like forgetting to
wrap an atom in `cerl:c_atom` are time consuming to debug, because the
erlang compiler gives me no useful error messages. I'm usually left to
comb through the erlang core AST and see if I can spot any problems
instead. So to keep erlang core code to a minimum, I've instead opted
for the approach of storing the `Kind` AST in erlang core form and
execute a call to the `typechecker` module passing the hardcoded AST as
a parameter. I know it's a hack, but it saved me a lot of work, so I'm
kind of pleased with the solution for what it is.

Module Creation
---------------

In the `domain_gen` module we create a set of modules covering domain
functions for the types and defs defined in the source file:

- Root module: The root module defines three domain functions for each
  type and def defined in the source file, no matter if they are exported
  or not:
   1) A domain function with the same arity as the origin function
      returning the domain given the domain of the arguments
   2) The same as above but with an additional strictness argument being
      either `strict`, `normal` or `lenient` prepended. For more discussion
      about strictness, see this commit message under "Error Modes"
   3) The same as above but with a stack arg prepended. The "stack" when
      evaluating a domain function serves to improve error messages as well
      as catcing recursion. This form of the domain function is called from
      the `typecheck` module.
  When a domain function makes a call to another domain function, this
  call is made to the root module because all other functions are
  available in the root module.
- Type modules: For each type constructor which defines new type
  constants in the function body, we create a separate module type module
  containing the parent type and all sub types defined in the function
  body. These modules makes it possible to import types with the same code
  as ordinary imports.
- Def modules: For each module defined in the source file, we define an
  equivalent domain module (using the name of the module with `_domain`
  appended). The domain module contains the same domain functions as
  defined by the root module, but only include functions exported in the
  kind module.

Hurdles / Points of note
========================

Handling Recursion
------------------

To compute the domain of a function, we need to evaluate all branches of
said function alongside all calls to other functions. This makes means
any uncaught recursion will result in the typechecker looping forever at
compile time.

To handle recursion, we pass a stack along as we recurse through the
AST. The stack is similar to a runtime call stack in that each time we
compute the domain of a function called in the AST, the name of the
function is added to the stack. This enables us to check if a function
has been seen before before we compute the domain for it.

If a function has been seen before, we return a recursive domain of the
shape `{recur, F}` where `F` is a function with zero arguments which
returns the domain if evaluated.

Recursive domains are a special case when handling the union of two
domains. If the domain is a sum of two or more elements where some (but
not all) are recursive domains), the union of said domains exclude the
recursive domains. We use the union of domains with pattern cases, and
this allows us to compute the domain of a function by looking only at
the non-recursive cases. This is useful because It's a bit of an ad-hoc
approach, and I worry it'll come back to bite me, but for now it makes
the code quite straightforward.

Whitelisting
------------

The domain output of an erlang function is generally `any`, but if the
domain arguments to the function are all values and the erlang function
doesn't have any side-effects, we compute the output domain by calling
the function. This allows for example the output domain of `1 + 1` to be
`2`, which is useful in a bunch of cases.

Erlang doesn't have a clear notion of functions without side effects, so
instead I coopt a module/function whitelist I originally made for
running code online for this purpose. The original whitelist was made to
sandbox arbitrary code execution by making sure (or at least trying to
make sure) that no function could be called that could compromise the
host where the code was running. Side-effect free functions fit the bill, but I
shan't say that there aren't a few functions out there in the erlang
libraries that are safe to run, but not side-effect free. It's not
something I've spent long thinking about, but I suspect that I'll have
to at some point.

Pattern Matching Codegen
------------------------

TypeEnv is generated as part of domain_gen. It's a map of type tags to
forms. Tricky part is that using forms for the typesEnv makes it a bit
more difficult to generate pattern matching because the form is a call
to the root domain module and calls aren't allowed in patterns, so
instead I need to make the call to the root domain module while
compiling and translate the resulting domain to a pattern

---
## [Noezor/adventofcode2020@69e33ddf54...](https://github.com/Noezor/adventofcode2020/commit/69e33ddf54143653383ebbb22e6d03dedc9c26bb)
##### 2021-01-08 09:28:13 by NoÃ©

The re of python is bullshit. I hate it.

Spent 10 hours trying to debug what came from my own stupidity while it is actually a problem from the feature of the re extension. This is why everyone used regex instead.

https://www.reddit.com/r/adventofcode/comments/kg1mro/2020_day_19_solutions/ggd6xt5/
see magic if line at the end

---
## [mrakgr/The-Spiral-Language@14d5bc5207...](https://github.com/mrakgr/The-Spiral-Language/commit/14d5bc5207afb51b146530c61c77d9651d2ed86e)
##### 2021-01-08 11:27:33 by Marko GrdiniÄ‡

"10:45am. Let me chill a little. Today I woke up too early. Let me read the first chapter of that Retsu isekai manga.

11:25am. Let me do some work. Let me fix that bug from yesterday.

Then I will have breakfast and do the chores.

```fs
    let generalize r scope (forall_vars : Var list) (body : T) =
        let h = HashSet(HashIdentity.Reference)
        List.iter (h.Add >> ignore) forall_vars
```

Let me get rid of this `HashSet`. Just what the hell was I thinking here?

```fs
    let generalize r scope (forall_vars : Var list) (body : T) =
        let generalized_metavars = ResizeArray()
        let rec replace_metavars x =
            let f = replace_metavars
            match x with
            | TyMetavar(_,{contents=Some x} & link) -> f x
            | TyMetavar(x, link) when scope = x.scope ->
                let v = {scope=x.scope; constraints=x.constraints; kind=kind_force x.kind; name=autogen_name !autogened_forallvar_count}
                incr autogened_forallvar_count
                link := Some (TyVar v)
                generalized_metavars.Add(v)
            | TyVar _ | TyMetavar _ | TyNominal _ | TyB | TyPrim _ | TySymbol _ -> ()
```

Let me give this a try.

11:30am. Yeah, it worked. Things like this happen when it is one's first time doing something.

Now let me make a recursive wrap.

```
inl wrap (b,a) (pu p) =
    pu {size = a >> p.size
        pickle = fun x state => p.pickle (a x) state
        unpickle = fun state => b (p.unpickle state)
        }

inl wrap' (b,a) p =
    pu {size = fun x => inl (pu p) = p() in p.size(a x)
        pickle = fun x state => inl (pu p) = p() in p.pickle (a x) state
        unpickle = fun state => inl (pu p) = p() in b (p.unpickle state)
        }
```

This should do it.

```
inl list (pu p) =
    inl (pu i32) = I32
    pu {size = list.fold (fun s x => s + I32Size + p.size x) I32Size
        pickle = fun x state =>
            let rec loop = function
                | Cons: x, xs =>
                    i32.pickle 0 state
                    p.pickle x state
                    loop xs
                | Nil =>
                    i32.pickle 1 state
            loop x
        unpickle = fun state =>
            let rec loop () =
                match i32.unpickle state with
                | 0 => Cons: p.unpickle state, loop()
                | 1 => Nil
                | _ => failwith "Invalid tag."
            loop ()
        }
```

Now let me back this up, and I will reimplement it in terms of alt.

```
inl rec list p =
    alt (function Cons: _ => 0 | Nil => 1) (
        wrap' (cons_,fun (Cons: a,b) => a,b) (fun () => pair p (list p)) ::
        wrap (nil,fun Nil => ()) Unit ::
        Nil
        )
```

Quite a gain in concision.

11:45am. I am sold. `wrap` and `alt` really make a large difference in concision.

...Ah, crap. Now I remember why I had that convoluted scheme in generalize. That is in order to generalize mutually recursive statements.

Let me backtrack a little.

```fs
    let generalize r scope (forall_vars : Var list) (body : T) =
        let h = HashSet(HashIdentity.Reference)
        List.iter (h.Add >> ignore) forall_vars
        let generalized_metavars = ResizeArray()
        let rec replace_metavars x =
            let f = replace_metavars
            match x with
            | TyMetavar(_,{contents=Some x} & link) -> f x
            | TyMetavar(x, link) when scope = x.scope ->
                let v = TyVar {scope=x.scope; constraints=x.constraints; kind=kind_force x.kind; name=autogen_name !autogened_forallvar_count}
                incr autogened_forallvar_count
                link := Some v
                replace_metavars v
            | TyVar v -> if scope = v.scope && h.Add(v) then generalized_metavars.Add(v)
```

How about I just do this instead.

Yeah, this is the correct fix. As can be seen, even if one knows what the problem is, the obvious thing to do is not always the right one.

11:55am. Things are good.

Now that I have this, the next step would be to actually try it out.

Let me make a test.

```
inl main () =
    inl scheme = pair I32 (pair I32 (list (record_qwe (pair I32 (pair String Char)))))
    ()
```

Ah, I went too fast. Before I can do anything I need the serialize and deserialize functions.

```
inl serialize (pu p) x =
    inl ar = array.create (p.size x)
    ()
```

This is not giving me a missing metavar error even though it should.

```
inl serialize (pu p) x =
    open array
    inl ar = create (p.size x)
    inl i = mut 0

    ()
```

Now it is telling me that array is an unbound variable. Something is seriously wrong here.

12:20pm.

```
nominal serialized a = array i8

inl serialize forall t. (pu p) x =
    inl size = p.size x
    inl ar = array.create size
    inl i = mut 0
    p.pickle x (i,ar)
    assert (*i = size) "The size of the array does not correspond to the amount being pickled. One of the combinators is faulty."
    serialized ar : serialized t

inl deserialize forall t. (pu p : pu t) (serialized x : serialized t) : t =
    inl i = mut 0
    inl r = p.unpickle (i,x)
    assert (*i = array.length x) "The size of the array does not correspond to the amount being unpickled. One of the combinators is faulty or the data is malformed."
    r

inl main () =
    inl scheme = pair I32 (pair I32 (list (record_qwe (pair I32 (pair String Char)))))
    inl x = 1,2,({q=1;w="a";e='z'} :: {q=2;w="s";e='x'} :: Nil)
    assert (x = deserialize scheme (serialize scheme x)) "Serialization and deserialization should result in the same result."
```

I wrote this out, but I do not want to run it right now. I'll leave that kind of debugging for later. First, let me restart the server to see if this array issue persists.

Wow, the metavar errors do not happen when it is a module application. That is ridiculous. How did I miss this for so long. Also I do need to get to the bottom of why `open array` fails outright.

Yeah, it persists. Let me make a test just for this.

```
open array
inl main () = ()
```

Yeah, in a separate test I do get that the array is unbound. But accessing the array function does work. It sees it properly in the hover.

12:25pm.

```
// Does the open array work? Do unapplied metavars errors happen on module application?
open array
inl main () =
    inl x = array.fold
    ()
```

Ok, good. I have my next task in this. After that I will try running the serialization test. That should tell me everything I need to know.

After I deal with this, I'll finish the documentation section.

Time for breakfast."

---
## [mariojp/dpac@f5292b5cc0...](https://github.com/mariojp/dpac/commit/f5292b5cc05f95f93f978af4b6b9674002199ebb)
##### 2021-01-08 12:29:09 by Mario Jorge Pereira

Update 2018-01-12-is-intelligence-enough.md

---
layout: post
title:  "External Featured Image"
author: sal
categories: [ Jekyll, tutorial, web development ]
image: "https://images.unsplash.com/photo-1541544537156-7627a7a4aa1c?ixlib=rb-0.3.5&ixid=eyJhcHBfaWQiOjEyMDd9&s=a20c472bc23308e390c8ffae3dd90c60&auto=format&fit=crop&w=750&q=80"
---
Education must also train one for quick, resolute and effective thinking. To think incisively and to think for one's self is very difficult. 

> We are prone to let our mental life become invaded by legions of half truths, prejudices, and propaganda. At this point, I often wonder whether or not education is fulfilling its purpose. A great majority of the so-called educated people do not think logically and scientifically. 

Even the press, the classroom, the platform, and the pulpit in many instances do not give us objective and unbiased truths. To save man from the morass of propaganda, in my opinion, is one of the chief aims of education. Education must enable one to sift and weigh evidence, to discern the true from the false, the real from the unreal, and the facts from the fiction.

The function of education, therefore, is to teach one to think intensively and to think critically. But education which stops with efficiency may prove the greatest menace to society. The most dangerous criminal may be the man gifted with reason, but with no morals.

The late Eugene Talmadge, in my opinion, possessed one of the better minds of Georgia, or even America. Moreover, he wore the Phi Beta Kappa key. By all measuring rods, Mr. Talmadge could think critically and intensively; yet he contends that I am an inferior being. Are those the types of men we call educated?

We must remember that intelligence is not enough. Intelligence plus character--that is the goal of true education. The complete education gives one not only power of concentration, but worthy objectives upon which to concentrate. The broad education will, therefore, transmit to one not only the accumulated knowledge of the race but also the accumulated experience of social living.

---
## [mariojp/dpac@b3b6ab3bf5...](https://github.com/mariojp/dpac/commit/b3b6ab3bf5660604e0b7f44c5a7043ce81a3084d)
##### 2021-01-08 12:36:05 by Mario Jorge Pereira

Update and rename 2018-01-12-never-stopped-worrying-never-loved-bomb.md to 2020-01-07-trabalhe-4-horas-por-semana-.md

> Iâ€™ve been through fire and water, I tell you! From my earliest pebblehood the wildest things you could imagine have been happening to this world of ours, and I have been right in the midst of them.

So begins Hallam Hawksworthâ€™s The Strange Adventures of a Pebble. Written in the 1920s, the book was part of a series which also included The Adventures of a Grain of Dust and A Year in the Wonderland of Trees, all of which were supposed to introduce children to the world of Natural Sciences. In each of them, Hawksworth personifies the natural object he is exploring, and using a mixture of folk tales, scientific facts and colloquial, friendly explanations guides the reader through the history of the natural world. Itâ€™s a real thrill of a ride, dramatizing the life cycle of supposedly dull things. The Adventures of a Grain of Dust begins even more loudly than Pebble:

I donâ€™t want you to think that Iâ€™m boasting, but I do believe Iâ€™m one of the greatest travellers that ever was; and if anybody, living or dead, has ever gone through with more than I have Iâ€™d like to hear about it.
Hallam Hawksworth was the pen-name of teacher Francis Blake Atkinson. He was married to the author Eleanor Stackhouse Atkinson, author of the childrenâ€™s classic Greyfriars Bobby, which was based on the (supposedly) true story of a Scottish dog who spent fourteen years guarding his masters grave. The couple were both committed to education and published a weekly magazine for Chicago high school students called The Little Chronicle, as well as working for Encyclopaedia companies later in life.

---
## [bobcatfish/adventofcode@3688f2700d...](https://github.com/bobcatfish/adventofcode/commit/3688f2700d3766f99368454397037d8b499d30da)
##### 2021-01-08 18:30:26 by christie

Day 20 - Awful code ðŸ™ˆ but so proud ðŸ˜Š

Okay this code is awful and no one should look at it ever BUT you should
have seen how happy I was when this finally worked. I was working on
this from day 20 until christmas eve and when it finally worked it
basically made my year. I had 33 (I kid you not, THIRTY THREE) different
versions of this sitting around. In the end it turned out I made a silly
mistake in my understanding of what rotatoin would do and it's kind of
amazing I got part 1 at all - once I figured that out (SO MANY HOURS
LATER) I was finally able to get it to work! Now that I know that, I
kinda hope I'll go back one day and remove like 90% of this code, but
who are we kidding, it'll be 2021 advent of code before we know it :D

---
## [KingOKarma/KFCBoy@7c1320ba9d...](https://github.com/KingOKarma/KFCBoy/commit/7c1320ba9dcd364af1cdcd980e9e0f1caaeaf580)
##### 2021-01-08 21:52:00 by KingOKarma

Developer (#188)

* added a whole bunch of shit

* fixed some stuff and added some stuuf lel

* yeah

* removed some stupid ideas and fixed the home page

* updated alot if stuff like slash commands. still needs work tho

* split up the css files

* some small changes that will be put in once rewrite is done

* forgot to change embed names oops

Co-authored-by: milas <59763532+milaskiller@users.noreply.github.com>
Co-authored-by: BuildTools <unconfigured@null.spigotmc.org>
Co-authored-by: Milas <milasholsting@protonmail.com>

---
## [KingOKarma/KFCBoy@82c2183290...](https://github.com/KingOKarma/KFCBoy/commit/82c2183290e443f43dc477773cce232a331c5961)
##### 2021-01-08 21:52:11 by KingOKarma

Developer (#189)

* added a whole bunch of shit

* fixed some stuff and added some stuuf lel

* yeah

* removed some stupid ideas and fixed the home page

* updated alot if stuff like slash commands. still needs work tho

* split up the css files

* some small changes that will be put in once rewrite is done

* forgot to change embed names oops

* quick embed welcome msg fix

Co-authored-by: milas <59763532+milaskiller@users.noreply.github.com>
Co-authored-by: BuildTools <unconfigured@null.spigotmc.org>
Co-authored-by: Milas <milasholsting@protonmail.com>

---
## [marissa999/unpackerr@c1ca403f79...](https://github.com/marissa999/unpackerr/commit/c1ca403f79fbbe20d16cbd2a7e5ca92ac2e40227)
##### 2021-01-08 23:17:46 by Marissa

Update unpackerr.conf.example

Added a #comment to lidarr and readarr bc oh my god i hate myself and spent a lil bit too much time figuring out why the program doesnt work

---

# [<](2021-01-07.md) 2021-01-08 [>](2021-01-09.md)

