# [<](2020-07-19.md) 2020-07-20 [>](2020-07-21.md)

3,466,802 events, 1,248,893 push events, 2,007,457 commit messages, 154,249,437 characters


## [k4yf0ur/AA2Unlimited](https://github.com/k4yf0ur/AA2Unlimited)@[dc7af63321...](https://github.com/k4yf0ur/AA2Unlimited/commit/dc7af63321d413093368f6568880c57778602bc0)
#### Monday 2020-07-20 00:41:28 by kayfour

Finally fixed infirmary h crash. God I fucking hate how dumb that was.

---
## [assertivist/Avara](https://github.com/assertivist/Avara)@[32f6505b7b...](https://github.com/assertivist/Avara/commit/32f6505b7bc991176746a495214d51221cf23574)
#### Monday 2020-07-20 00:47:29 by assertivist

levels added in this commit:

Emotion - Stratocaster finally!
SomeSet - Rez's amazing set!
Oddities v4 - contains several interesting test cases involving use of AI objects for scripting, one of which (Crossover) is currently broken. "The Race" also fails during parsing. Lots of interesting PICT stuff here that is not translating to svg successfully, i think this guy used diagrams to help keep organized
Dildensburg - personal favorite, large scale, good stress test
Medievos - another big one
Wide Open - by request of its creator, war <ivha>!!
Net Levels - for almost purely historical reasons
Clockwork Blue b4 - another level by one of our contributors, poverty
We Be Ground Pounders - Another AI test case, is pretty much impossible currently
T Plus 5 - Lots of good levels in here that I've missed personally

Change in CSwitch:
added a fix for crash in CSwitch that WBGP uncovered, may indicate an issue parsing BSPs (switch bsp had only one part--usually there are two and the game switches between them), doesn't hurt to check if the second part is there before trying to set a field on it though

---
## [ofsho/Pokemon-Night](https://github.com/ofsho/Pokemon-Night)@[ff6499d058...](https://github.com/ofsho/Pokemon-Night/commit/ff6499d0583bc25a1ef2db65281f55531ec3c4f6)
#### Monday 2020-07-20 00:47:39 by Ofek Ben David

################################################################################ # # GTS System                  Version 3.0.0 RELEASE # By Hansiec and Manoel Afonso  # # CHANGE LOG FOR THIS VERSION: # - Adaptation of the original script to work on v17.x of Pokï¿½mon Essentials # - Set to work with GTS Online Panel by Hills Tech # - Performance improvement # - Some minor bugs fixed # # Special Thanks to Saving Raven for providing graphics and testing # CREDITS REQUIRED # ################################################################################ # # NOTICE: If a bug occurs, please state the message of the bug. # # Installation: #   * Create a new code session above Main and paste this script there; #   * Go to http://gts.hillstech.co and create a user account; #   * Go to the "new game" tab on the site and create a new game; #   * Get the game ID that was generated on the site and paste it  #     into the GAMEID variable in this script; #   * Done. # # How To Use: #   * Install #   * Call "GTS.open" #   * Report if any bugs uccor # # Settings: #   * URL - The url link of the online panel, don't change this. #   * SPECIES_SHOWN - Set to "All", "Owned", or "Seen" - this sets the available #       species you can search for. #   * SORT_MODE - Set to "Alphabetical" or "Regional" - How species are arranged #       during species finding. #   * GAME_CODE - A special Game Code, if you happen to trade with a game with #       a different game code, the found map would be "Faraway Place". # ################################################################################  module GTSSettings     GAMEID = 0 # paste the ID of your game here    URL = "http://gts.hillstech.co/api.php?i=" # don't change this    SPECIES_SHOWN = "All" # All/Seen/Owned Species you can search for   SORT_MODE = "Alphabetical" # Alphabetical/Regional How species are arranged   BLACK_LIST = [] # Pokemon Species of which cannot be selected to search for    GAME_CODE = "" # Please use a custom Game Code                  # It IS case Sensitive and can be any length, this is to define                  # Games as different from each other.                     KEEP_OLD_IDS = true # If this is set to false, instead of keeping your old                       # online ID it creates you a new one, this means that                       # it can cause a table in the MySQL server to be flooded                       # with someone who constantly does new game and uploads a                       # pokemon to the server. This should only be done for                       # testing purposes                        end  # Temporary boolean, DO NOT REMOVE $TempBool = false  module GTS   ##### Main Method   def self.open     scene = Scene_GTS.new     scene.main   end      #### Brings up a summary of your uploaded pokemon (also allows you to delete it)   def self.summary     if GTSCore.isTaken       newpoke = GTSCore.downloadPokemon($PokemonGlobal.onlineID).to_pokemon       if finishTrade($PokemonGlobal.onlinePokemon, newpoke, false)         pbAddPokemonSilent(newpoke)         $PokemonGlobal.onlinePokemon = nil         pbSave       end       return     end     pbFadeOutIn(99999){       scene=PokemonSummary_Scene.new       screen=PokemonSummaryScreen.new(scene)       screen.pbStartScreen([$PokemonGlobal.onlinePokemon],0)     }     if Kernel.pbConfirmMessageSerious(_INTL("Do you want to withdraw your "+       "pokemon from GTS?"))       if Kernel.pbConfirmMessageSerious(_INTL("Are you sure you want to "+         "withdraw your pokemon?"))         if GTSCore.deletePokemon           pbAddPokemonSilent($PokemonGlobal.onlinePokemon)           $PokemonGlobal.onlinePokemon = nil           $TempBool = true           pbSave           # Long story short, we save before we show the message to help prevent           # pokemon from being deleted by restarting, but if the game is restarted,           # we don't want this message           if $TempBool             Kernel.pbMessage(_INTL("Pokemon withdrawn, please be aware that "+             "your pokemon may have had been taken by now."))           end         end       end     end   end      ##### Finishes the GTS trade   def self.finishTrade(myPokemon, newpoke, searching, id=nil)     $Trainer.seen[newpoke.species]=true     $Trainer.owned[newpoke.species]=true     pbSeenForm(newpoke)     pbFadeOutInWithMusic(99999){       evo=PokemonTradeScene.new       evo.pbStartScreen(myPokemon,newpoke,$Trainer.name,newpoke.ot)       evo.pbTrade       evo.pbEndScreen     }     if !newpoke.game_code || newpoke.game_code != GTSSettings::GAME_CODE       newpoke.obtainText = "Faraway Place"     end     newpoke.obtainMode = 2 # Traded     if searching       if GTSCore.setTaken(id) && GTSCore.uploadNewPokemon(id, myPokemon)         pbAddPokemonSilent(newpoke)         pbSave         return true       end       return false     else       pbSave       return GTSCore.deletePokemon(false)     end   end         ##### Brings up all species of pokemon of the given index of the given sort mode   def self.orderSpecies(index)     speciesList = []     commands = ["Cancel"]     if GTSSettings::SORT_MODE == "Alphabetical"       l = "A"       l[0] += index if !index.is_a?(String)       letter = index.is_a?(String) ? index : l       for i in 1..PBSpecies.maxValue         show = true         show = false if !$Trainer.seen[i] && GTSSettings::SPECIES_SHOWN == "Seen"         show = false if !$Trainer.owned[i] && GTSSettings::SPECIES_SHOWN == "Owned"         for j in GTSSettings::BLACK_LIST           show = false if i == j           break if !show         end         speciesList.push(i) if PBSpecies.getName(i)[0] == letter[0] && show       end     elsif GTSSettings::SORT_MODE == "Regional"       realIndex = -1       regions = pbDexNames       for i in 0...regions.length         if regions[i].is_a?(Array)           if regions[i][0] == index             realIndex = regions[i][1]           end         end       end       if realIndex != -1         sl = pbAllRegionalSpecies(realIndex)         for i in sl           show = true           show = false if !$Trainer.seen[i] &&           GTSSettings::SPECIES_SHOWN == "Seen"           show = false if !$Trainer.owned[i] &&           GTSSettings::SPECIES_SHOWN == "Owned"           for j in GTSSettings::BLACK_LIST             show = false if i == j             break if !show           end           speciesList.push(i) if show         end       else         for i in 1..PBSpecies.maxValue           show = true           show = false if !$Trainer.seen[i] &&           GTSSettings::SPECIES_SHOWN == "Seen"           show = false if !$Trainer.owned[i] &&           GTSSettings::SPECIES_SHOWN == "Owned"           for j in GTSSettings::BLACK_LIST             show = false if i == j             break if !show           end           speciesList.push(i) if show         end       end     end     for i in speciesList       commands.push("#{i}: #{PBSpecies.getName(i)}") if i > 0     end     if commands.length == 1       Kernel.pbMessage(_INTL("No species found"))       return [0, 0]     end     c = Kernel.pbMessage("Select a Species", commands, 0, nil, 1)          x = speciesList[c - 1]     if x.is_a?(Array)       x = x[0]     end     return [c == 0 ? -1 : x, c]   end    end ################################################################################ # GTS Scenes # By A Dork of Pork # Scenes For GTS ################################################################################  ######## GTS Button, A Basic options button for our GTS System class GTS_Button < SpriteWrapper   def initialize(x,y,name="",index=0,viewport=nil)     super(viewport)     @index=index     @name=name     @selected=false     self.x=x     self.y=y     update   end    def dispose     super   end    def refresh     self.bitmap.dispose if self.bitmap     self.bitmap = Bitmap.new("Graphics/Pictures/GTS/Options_bar")     pbSetSystemFont(self.bitmap)     textpos=[        [@name,self.bitmap.width/2,1,2,Color.new(248,248,248),Color.new(40,40,40)],     ]     pbDrawTextPositions(self.bitmap,textpos)   end    def update     refresh     super   end end  ########## GTS Search Method Selection class GTSSearchMethod   def initialize     @exit = false     @index = 0   end      def create_spriteset     pbDisposeSpriteHash(@sprites) if @sprites     @sprites = {}     @sprites["background"] = IconSprite.new     @sprites["background"].setBitmap("Graphics/Pictures/GTS/Background")          pbSetSystemFont(@sprites["background"].bitmap)     textpos=[                  ["Select Search Method",50,6,0,Color.new(248,248,248),Color.new(40,40,40)],        ["Online ID: #{$PokemonGlobal.onlineID}",350,6,2,Color.new(248,248,248),        Color.new(40,40,40)],     ]     pbDrawTextPositions(@sprites["background"].bitmap,textpos)          @sprites["0"] = GTS_Button.new(Graphics.width/2, 50, "By Wanted")     @sprites["0"].x -= @sprites["0"].bitmap.width / 2          @sprites["1"] = GTS_Button.new(Graphics.width/2, 110, "By Pokemon")     @sprites["1"].x -= @sprites["1"].bitmap.width / 2          @sprites["2"] = GTS_Button.new(Graphics.width/2, 170, "By ID")     @sprites["2"].x -= @sprites["2"].bitmap.width / 2          @sprites["3"] = GTS_Button.new(Graphics.width/2, 230, "Exit")     @sprites["3"].x -= @sprites["3"].bitmap.width / 2          bit = Bitmap.new("Graphics/Pictures/GTS/Select")     @sprites["selection_l"] = IconSprite.new     @sprites["selection_l"].bitmap = Bitmap.new(16, 46)     @sprites["selection_l"].bitmap.blt(0, 0, bit, Rect.new(0, 0, 16, 16))     @sprites["selection_l"].bitmap.blt(0, 23, bit, Rect.new(0, 16, 16, 32))          @sprites["selection_r"] = IconSprite.new     @sprites["selection_r"].bitmap = Bitmap.new(16, 46)     @sprites["selection_r"].bitmap.blt(0, 0, bit, Rect.new(16, 0, 32, 16))     @sprites["selection_r"].bitmap.blt(0, 23, bit, Rect.new(16, 16, 32, 32))          @sprites["selection_l"].x = @sprites["#{@index}"].x-2     @sprites["selection_l"].y = @sprites["#{@index}"].y-2     @sprites["selection_r"].x = @sprites["#{@index}"].x+     @sprites["#{@index}"].bitmap.width-18     @sprites["selection_r"].y = @sprites["#{@index}"].y-2        end      def main     Graphics.freeze     create_spriteset     Graphics.transition     loop do       Graphics.update       Input.update       update       break if @exit     end     Graphics.freeze     pbDisposeSpriteHash(@sprites)   end      def update     pbUpdateSpriteHash(@sprites)     @sprites["selection_l"].x = @sprites["#{@index}"].x-2     @sprites["selection_l"].y = @sprites["#{@index}"].y-2     @sprites["selection_r"].x = @sprites["#{@index}"].x+     @sprites["#{@index}"].bitmap.width-18     @sprites["selection_r"].y = @sprites["#{@index}"].y-2     if Input.trigger?(Input::UP)       @index -= 1       if @index < 0         @index = 3       end     elsif Input.trigger?(Input::DOWN)       @index += 1       if @index > 3         @index = 0       end     end     if (Input.trigger?(Input::B))       pbPlayCancelSE       @exit = true     elsif (Input.trigger?(Input::C))       pbPlayDecisionSE       do_command     end   end      def do_command     if @index == 0       Graphics.freeze       scene = GTSWantedData.new       @sprites["background"].dispose       data=scene.main       create_spriteset       Graphics.transition       return if !data.is_a?(Array)       list = GTSCore.getPokemonList(data)       if list[0] == "nothing"         Kernel.pbMessage(_INTL("No Pokemon was found."))       else         pokemonList = []         for i in list           pokemonList.push(GTSCore.downloadPokemon(i).to_pokemon)         end         loop do           scene=PokemonSummaryScene.new           screen=PokemonSummary.new(scene)           index = screen.pbStartGTSScreen(pokemonList,0)           if index == false             break           else             wantedData = GTSCore.downloadWantedData(list[index])             for i in 0...wantedData.length               wantedData[i] = wantedData[i].to_i             end             scene=PokemonSummaryScene.new             screen=PokemonSummary.new(scene)             takes = screen.pbStartGTSWantedScreen(wantedData,0)             if takes               pbFadeOutIn(99999){                scene=PokemonStorageScene.new                screen=PokemonStorageScreen.new(scene,$PokemonStorage)                $choice = choice = screen.pbChoosePokemon               }               choice = $choice               if choice == nil                 break               else                 party = choice[0] == -1                 pkmn = $Trainer.party[choice[1]].clone if party                 pkmn = $PokemonStorage[choice[0]][choice[1]].clone if !party                                  if pkmn.species != wantedData[0] || pkmn.level < wantedData[1] ||                   pkmn.level > wantedData[2] ||                   (wantedData[3] != -1 && pkmn.gender != wantedData[3])                   Kernel.pbMessage(_INTL("The selected pokemon does not match the"+                   " wanted requirments."))                 else                         if GTS.finishTrade(pkmn, pokemonList[index], true, list[index])                     if party                       pbRemovePokemonAt(choice[1])                     else                       $PokemonStorage[choice[0]][choice[1]] = nil                     end                     pbSave                     return true                   end                 end               end             end           end         end       end     elsif @index == 1       Kernel.pbMessage(_INTL("To Continue, please select a pokemon of yours,"+       " we will match it up with any possible matches and allow you to choose a"+       " match."))       pbFadeOutIn(99999){        scene=PokemonStorageScene.new        screen=PokemonStorageScreen.new(scene,$PokemonStorage)        $choice = choice = screen.pbChoosePokemon       }       choice = $choice       if choice == nil         return       else         party = choice[0] == -1         pkmn = $Trainer.party[choice[1]].clone         pkmn = $PokemonStorage[choice[0]][choice[1]].clone if !party         if pkmn           list = GTSCore.getPokemonListFromWanted(pkmn)           if list[0] == "nothing"             Kernel.pbMessage(_INTL("No Pokemon was found."))           else             pokemonList = []             for i in list               pokemonList.push(GTSCore.downloadPokemon(i).to_pokemon)             end             loop do               scene=PokemonSummaryScene.new               screen=PokemonSummary.new(scene)               index = screen.pbStartGTSScreen(pokemonList,0)               if index == false                 break               else                 wantedData = GTSCore.downloadWantedData(list[index])                 for i in 0...wantedData.length                   wantedData[i] = wantedData[i].to_i                 end                 Kernel.pbMessage(_INTL("To confirm, this is the wanted data."))                 scene=PokemonSummaryScene.new                 screen=PokemonSummary.new(scene)                 takes = screen.pbStartGTSWantedScreen(wantedData,0)                 if takes                   if GTS.finishTrade(pkmn, pokemonList[index], true, list[index])                     if party                       pbRemovePokemonAt(choice[1])                     else                       $PokemonStorage[choice[0]][choice[1]] = nil                     end                     pbSave                     return true                   end                 else                   break                 end               end             end           end         end       end     elsif @index == 2       loop do         params=ChooseNumberParams.new         params.setRange(1,99999999)         params.setInitialValue(1)         params.setCancelValue(-1)         id=Kernel.pbMessageChooseNumber(            _INTL("Select the online ID."),params)         return if id < 1         if id == $PokemonGlobal.onlineID           Kernel.pbMessage(_INTL("You cannot search by your own online ID!"))         else           break         end       end       if !GTSCore.hasPokemonUploaded?(id)         Kernel.pbMessage(_INTL("No Pokemon with this online ID exists!"))         return       end       gpkmn = GTSCore.downloadPokemon(id).to_pokemon       wantedData = GTSCore.downloadWantedData(id)       for i in 0...wantedData.length         wantedData[i] = wantedData[i].to_i       end       scene=PokemonSummaryScene.new       screen=PokemonSummary.new(scene)       index = screen.pbStartGTSScreen([gpkmn],0)       if index         scene=PokemonSummaryScene.new         screen=PokemonSummary.new(scene)         takes = screen.pbStartGTSWantedScreen(wantedData,0)         if takes           pbFadeOutIn(99999){            scene=PokemonStorageScene.new            screen=PokemonStorageScreen.new(scene,$PokemonStorage)            $choice = choice = screen.pbChoosePokemon           }           choice = $choice           if choice == nil             return           else             party = choice[0] == -1             pkmn = $Trainer.party[choice[1]].clone             pkmn = $PokemonStorage[choice[0]][choice[1]].clone if !party                          if pkmn.species != wantedData[0] || pkmn.level < wantedData[1] ||               pkmn.level > wantedData[2] ||               (wantedData[3] != -1 && pkmn.gender != wantedData[3])               Kernel.pbMessage(_INTL("The selected pokemon does not match the"+               " wanted requirments."))             else                     if GTS.finishTrade(pkmn, gpkmn, true, id)                 if party                   pbRemovePokemonAt(choice[1])                 else                   $PokemonStorage[choice[0]][choice[1]] = nil                 end                 pbSave                 return true               end             end           end         end       end     else       @exit = true     end   end end  ########## GTS Wanted Data, shows a screen on which you can create wanted data class GTSWantedData   def initialize     @exit = false     @wanted_data = [-1, 1, 100, -1]     @index = 0   end      def create_spriteset     pbDisposeSpriteHash(@sprites) if @sprites     @sprites = {}          @sprites["background"] = IconSprite.new     @sprites["background"].setBitmap("Graphics/Pictures/GTS/Background")          pbSetSystemFont(@sprites["background"].bitmap)     textpos=[                  ["Pokemon Wanted Data",50,6,0,Color.new(248,248,248),Color.new(40,40,40)],        ["Online ID: #{$PokemonGlobal.onlineID}",350,6,2,Color.new(248,248,248),        Color.new(40,40,40)],     ]     pbDrawTextPositions(@sprites["background"].bitmap,textpos)          @sprites["0"] = IconSprite.new     @sprites["0"].setBitmap("Graphics/Pictures/GTS/Pokemon_bar")     @sprites["0"].x = Graphics.width / 2     @sprites["0"].x -= @sprites["0"].bitmap.width / 2     @sprites["0"].y = 50          @sprites["0t"] = IconSprite.new     @sprites["0t"].bitmap = Bitmap.new(@sprites["0"].bitmap.width,      @sprites["0"].bitmap.height)     @sprites["0t"].x = @sprites["0"].x     @sprites["0t"].y = @sprites["0"].y          @sprites["1"] = IconSprite.new     @sprites["1"].setBitmap("Graphics/Pictures/GTS/Gender_bar")     @sprites["1"].x = Graphics.width / 2     @sprites["1"].x -= @sprites["1"].bitmap.width / 2     @sprites["1"].y = 110          @sprites["1t"] = IconSprite.new     @sprites["1t"].bitmap = Bitmap.new(@sprites["1"].bitmap.width,      @sprites["1"].bitmap.height)     @sprites["1t"].x = @sprites["1"].x     @sprites["1t"].y = @sprites["1"].y          @sprites["2"] = IconSprite.new     @sprites["2"].setBitmap("Graphics/Pictures/GTS/Level_bar")     @sprites["2"].x = Graphics.width / 2     @sprites["2"].x -= @sprites["2"].bitmap.width / 2     @sprites["2"].y = 170          @sprites["2t"] = IconSprite.new     @sprites["2t"].bitmap = Bitmap.new(@sprites["2"].bitmap.width,      @sprites["2"].bitmap.height)     @sprites["2t"].x = @sprites["2"].x     @sprites["2t"].y = @sprites["2"].y          @sprites["3"] = IconSprite.new     @sprites["3"].setBitmap("Graphics/Pictures/GTS/Search_bar")     @sprites["3"].x = Graphics.width / 2     @sprites["3"].x -= @sprites["3"].bitmap.width / 2     @sprites["3"].y = 230          @sprites["3t"] = IconSprite.new     @sprites["3t"].bitmap = Bitmap.new(@sprites["3"].bitmap.width,      @sprites["3"].bitmap.height)     @sprites["3t"].x = @sprites["3"].x     @sprites["3t"].y = @sprites["3"].y          @sprites["4"] = GTS_Button.new(Graphics.width/2, 290, "Back")     @sprites["4"].x -= @sprites["4"].bitmap.width / 2          pbSetSystemFont(@sprites["0"].bitmap)     textpos=[                  ["Pokemon You Want",50,0,0,Color.new(248,248,248),Color.new(40,40,40)],     ]     pbDrawTextPositions(@sprites["0"].bitmap,textpos)          pbSetSystemFont(@sprites["1"].bitmap)     textpos=[                  ["Gender",75,0,0,Color.new(248,248,248),Color.new(40,40,40)],     ]     pbDrawTextPositions(@sprites["1"].bitmap,textpos)          pbSetSystemFont(@sprites["2"].bitmap)     textpos=[                  ["Level Range",50,0,0,Color.new(248,248,248),Color.new(40,40,40)],     ]     pbDrawTextPositions(@sprites["2"].bitmap,textpos)          pbSetSystemFont(@sprites["3"].bitmap)     textpos=[                  ["Search with these Conditions!",        @sprites["3"].bitmap.width / 2, 2,2,Color.new(248,248,248),        Color.new(40,40,40)],     ]     pbDrawTextPositions(@sprites["3"].bitmap,textpos)          bit = Bitmap.new("Graphics/Pictures/GTS/Select")     @sprites["selection_l"] = IconSprite.new     @sprites["selection_l"].bitmap = Bitmap.new(16, 46)     @sprites["selection_l"].bitmap.blt(0, 0, bit, Rect.new(0, 0, 16, 16))     @sprites["selection_l"].bitmap.blt(0, 23, bit, Rect.new(0, 16, 16, 32))          @sprites["selection_r"] = IconSprite.new     @sprites["selection_r"].bitmap = Bitmap.new(16, 46)     @sprites["selection_r"].bitmap.blt(0, 0, bit, Rect.new(16, 0, 32, 16))     @sprites["selection_r"].bitmap.blt(0, 23, bit, Rect.new(16, 16, 32, 32))          @sprites["selection_l"].x = @sprites["#{@index}"].x-2     @sprites["selection_l"].y = @sprites["#{@index}"].y-2     @sprites["selection_r"].x = @sprites["#{@index}"].x+     @sprites["#{@index}"].bitmap.width-18     @sprites["selection_r"].y = @sprites["#{@index}"].y-2          drawWantedData   end      def drawWantedData     @sprites["0t"].bitmap.clear     s = "????"     s = PBSpecies.getName(@wanted_data[0]) if @wanted_data[0] > 0     pbSetSystemFont(@sprites["0t"].bitmap)     textpos=[                  [s,350,4,2,Color.new(248,248,248),Color.new(40,40,40)],     ]     pbDrawTextPositions(@sprites["0t"].bitmap,textpos)          @sprites["1t"].bitmap.clear     g = "Either"     g = "Male" if @wanted_data[3] == 0     g = "Female" if @wanted_data[3] == 1     pbSetSystemFont(@sprites["1t"].bitmap)     textpos=[                  [g,325,2,2,Color.new(248,248,248),Color.new(40,40,40)],     ]     pbDrawTextPositions(@sprites["1t"].bitmap,textpos)          @sprites["2t"].bitmap.clear     lr = "#{@wanted_data[1]} To #{@wanted_data[2]}"     pbSetSystemFont(@sprites["2t"].bitmap)     textpos=[                  [lr,325,4,2,Color.new(248,248,248),Color.new(40,40,40)],     ]     pbDrawTextPositions(@sprites["2t"].bitmap,textpos)   end      def main     Graphics.freeze     create_spriteset     Graphics.transition     loop do       Graphics.update       Input.update       update       break if @exit     end     Graphics.freeze     pbDisposeSpriteHash(@sprites)     return @wanted_data    end      def update     pbUpdateSpriteHash(@sprites)          @sprites["selection_l"].x = @sprites["#{@index}"].x-2     @sprites["selection_l"].y = @sprites["#{@index}"].y-2     @sprites["selection_r"].x = @sprites["#{@index}"].x+     @sprites["#{@index}"].bitmap.width-18     @sprites["selection_r"].y = @sprites["#{@index}"].y-2          if Input.trigger?(Input::B)       pbPlayCancelSE       @wanted_data = -1       @exit = true     end          if Input.trigger?(Input::C)       pbPlayDecisionSE       do_command     end          if Input.trigger?(Input::UP)       @index -= 1       if @index < 0         @index = 4       end     end     if Input.trigger?(Input::DOWN)       @index += 1       if @index > 4         @index = 0       end     end   end      def do_command     if @index == 0       msg = ""       commands2 = ["Cancel"]       if GTSSettings::SORT_MODE == "Alphabetical"         sL = "A"         for i in 0...26           s = sL.clone           s[0] += i           commands2.push(s)         end         msg = "Choose a Letter."       elsif GTSSettings::SORT_MODE == "Regional"         dexNames = pbDexNames         for i in dexNames           if i.is_a?(String)             name = i           else             name = i[0]           end           commands2.push(name)         end         msg = "Choose a Pokedex."       end       c2 = Kernel.pbMessage(msg, commands2, 0, nil, 1)       if c2 > 0         s = GTS.orderSpecies(commands2[c2])         @wanted_data[0] = s[0] if s[0] > 0       end     elsif @index == 1       cmds = ["Either", "Male", "Female"]       @wanted_data[3] = Kernel.pbMessage("Which gender do you want", cmds,       @wanted_data[3] + 1, nil, @wanted_data[3]+1) - 1     elsif @index == 2       params=ChooseNumberParams.new       params.setRange(1,PBExperience::MAXLEVEL)       params.setInitialValue(@wanted_data[1])       params.setCancelValue(@wanted_data[1])       @wanted_data[1]=Kernel.pbMessageChooseNumber(          _INTL("Set the Minimum wanted level."),params)       params=ChooseNumberParams.new       params.setRange(1,PBExperience::MAXLEVEL)       params.setInitialValue(@wanted_data[2])       params.setCancelValue(@wanted_data[2])       @wanted_data[2]=Kernel.pbMessageChooseNumber(          _INTL("Set the Maximum wanted level."),params)     elsif @index == 3       if @wanted_data[0] > 0         @exit = true       else         pbPlayCancelSE       end     elsif @index == 4       @wanted_data = -1       @exit = true     end     drawWantedData   end end   ########## Scene GTS Main GTS Functionality here. class Scene_GTS   def initialize     @index = 0     @exit = false     @uploaded = GTSCore.hasPokemonUploaded?   end      def create_spriteset     pbDisposeSpriteHash(@sprites) if @sprites     @sprites = {}     @sprites["background"] = IconSprite.new     @sprites["background"].setBitmap("Graphics/Pictures/GTS/Background")          pbSetSystemFont(@sprites["background"].bitmap)     textpos=[                  ["GTS",50,6,2,Color.new(248,248,248),Color.new(40,40,40)],        ["Online ID: #{$PokemonGlobal.onlineID}",350,6,2,Color.new(248,248,248),        Color.new(40,40,40)],     ]     pbDrawTextPositions(@sprites["background"].bitmap,textpos)          @sprites["0"] = GTS_Button.new(Graphics.width/2, 100, "Search")     @sprites["0"].x -= @sprites["0"].bitmap.width / 2          t = "Deposit"     t = "Summary" if @uploaded          @sprites["1"] = GTS_Button.new(Graphics.width/2, 200, t)     @sprites["1"].x -= @sprites["1"].bitmap.width / 2          @sprites["2"] = GTS_Button.new(Graphics.width/2, 300, "Exit")     @sprites["2"].x -= @sprites["2"].bitmap.width / 2          bit = Bitmap.new("Graphics/Pictures/GTS/Select")     @sprites["selection_l"] = IconSprite.new     @sprites["selection_l"].bitmap = Bitmap.new(16, 46)     @sprites["selection_l"].bitmap.blt(0, 0, bit, Rect.new(0, 0, 16, 16))     @sprites["selection_l"].bitmap.blt(0, 23, bit, Rect.new(0, 16, 16, 32))          @sprites["selection_r"] = IconSprite.new     @sprites["selection_r"].bitmap = Bitmap.new(16, 46)     @sprites["selection_r"].bitmap.blt(0, 0, bit, Rect.new(16, 0, 32, 16))     @sprites["selection_r"].bitmap.blt(0, 23, bit, Rect.new(16, 16, 32, 32))          @sprites["selection_l"].x = @sprites["#{@index}"].x-2     @sprites["selection_l"].y = @sprites["#{@index}"].y-2     @sprites["selection_r"].x = @sprites["#{@index}"].x+     @sprites["0"].bitmap.width-18     @sprites["selection_r"].y = @sprites["#{@index}"].y-2        end      def main     Graphics.freeze     create_spriteset     Graphics.transition     loop do       break if @exit       Graphics.update       Input.update       update     end     Graphics.freeze     pbDisposeSpriteHash(@sprites)     Graphics.transition   end      def update     pbUpdateSpriteHash(@sprites)     @sprites["selection_l"].x = @sprites["#{@index}"].x-2     @sprites["selection_l"].y = @sprites["#{@index}"].y-2     @sprites["selection_r"].x = @sprites["#{@index}"].x+     @sprites["0"].bitmap.width-18     @sprites["selection_r"].y = @sprites["#{@index}"].y-2          if Input.trigger?(Input::UP)       @index -= 1       if @index < 0         @index = 2       end     end          if Input.trigger?(Input::DOWN)       @index += 1       if @index > 2         @index = 0       end     end          if Input.trigger?(Input::B)       choices = []       choices.push(_INTL("Yes"))       choices.push(_INTL("No"))       command=Kernel.pbMessage("Are you sure you want to quit GTS?",choices,choices.length)       if command == 0         pbPlayCancelSE         @exit = true       end     end          if Input.trigger?(Input::C)       pbPlayDecisionSE       do_command     end        end      def do_command     if @index == 0       Graphics.freeze       scene = GTSSearchMethod.new       @sprites["background"].dispose       data = scene.main       create_spriteset       Graphics.transition     elsif @index == 1       if @uploaded         GTS.summary         @uploaded = GTSCore.hasPokemonUploaded?         create_spriteset       else         pbFadeOutIn(99999){          scene=PokemonStorageScene.new          screen=PokemonStorageScreen.new(scene,$PokemonStorage)          $choice = screen.pbChoosePokemon         }         choice = $choice         return false if choice == nil         pkmn = $Trainer.party[choice[1]]         pkmn = $PokemonStorage[choice[0]][choice[1]] if choice[0] >= 0         if choice[0] == -1           if $Trainer.party.length == 1             Kernel.pbMessage(_INTL("You cannot deposit your last pokemon in "+             "your party!"))             return           end         end         Graphics.freeze         scene = GTSWantedData.new         @sprites["background"].dispose         data = scene.main         create_spriteset         Graphics.transition         if GTSCore.uploadPokemon(pkmn, data)           $PokemonGlobal.onlinePokemon = pkmn.clone           if choice[0] >= 0             $PokemonStorage[choice[0]][choice[1]] = nil           else             pbRemovePokemonAt(choice[1])           end           pbSave           @uploaded = true           create_spriteset         end       end     else       choices = []       choices.push(_INTL("Yes"))       choices.push(_INTL("No"))       command=Kernel.pbMessage("Are you sure you want to quit GTS?",choices,choices.length)       if command == 0         pbPlayCancelSE         @exit = true       end     end   end end  ################################################################################ # GTS Summary Scenes # By A Dork of Pork # Summary Modifications for GTS ################################################################################  class PokemonSummary      def pbStartGTSScreen(party,partyindex)     @scene.pbStartScene(party,partyindex)     ret=@scene.pbGTSScene     @scene.pbEndScene     return ret   end      def pbStartGTSWantedScreen(party,partyindex)     @scene.pbStartGTSWantedScene(party)     ret=@scene.pbGTSWantedScene(party)     @scene.pbEndScene     return ret   end    end  class PokemonSummary_Scene      def pbStartGTSWantedScene(wantedData)     @viewport=Viewport.new(0,0,Graphics.width,Graphics.height)     @viewport.z=99999     @party=nil     @partyindex=0     @pokemon=nil     @sprites={}     pk = PokeBattle_Pokemon.new(wantedData[0], 1)     @typebitmap=AnimatedBitmap.new(_INTL("Graphics/Pictures/types"))     @sprites["background"]=IconSprite.new(0,0,@viewport)     @sprites["overlay"]=BitmapSprite.new(Graphics.width,Graphics.height,@viewport)     @sprites["pokemon"]=PokemonSprite.new(@viewport)     @sprites["pokemon"].setPokemonBitmap(pk)     @sprites["pokemon"].mirror=false     @sprites["pokemon"].color=Color.new(0,0,0,0)     pbPositionPokemonSprite(@sprites["pokemon"],40,144)     @sprites["pokeicon"]=PokemonBoxIcon.new(pk,@viewport)     @sprites["pokeicon"].x=14     @sprites["pokeicon"].y=52     @sprites["pokeicon"].mirror=false     @sprites["pokeicon"].visible=false     @sprites["movepresel"]=MoveSelectionSprite.new(@viewport)     @sprites["movepresel"].visible=false     @sprites["movepresel"].preselected=true     @sprites["movesel"]=MoveSelectionSprite.new(@viewport)     @sprites["movesel"].visible=false     @page=0     drawPageOneGTSWanted(wantedData)     pbFadeInAndShow(@sprites) { pbUpdate }   end      def pbGTSScene     pbPlayCry(@pokemon)     loop do       Graphics.update       Input.update       pbUpdate       if Input.trigger?(Input::B)         if Kernel.pbConfirmMessage(_INTL("Stop looking for a pokemon?"))           return false         end       end       dorefresh=false       if Input.trigger?(Input::C)           if Kernel.pbConfirmMessage(_INTL("Is this the pokemon you want?"))             break           end       end       if Input.trigger?(Input::UP) && @partyindex>0         pbGoToPrevious         @pokemon=@party[@partyindex]         @sprites["pokemon"].setPokemonBitmap(@pokemon)         @sprites["pokemon"].color=Color.new(0,0,0,0)         pbPositionPokemonSprite(@sprites["pokemon"],40,144)         dorefresh=true         pbPlayCry(@pokemon)       end       if Input.trigger?(Input::DOWN) && @partyindex<@party.length-1         pbGoToNext         @pokemon=@party[@partyindex]         @sprites["pokemon"].setPokemonBitmap(@pokemon)         @sprites["pokemon"].color=Color.new(0,0,0,0)         pbPositionPokemonSprite(@sprites["pokemon"],40,144)         dorefresh=true         pbPlayCry(@pokemon)       end       if Input.trigger?(Input::LEFT) && !@pokemon.egg?         oldpage=@page         @page-=1         @page=0 if @page<0         @page=4 if @page>4         dorefresh=true         if @page!=oldpage # Move to next page           pbPlayCursorSE()           dorefresh=true         end       end       if Input.trigger?(Input::RIGHT) && !@pokemon.egg?         oldpage=@page         @page+=1         @page=0 if @page<0         @page=4 if @page>4         if @page!=oldpage # Move to next page           pbPlayCursorSE()           dorefresh=true         end       end       if dorefresh         case @page           when 0             drawPageOne(@pokemon)           when 1             drawPageTwo(@pokemon)           when 2             drawPageThree(@pokemon)           when 3             drawPageFour(@pokemon)           when 4             drawPageFive(@pokemon)         end       end     end     return @partyindex   end      def pbGTSWantedScene(wantedData)     pbPlayCry(wantedData[0])     loop do       Graphics.update       Input.update       pbUpdate       if Input.trigger?(Input::B)         if Kernel.pbConfirmMessage(_INTL("Decline this trade?"))           return false         end       end       dorefresh=false       if Input.trigger?(Input::C)         if Kernel.pbConfirmMessage(_INTL("Accept this trade?"))           return true         end       end       if dorefresh         drawPageOneGTSWanted(wantedData)       end     end   end      def drawPageOneGTSWanted(wantedData)     pokemon = PokeBattle_Pokemon.new(wantedData[0], 1)     overlay=@sprites["overlay"].bitmap     overlay.clear     bit = "Graphics/Pictures/summaryGTS"     bit = "Graphics/Pictures/summary1" if !pbResolveBitmap(bit)     g = "Either"     g = "Male" if wantedData[3] == 0     g = "Female" if wantedData[3] == 1     @sprites["background"].setBitmap(bit)     base=Color.new(248,248,248)     shadow=Color.new(104,104,104)     numberbase=Color.new(64,64,64)     numbershadow=Color.new(176,176,176)     pbSetSystemFont(overlay)     pokename = PBSpecies.getName(wantedData[0])     imagepos=[]     textpos=[        [_INTL("WANTED INFO"),26,16,0,base,shadow],        [_ISPRINTF("Dex No."),238,80,0,base,shadow],        [_ISPRINTF("{1:03d}",wantedData[0]),435,80,2,numberbase,numbershadow],        [_INTL("Species"),238,112,0,base,shadow],        [_INTL("{1}",pokename),435,112,2,Color.new(64,64,64),Color.new(176,176,176)],        [_INTL("Type"),238,144,0,base,shadow],        [_INTL("Level"),238,176,0,base,shadow],        [_INTL("{1} to {2}",wantedData[1], wantedData[2]),390,176,0,        Color.new(64,64,64),Color.new(176,176,176)],        [_INTL("Gender"),238,208,0,base,shadow],        [_INTL("{1}",g),435,208,2,Color.new(64,64,64),Color.new(176,176,176)],     ]     pbDrawTextPositions(overlay,textpos)     type1rect=Rect.new(0,pokemon.type1*28,64,28)     type2rect=Rect.new(0,pokemon.type2*28,64,28)     if pokemon.type1==pokemon.type2       overlay.blt(402,146,@typebitmap.bitmap,type1rect)     else       overlay.blt(370,146,@typebitmap.bitmap,type1rect)       overlay.blt(436,146,@typebitmap.bitmap,type2rect)     end   end end  ################################################################################ # GTS Core # By A Dork of Pork # Core GTS functions (Basically this is what you need to make a complete GTS # system) ################################################################################  module GTSCore      # Tests connection to the server (not used anymore but kept for possible use)   def self.testConnection     x = execute("test")     return x != ""   rescue     return false   end      # Our main execution method, since I'm too lazy to write GTSSettings::URL a lot   def self.execute(action, data={})     data["action"]=action     return pbPostData(GTSSettings::URL+GTSSettings::GAMEID.to_s, data)   end      # gets a new online ID from the server   def self.getOnlineID     r = execute("getOnlineID")     return r.to_i   end      # registers our new online ID to the server   def self.setOnlineID(id)     r = execute("setOnlineID", {"id" => id})     ret = r == "success"     print "GTS Error: #{r}" if !ret && $DEBUG     return ret   end      # checks whether you have a pokemon uploaded in the server   def self.hasPokemonUploaded?(id=$PokemonGlobal.onlineID)     r = execute("hasPokemonUploaded", {"id" => id})     e = !(r == "yes" || r == "no")     print "GTS Error: #{r}" if e && $DEBUG     return r == "yes"   end      # sets the pokemon with the given online ID to taken   def self.setTaken(id)     r = execute("setTaken", {"id" => id})     e = !r == "success"     print "GTS Error: #{r}" if e && $DEBUG     return r == "success"   end      # checks wether the pokemon with the give online ID is taken   def self.isTaken(id=$PokemonGlobal.onlineID)     r = execute("isTaken", {"id" => id})     e = !(r == "yes" || r == "no")     print "GTS Error: #{r}" if e && $DEBUG     return r == "yes"   end      # uploads a pokemon to the server   def self.uploadPokemon(pokemon, *wantedData)     if wantedData[0].is_a?(Array)       wantedData = wantedData[0]     end     pokemon.game_code = GTSSettings::GAME_CODE     r = execute("uploadPokemon", {"id" => $PokemonGlobal.onlineID,     "pokemon" => pokemon, "species" => pokemon.species,"level" => pokemon.level,     "gender" => pokemon.gender, "Wspecies" => wantedData[0],     "WlevelMin" => wantedData[1], "WlevelMax" => wantedData[2],     "Wgender" => wantedData[3]})     ret = r == "success"     print "GTS Error: #{r}" if !ret && $DEBUG     return ret   end      # uploads the newly traded pokemon to the given online ID to the server   def self.uploadNewPokemon(id, pokemon)     pokemon.game_code = GTSSettings::GAME_CODE     r = execute("uploadNewPokemon", {"id" => id, "pokemon" => pokemon})     ret = r == "success"     print "GTS Error: #{r}" if !ret && $DEBUG     return ret   end      # downloads a pokemon string with the given online ID   def self.downloadPokemon(id)     r = execute("downloadPokemon", {"id" => id})     ret = r != ""     print "GTS Error: #{r}" if !ret && $DEBUG     return ret ? r : false   end      # downloads the wanted data with the given online ID   def self.downloadWantedData(id)     r = execute("downloadWantedData", {"id" => id})     ret = r != ""     print "GTS Error: #{r}" if !ret && $DEBUG     return ret ? r.split(",") : false   end      # deletes your current pokemon from the server   def self.deletePokemon(withdraw = true)     r = execute("deletePokemon", {"id" => $PokemonGlobal.onlineID,     "withdraw" => withdraw ? "y" : "n"})     ret = r == "success"     print "GTS Error: #{r}" if !ret && $DEBUG     return ret   end      # gets a list of online IDs where the wanted data match up   def self.getPokemonList(*wantedData)     if wantedData[0].is_a?(Array)       wantedData = wantedData[0]     end     r = execute("getPokemonList", {"id" => $PokemonGlobal.onlineID,     "species" => wantedData[0], "levelMin" => wantedData[1],     "levelMax" => wantedData[2], "gender" => wantedData[3]})     return [r] if r == "nothing"     if (r.include?("/,,,/"))       return r.split("/,,,/")     else       return r.split(",")     end   end      # Reverse Lookup pokemon   def self.getPokemonListFromWanted(pokemon)     r = execute("getPokemonListFromWanted", {"id" => $PokemonGlobal.onlineID,     "species" => pokemon.species, "level" => pokemon.level,     "gender" => pokemon.gender})     return [r] if r == "nothing"     if (r.include?("/,,,/"))       return r.split("/,,,/")     else       return r.split(",")     end   end      # installs the MYSQL tables in the server   def self.install     return execute("createTables")   end end  ################################################################################ # Addons # By A Dork of Pork (pokemon to string and string to pokemon based from Maruno's #             MysteryGift packer/unpacker) # Addons to other scripts ################################################################################ class PokemonGlobalMetadata   attr_accessor :onlineID   attr_accessor :onlinePokemon   attr_accessor :keepGTS      alias gts_initialize initialize   # Keep your old online ID when doing newgame to prevent "spamming" the server   def initialize     gts_initialize          return if !GTSSettings::KEEP_OLD_IDS # return before we get your old ID back          save = RTP.getSaveFileName("Game.rxdata")     if FileTest.exist?(save)       file = File.open(save, "rb")       Marshal.load(file)       Marshal.load(file)       Marshal.load(file)       Marshal.load(file)       Marshal.load(file)       Marshal.load(file)       Marshal.load(file)       Marshal.load(file)       Marshal.load(file)       Marshal.load(file)       Marshal.load(file)       pg = Marshal.load(file)       file.close       @onlineID = pg.rawOnlineID     end     @keepGTS = false   end      def onlineID     if @onlineID == nil       id = GTSCore.getOnlineID       if id == 0         raise("GTS Error: Cannot get Online ID for GTS!")       end       if !GTSCore.setOnlineID(id)         raise("GTS Error: Cannot set Online ID for GTS!")       end       @onlineID = id     end     return @onlineID   end      # The rawOnlineID doesn't have the checksum to get a new ID, this is used for   # when you do new game.   def rawOnlineID     if @onlineID       return @onlineID     else       return nil     end   end end  # Add a game_code field and to_s method to the pokemon class class PokeBattle_Pokemon   attr_accessor :game_code   def to_s     ret=[Zlib::Deflate.deflate(Marshal.dump(self))].pack("m")     return ret   end end  # Add a to_pokemon method to the string class class String   def to_pokemon     ret=Marshal.restore(Zlib::Inflate.inflate(unpack("m")[0]))     return ret   end end  # Delete Pokemon if we began a newgame alias pbSaveGTS pbSave def pbSave(safesave=false)   if GTSCore.testConnection     if !$PokemonGlobal.keepGTS       if GTSCore.deletePokemon         $PokemonGlobal.keepGTS=true       end     end   end   pbSaveGTS(safesave) end

---
## [fuglore/PD2-Hyper-Heisting](https://github.com/fuglore/PD2-Hyper-Heisting)@[726da759fa...](https://github.com/fuglore/PD2-Hyper-Heisting/commit/726da759fa67131b0649c9604c25fd0e02fe58b8)
#### Monday 2020-07-20 00:56:59 by Neslon-Poggers

Revert "i fuck your mother @ BADATNAMES85"

This reverts commit 7dfa8df462f1ea8c93ddcb519210f64532baa23e.

---
## [WaspStation/WaspStation-1.0](https://github.com/WaspStation/WaspStation-1.0)@[3b275a2a33...](https://github.com/WaspStation/WaspStation-1.0/commit/3b275a2a33a3c751d2183ec2c2fe8412e1036b08)
#### Monday 2020-07-20 02:22:44 by Shayne Fitzgerald

Make buzzwords actually usable by insectoid species (#335)

* actually make buzzwords a shared language among insects.

* fluttering FUCKING MOTHS.

* fucking caaaaaps

* three PRs in 5 hours and I still can't remember to import new files

* an S

* well my mojo's gone for the night time to drown myself in liquor

Co-authored-by: Shayne Fitzgerald <robotech417@yahoo.com>
Co-authored-by: Mark Suckerberg <tommjd54321@outlook.com>

---
## [CluckeyMcCormick/fictional-guacamole](https://github.com/CluckeyMcCormick/fictional-guacamole)@[5ed48d9a5b...](https://github.com/CluckeyMcCormick/fictional-guacamole/commit/5ed48d9a5b40bbcdc0646491ca67a7c012d40a39)
#### Monday 2020-07-20 05:34:02 by frick-nedrickson

Add wheat (dear god)

Okay, so I wanted to add some dynamic wheat that grew or shrank with
the farm fields.

At first I thought - "that's easy! I'll just slap something together
with quads and and a plane!" The issue there was it didn't expand
easily - modifying meshes directly in the code was a headache and
inconsistent. Plus, with how Godot handles materials, we would have
needed to rescale the material's UV each time. This would have
affected all the wheat textures, globally, which would have been a
giant mess.

I also had the idea for the field to "part" as creatures / NPCs walked
through it. The mesh wasn't working, so I was about to shelve that
whole plan, when I had an idea - what if we used Godot's 3D GridMap to
place individual "units" of wheat that could be added and removed
dynamically.

This turned out to be a terrible idea. Not because it didn't work, but
purely because of the art pipeline.

You see, the GridMap requires a resource called a "MeshLibrary". This
is a scene of nothing but meshes that gets converted into a special
format for use with the GridMap. The only issue was that I was making
my "Wheat Cubes" out of three separate meshes instead of one cohesive
mesh. This was translating in the MeshLibrary as a single
upward-facing plane.

So I needed to make a Cube capable of using multiple materials. And
that involved me learning how to use Blender. I was not happy, but I
did it.

I also had to make a texture for the top of the wheat (which I was
happy with) and the side of the wheat (which I am NOT HAPPY WITH). So
I had to put in way more effort than I wanted to and I hate the wheat
vomit texture I made but WE HAVE WHEAT!

---
## [mrakgr/The-Spiral-Language](https://github.com/mrakgr/The-Spiral-Language)@[2744869e99...](https://github.com/mrakgr/The-Spiral-Language/commit/2744869e99cc88e2064939a55d30a590fd202bfe)
#### Monday 2020-07-20 09:18:06 by Marko GrdiniÄ

"9:45am. Today it seems I stayed in bed longer than usual. I played Project Brutality 3.0 until late, so far I like it more than all the other Doom mods that I've tried. It is great.

Lesson number one from my life - channel your will into where it is possible. You benefit nothing from taking on boredom and humiliation in the long run. The story of the Inspired was inspiring to me enough to accept the curse of labor. And that is pretty much it.

I need to do this thing. I need to complete Spiral v0.2, and then get my hands on those neurochips. When I do, I'll try making the poker agent again. If I can go from 1k hands per second to 1M or more, then that will be a game changer either way. I'll implement both the game and the agent on that device.

GPUs are just excedingly poorly suited for this sort of thing. They were useful enough as a motivator, but just throughput will not cut it. I need latency as well.

One thing has been proven to me - I do not actually have any capability to anticipate how well arbitrary models and algorithms will perform in practice. But one thing I can anticipate is how my perception of them will change once they start to work. Ultimately, the perfomance regime you are operating becomes your reality. And I need to break the prison imposed on me by GPUs.

I do not really know once I have the agent whether I will use it to make real life money, but one thing I am sure is that I want to make it. I need to get good at this sort of thing.

I am just so tired. I have been tired from 2015 onwards, so me saying that does not mean much, but I haven't been able to get the creative release I so wanted in RL yet. If I could just tap into it, I get closer to the essence of what I want to do. If I can just hit this goal, I'll be able to put all my failures up to now behind me.

I want a real success in my life. Just making a language is not enough - I want to use it in a domain where no other languages can exceed it.

10:05am. Let me slack for a while and then I will start. Today I will begin work on integrating the block parser with the language server.

10:35am. Done slacking. Let me resume the run.

...Now, I said I would do this part relatively quickly so I can move on to practical things, but I think I will stick to this for a good long while. Even before typechecking and the prepass, I want to get all the editor related stuff out of the way. That will take me a while.

What I am saying is that I got the urge to do this. I'll go beyond just semantic tokenization and do all the prepass related highlighting done as well. At that point the editor support should be in a pretty good shape.

10:45am. It does not matter if this takes me an entire month. I should take this on and feel satisfied after it is done. Thankfully unlike the parser which was one huge intervowen thing that I've finally managed to simplify, this auxiliary stuff is a series of different things.

This part and the typechecking parts are the pieces that will trully be new to Spiral.

The prepass itself will only have compilation of mutually recursive functions added to it, and the partial evaluator will only need to tackle prototypes as its new responsibility. Everything else with regards to them is ground that I've covered and dealt with before. They should go smoothly. The codegen is barely worth mentioning - it is the most straightforward of all passes and nothing new needs to be done there. It had some challenges back in 2017 and 2018, but the way to do proper code generation from the partially evaled AST has been a solved problem for a while now.

10:50am. Though it will be time consuming, at least the editor support stuff will be relatively well isolated from the rest, and the rewards of my work will be immediatelly visible on the screen. Unlike the parser whose benefits I've only been imagining in my head for a while now, here I will get more immediate feedback.

And now that I am mentioning it, that was only the case thus far - I can in fact get feedback from the parser now.

11am. That should be my priority for today.

I need to switch gears. It is time to refresh my memory of the server. Then I have to start thinking of how to plug the parser in.

I won't stress myself to do a lot today. Just do a little. I won't force motivation or try to do a large quantity of work as if the fate of the world depends on it. The quantity will come when it does.

11:15am. If needed, I'll just meditate today of what I need to do. Since I am in a ranting mood, let me think until I feel like doing."

---
## [cyanreg/mpv](https://github.com/cyanreg/mpv)@[5114c69c7f...](https://github.com/cyanreg/mpv/commit/5114c69c7f85e7cd38d6928e874c5b44c951be60)
#### Monday 2020-07-20 11:59:41 by wm4

demux: change hack for closing subtitle files early

Subtitles (and a few other file types, like playlists) are not streamed,
but fully read on opening. This means keeping the file handle or network
socket open is a waste of resources and could cause other weird
behavior. This is why there's a hack to close them after opening.

Change this hack to make the demuxer itself do this, which is less
weird. (Until recently, demuxer->stream ownership was more complex,
which is why it was done this way.)

There is some evil shit due to a huge ownership/lifetime mess of various
objects. Especially EDL (the currently only nested demuxer case)
requires being careful about mp_cancel and passing down stream pointers.

As one defensive programming measure, stop accessing the "stream"
variable in open_given_type(), even where it would still work. This
includes removing a redundant line of code, and removing the peak call,
which should not be needed anymore, as the remaining demuxers do this
mostly correctly.

---
## [cyanreg/mpv](https://github.com/cyanreg/mpv)@[7fad173cfd...](https://github.com/cyanreg/mpv/commit/7fad173cfda06724a0af33091c26eec937d0c6cf)
#### Monday 2020-07-20 11:59:41 by wm4

demux, demux_edl: add extension for tracks sourced from separate streams

This commit adds an extension to mpv EDL, which basically allows you to
do the same as --audio-file, --external-file, etc. in a single EDL file.

This is a relatively quick & dirty implementation. The dirty part lies
in the fact that several shortcuts are taken. For example, struct
timeline now forms a singly linked list, which is really weird, but also
means the other timeline using demuxers (cue, mkv) don't need to be
touched. Also, memory management becomes even worse (weird object
ownership rules that are just fragile WTFs). There are some other
dubious small changes, mostly related to the weird representation of
separate streams.

demux_timeline.c contains the actual implementation of the separate
stream handling. For the most part, most things that used to be on the
top level are now in struct virtual_source, of which one for each
separate stream exists. This is basically like running multiple
demux_edl.c in parallel. Some changes could strictly speaking be split
into a separate commit, such as the stream_map type change.

Mostly untested. Seems to work for the intended purpose. Potential for
regressions for other timeline uses (like ordered chapters) is probably
low. One thing which could definitely break and which I didn't test is
the pseudo-DASH fragmented EDL code, of which ytdl can trigger various
forms in obscure situations. (Uh why don't we have a test suite.)

Background:

The intention is to use this for the ytdl wrapper. A certain streaming
site from a particularly brain damaged and plain evil Silicon Valley
company usually provides streams as separate audio and video streams.
The ytdl wrapper simply does use audio-add (i.e. adding it as external
track, like with --audio-file), which works mostly fine. Unfortunately,
mpv manages caching completely separately for external files. This has
the following potential problems:

1. Seek ranges are rendered incorrectly. They always use the "main"
stream, in this case the video stream. E.g. clicking into a cached range
on the OSC could trigger a low level seek if the audio stream is
actually not cached at the target position.

2. The stream cache bloats unnecessarily. Each stream may allocate the
full configured maximum cache size, which is not what the user intends
to do. Cached ranges are not pruned the same way, which creates disjoint
cache ranges, which only use memory and won't help with fast seeking or
playback.

3. mpv will try to aggressively read from both streams. This is done
from different threads, with no regard which stream is more important.
So it might happen that one stream starves the other one, especially if
they have different bitrates.

4. Every stream will use a separate thread, which is an unnecessary
waste of system resources.

In theory, the following solutions are available (this commit works
towards D):

A. Centrally manage reading and caching of all streams. A single thread
would do all I/O, and decide from which stream it should read next. As
long as the total TCP/socket buffering is not too high, this should be
effective to avoid starvation issues. This can also manage the cached
ranges better. It would also get rid of the quite useless additional
demuxer threads. This solution is conceptually simple, but requires
refactoring the entire demuxer middle layer.

B. Attempt to coordinate the demuxer threads. This would maintain a
shared cache and readahead state to solve the mentioned problems
explicitly. While this sounds simple and like an incremental change,
it's probably hard to implement, creates more messy special cases,
solution A. seems just a better and simpler variant of this. (On the
other hand, A. requires refactoring more code.)

C. Render an intersection of the seek ranges across all streams. This
fixes only problem 1.

D. Merge all streams in a dedicated wrapper demuxer. The general demuxer
layer remains unchanged, and reading from separate streams is handled as
special case. This effectively achieves the same as A. In particular,
caching is simply handled by the usual demuxer cache layer, which sees
the wrapper demuxer as a single stream of interleaved packets. One
implementation variant of this is to reuse the EDL infrastructure, which
this commit does.

All in all, solution A would be preferable, because it's cleaner and
works for all external streams in general.

Some previous commit tried to prepare for implementing solution A. This
could still happen. But it could take years until this is finally
seriously started and finished. In any case, this commit doesn't block
or complicate such attempts, which is also why it's the way to go.

It's worth mentioning that original mplayer handles external files by
creating a wrapper demuxer. This is like a less ideal mixture of A. and
D. (The similarity with A. is that extending the mplayer approach to be
fully dynamic and without certain disadvantages caused by the wrapper
would end up with A. anyway. The similarity with D. is that due to the
wrapper, no higher level code needs to be changed.)

---
## [mrakgr/The-Spiral-Language](https://github.com/mrakgr/The-Spiral-Language)@[1f7d800cbd...](https://github.com/mrakgr/The-Spiral-Language/commit/1f7d800cbd5fa7561e9fa63205bcacd99d9d325d)
#### Monday 2020-07-20 13:17:15 by Marko GrdiniÄ

"1:15pm. Done with the break. Instead of just sitting here, let me do some work.

```fs
type Block = {block: LineToken [] []; offset: int}
```

I guess I should start with this.

Let me extend it with the errors.

```fs
type Block = {block: LineToken [] []; offset: int; errors: VSCError []}
```

Now let me make the trace.

...No, forget this. Let me use reference equality.

```fs
type Block = {block: LineToken [] []; offset: int; errors: VSCError [] option}
```

No, ref equality with a dictionary would cause garbage to accumulate.

So how about this then?

1:30pm. Hmmm, I am thinking about it. Even if it means iterating through the whole block again, I do not want to put any more stuff in the blockizer.

```fs
type Block<'a> = {block: LineToken [] []; offset: int; meta: 'a}
```

Let me do this.

1:40pm.

```fs
let block_init (block : LineToken [] []) offset =
    let env = failwith ""
    {block=block; offset=offset; meta=BlockParsing.top_statement env}
```

What I will do is just call `block_init` to do the meta.

I've forgotten that I actually need to convert that line token array so it has VSCode ranges.

```fs
let inline try_current d f = try_current_template d (fun (p,t) -> f (range_to_vscrange p, t)) (fun () -> Error [])
```

Ah, shit. Why am I doing this. I should just have used vs code ranges directly.

```fs
let eob d =
    let i = index d
    let len = d.tokens.Length
    if i = len then Ok()
    elif 0 <= i && i < len then let r,_ = d.tokens.[i] in Error [{line=r.line; from=r.nearTo; nearTo=r.nearTo+1}, ExpectedEob]
    else failwith "Compiler error: The block parser's pointer is out of bounds in the eof parser."
```

This thing is nowhere used and yet I did not even notice it. It is actually using the wrong kind of range here.

```fs
let inline range exp s =
    let i = index s
    exp s |> Result.map (fun x ->
        let i' = index s
        if i < i' then
            let r, r' = fst s.tokens.[i], fst s.tokens.[i'-1]
            ({line=r.line; character=r.from}, {line=r'.line; character=r'.nearTo} : Config.VSCRange), x
```

This I can simplify.

1:55pm.

```fs
    let application_tight d =
        let next = expressions
        let inline expr_tight (d: Env) =
            let i = index d
            if 0 < i && i < d.tokens.Length then
                let r,r' = snd (fst d.tokens.[i-1]), fst (fst d.tokens.[i])
                if r.line = r'.line && r.character = r'.character then next d else Error []
```

Had to adjust the way ranges are done in a bunch of places.

```fs
let range_to_vscrange (x : Range) : Config.VSCRange = {line=x.line; character=x.from}, {line=x.line; character=x.nearTo}
```

Let me take this out.

2pm. Right now, I am lost in daydreams.

2:05pm. Yeah, in review, my social skills are too low.

As I looked for the answer, I let myself be dragged around way too much by my environment. And I made excuses and delusions for why I am doing things I find unpleasant. And for the past month I've been flabbergasted by an event that I do not how to deal with.

Well, you start dealing with it once you decide what is right and wrong.

Real life is not that much different from programming in that respect. I mean, I am dissappointed. IF you lift weights, you'd expect to develop muscles after some point. On my end, so many abilities I've wanted to develop mentally were a dead end. It is all because I am human.

And because I was late in noticing that, the one thing I needed to do ASAP - controlling my environment is what I left for last.

2:15pm. I am insane. I've definitely had bouts of crazy behavior in the past, the kind where afterwards I could not help but wonder what was I thinking. Well, I am smart so I know exactly why and what I was thinking. For intelligent people, crazy behavior is just a cope against a broken foundation. Like fish out of the water, they cannot help, but asphyxiate when out of their comfort zone. The things I always regret the most in those situations is when I act like an animal myself.

Since I am fixing up Spiral, I might as well deal with my social foundation while I am at it. I can't leave this aspect of myself alone so I've been dedicating thought to it.

I can't be like those idiots who go from interview to interview trying to get lucky.

I can't live my life trying to will reality so it accomodates what I want. Not even a single inch.

While thinking up my theories, I've made a special place in my mind where I am able to look at reality what it is. I need to make that the real me.

The most important thing is to recognize one's own limit, and never to cross it.

2:25pm. I need to recognize the fact that my mind does not work the same way as anybody around me.

When I was a kid I thought the others would grow out of it eventually, but in fact we just seem to be growing further apart as time goes on.

Figuring out the self improvement loop 7 years ago broke me. When I was a kid I thought that the differences between people were irrelevant, but finally, I had found a difference that was not. I thought that the axiom of power as the purpose of life was out of the field, but not important enough to be worth bemoaning about. But once I found the connector, the 'Necromutation is Transcendence' thing, that is when things changed. Suddenly, living by that axiom became realistic. If not today, then tomorrow.

3pm. Had to take a break. Let me continue the rant. I am in a ranting mood.

Everything is done for a reason. It sometimes happens in programming that you make a big piece of code and then during testing uncover a bug. Most of the time that can be dealt with, but sometimes you realize that the architecture is fundamentally broken and the whole thing has to be rewritten.

That is the relationship between me accepting the truth of the self improvement loop as iterative suicide, and the rest of my life. I've been looking for the connector to omnipotence for 15 years by that point, and that truth invalidated pretty much all of that time. I still haven't coped with it even now.

3:05pm. When your footing is unstable, you cannot help, but act like a crank.

What rules can you believe in? What rules can be realistically set and obeyed?

Boredom is like wine - a little bit is good, but when imposed it just leads to poor results.

I need to set rules to my interactions. And just like with programming, I need to think about them from every conceivable angle. Sure, I'll fail, but only imposing the correct frame of mind upon myself will I get better. So far, I've only been imposing the wrong frame of mind.

Right now I am still mad about that thing a month ago - good. Maybe I'll change this time. Usually, I put things behind me quickly enough. Maybe this time I'll draw a proper lesson from such an event.

3:15pm. To live is to fight, but exactly what will you fight for? The first battle is to discover that.

Agh, I've started this rant just as I was in the middle of programming, but I do not feel like it anymore. Let me take a nap for a while. Then I'll finish what I was doing."

---
## [mrakgr/The-Spiral-Language](https://github.com/mrakgr/The-Spiral-Language)@[fdca6b5293...](https://github.com/mrakgr/The-Spiral-Language/commit/fdca6b5293393484dc24fd91a5ac025cfc369749)
#### Monday 2020-07-20 16:04:02 by Marko GrdiniÄ

"5:15pm. It seems I was in bed thinking for two hours.

Let me write the thoughts down. No matter what my failures are and how many of them, I did succeed at the one thing in life that really mattered to me. The the secrets of the self improvement loop had I not looked for them are not something that anybody else would have explained to me. So as trite as the theories might seem at first glance, the achievement for their discovery belong to me and nobody else.

I won that battle.

Though I've forgotten...or more like, I've refused to accept lately, a lot of my past failure in the past were calculated with the express purpose of buying time for me to solve those riddles. Now that this has been done I should take this as a sign to stop acting like a moron.

Anyway, as unfortunate as it is, I am not entirely through that 'buying time' phase just yet.

Sure, I might need Spiral to use those neurochips effectively, but it is still the case that I am running away from the fact that I cannot really make those agents just yet. I can't deliver just yet. I cannot be myself until that happens.

Still, if it is just finding a reasonable starting point, those chips should fit the bill. 1M games per second is not a joke. Even tabular RL which 100x faster than deep RL is only 100k games per second. But tabular RL requires a lot of (non-contiguous) memory so it is quite realistic to expect that neural nets would actually be better than tabular RL even in terms of latency when done properly. Once I get my hands on this, those human pros are pretty much going to be dead should I decide to turn on them.

5:25pm. Rules...the answer to being strong in social situations is to imagine the failure cases ahead of time and accept them. Take nothing for granted. Do not make assumptions and then get mad when they fail to materialize.

If I have to make snap decisions in the future, do not go with the flow. Take the time to think. If there is no time to do that, refuse.

5:30pm. Should my past sins come back to haunt me, I need to be ready to fight. I cannot regret them. I can make apologies and excuses, but what is the most important is to make decisions that further my own power.

This is especially important from here on out - who knows what my agents will do, and I do not want to get morality jacked, or be regretful and weak like I am now. Since they will be my power, I need to take responsibility when they clobber some NPCs.

5:35pm. It is the law, the sense of my own law that I am lacking. I lack righteousness.

I need to develop it. Otherwise I won't be able to deal with failure.

The mainstream strands of morality really aren't doing it for me. Most importantly, once I have that, rather than assume that everybody would be on my team if all the secrets were cleared up, I need to evict those who aren't paying rent.

5:40pm. It is all about what one is willing to accept and not.

I might have solved some important things related to life, but I need to accept that there is a difference between my target audience and background characters.

Now that I think about it, I am reminded of that report I read about US building empty schools in Afganistan and the army officer taking offense at the retarded goat herders there not seeing a purpose to them. Rejection of deeply seated values is a bitch, isn't it?

5:45pm. Rather than be pissed all the time, I should take it as a sign to work on my social skills. The only time I've ever used my brain in such situation is when doing time buying maneuvers so it became a habit by this point. The way to break that is to obey the rules I will set out for myself ahead of time. Then the way to play will just be to abide by them.

Who knows, I did not like roguelikes before I started being careful and thorough in my thinking, so maybe once I get into it the social game will get more interesting.

5:50pm. The Law is what is important. Whatever decision I make, should have a branch leading to it somewhere. Break the old habits.

It won't be long until Spiral is finished and I have emerged from my 'buying time' period completely.

5:55pm. Damn, I really didn't do much today. But I should be able to do a lot of work once I set my mind to it properly. I need to go beyond what I've done so far. Just like my vivid imagining is allowing me to excell in programming, I need to believe that the rules I derive from that will serve me well elsewhere.

I need to believe that my emotions are just tools to let me formalize the rules. Direct action on them is a poor strategy for what I want to do."

---
## [fuglore/PD2-Hyper-Heisting](https://github.com/fuglore/PD2-Hyper-Heisting)@[b7c8ff20a9...](https://github.com/fuglore/PD2-Hyper-Heisting/commit/b7c8ff20a9627887131f13536f0f20346c34f982)
#### Monday 2020-07-20 17:04:43 by Neslon-Poggers

Revert "Revert "i fuck your mother @ BADATNAMES85""

This reverts commit 726da759fa67131b0649c9604c25fd0e02fe58b8.

---
## [BananasToaster/BananasToaster.github.io](https://github.com/BananasToaster/BananasToaster.github.io)@[a889e88872...](https://github.com/BananasToaster/BananasToaster.github.io/commit/a889e88872ac78c906360807d8f93064ec84ba91)
#### Monday 2020-07-20 18:09:03 by BananasToaster

big update

cuz some fucking retards kept leeching my shit, so i added license and some cool updates yeeeeeeeeeeeet

---
## [Subhendu-io/bolt-architecture](https://github.com/Subhendu-io/bolt-architecture)@[f983f894f3...](https://github.com/Subhendu-io/bolt-architecture/commit/f983f894f3a1565ea69754cc85f71c9e933c5d94)
#### Monday 2020-07-20 18:40:22 by Subhendu

BOLT-001: Initializing home page for the repo.

Express.js is great frameworks for making a node.js REST APIs however it doesnât give you any clue on how to organizing your node.js project. While it may sound silly, this is a real problem. The correct organization of your node.js project structure will avoid duplication of code, will improve stability, and potentially, will help you scale your services if is done correctly. This post is extense research, from my years of experience dealing with a poor structured node.js project, bad patterns, and countless hours of refactoring code and moving things around. If you need help to align your node.js project architecture, just drop me a letter at subhendu.luv@gmail.com

---
## [json-schema-tools/transpiler](https://github.com/json-schema-tools/transpiler)@[4d144db857...](https://github.com/json-schema-tools/transpiler/commit/4d144db857f0b3fc92b27ac4828151abd09f3fdd)
#### Monday 2020-07-20 19:31:06 by BelfordZ

chore(release): 1.2.0 [skip ci]

# [1.2.0](https://github.com/json-schema-tools/transpiler/compare/1.1.0...1.2.0) (2020-07-20)

### Bug Fixes

* all unit tests passing ([15cb174](https://github.com/json-schema-tools/transpiler/commit/15cb174fa8d910424aaa1efcca11bae6a0932e9c))
* almost there... ([0f5db50](https://github.com/json-schema-tools/transpiler/commit/0f5db5041fdf458ee4d3a356bb2b50bfc1c44767))
* broken test and extra garbage log ([65739ff](https://github.com/json-schema-tools/transpiler/commit/65739ff355159d5f67907517d40f238a36174838))
* getting close to being the best in the world ([31b9168](https://github.com/json-schema-tools/transpiler/commit/31b9168253ba8a80a2c04ea146dc3938757c796a))
* oh my god its alive ([cd0b386](https://github.com/json-schema-tools/transpiler/commit/cd0b38693cab2755a149e4579ce5f2f907c9509c))
* things looking good ([36e4b1f](https://github.com/json-schema-tools/transpiler/commit/36e4b1f5a5d7d591c88146b2161d97086318bf2e))
* update package lock after rebase ([5692401](https://github.com/json-schema-tools/transpiler/commit/5692401b32cbbb561fb92bf1ce735a22544663b7))
* wip wip ([a92df4a](https://github.com/json-schema-tools/transpiler/commit/a92df4a8edee6bb9705d14da470ca57272e4dc76))

### Features

* fuck yeah boys!! ([a125582](https://github.com/json-schema-tools/transpiler/commit/a12558237b660f7fb95e3914525b4281d955406e))
* referencer ownage ([469f8db](https://github.com/json-schema-tools/transpiler/commit/469f8dbc23e310a9a14667c55a75e7846647cb90))

---
## [DarkoniusXNG/oaa](https://github.com/DarkoniusXNG/oaa)@[adcb039f2a...](https://github.com/DarkoniusXNG/oaa/commit/adcb039f2ac3df5a62d02fa90a3a01a75af6a55d)
#### Monday 2020-07-20 23:53:19 by Darko V

Balance Part 5

* Buffed mana costs of the following abilities:
1) Earthshaker Echo Slam
2) Elder Titan Earth Splitter
3) Faceless Void Chronosphere
4) Nature's Prophet Wrath of Nature
5) Jakiro Macropyre
6) Kunkka Ghostship
7) Lion Finger of Death
8) Luna Eclipse
9) Magnus Reverse Polarity
10) Shadow Fiend Requiem
11) Nyx Assassin Vendetta
12) Oracle False Promise
13) Puck Dream Coil
14) Pugna Life Drain
15) Queen of Pain Sonic Wave
16) Shadow Shaman Mass Serpent Ward
17) Timbersaw Chakram
18) Snapfire Mortimer Kisses
19) Spirit Breaker Nether Strike
20) Tidehunter Ravage
21) Tusk Walrus Punch
22) Vengeful Spirit Nether Swap
23) Venomancer Poison Nova
24) Viper Viper Strike
25) Warlock Chaotic Offering
* Replaced Underlord +80 Attack Speed talent with +40 movement speed talent.
* Replaced Underlord +30% Crit talent with Firestorm damage talent (it will probably need a buff).
* Reverted all Chaos Knight talents to vanilla except bonus strength talent.
* Fixed Hand of Midas item costs.

---

# [<](2020-07-19.md) 2020-07-20 [>](2020-07-21.md)

