# [<](2020-10-23.md) 2020-10-24 [>](2020-10-25.md)

1,965,352 events, 1,114,039 push events, 1,607,754 commit messages, 95,584,469 characters


## [smolespi/Hibiki](https://github.com/smolespi/Hibiki)@[9dfd47ab73...](https://github.com/smolespi/Hibiki/commit/9dfd47ab736b58b6843a5b1a071be50bd1f9d87a)
#### Saturday 2020-10-24 01:45:04 by Espi

src: unfuck this stupid fucking dogshit javascript code that i never want to touch in my life ever again

---
## [dogelore-tcg/dogelore-tcg.github.io](https://github.com/dogelore-tcg/dogelore-tcg.github.io)@[76dd3bc7ed...](https://github.com/dogelore-tcg/dogelore-tcg.github.io/commit/76dd3bc7edeaea0db2df041ba074b228ac612d94)
#### Saturday 2020-10-24 04:35:39 by Zachary Pike

sonic pissed on my fucking wife

I've come to make an announcement: Shadow the Hedgehog's a bitch-ass motherfucker. He pissed on my fucking wife. That's right. He took his hedgehog fuckin' quilly dick out and he pissed on my FUCKING wife, and he said his dick was THIS BIG, and I said that's disgusting. So I'm making a callout post on my Twitter.com. Shadow the Hedgehog, you got a small dick. It's the size of this walnut except WAY smaller. And guess what? Here's what my dong looks like. That's right, baby. Tall points, no quills, no pillows, look at that, it looks like two balls and a bong. He fucked my wife, so guess what, I'm gonna fuck the earth. That's right, this is what you get! My SUPER LASER PISS! Except I'm not gonna piss on the earth. I'm gonna go higher. I'm pissing on the MOOOON! How do you like that, OBAMA? I PISSED ON THE MOON, YOU IDIOT! You have twenty-three hours before the piss DROPLETS hit the fucking earth, now get out of my fucking sight before I piss on you too!

---
## [maveric-coder/python_practice](https://github.com/maveric-coder/python_practice)@[ca59f1cfc8...](https://github.com/maveric-coder/python_practice/commit/ca59f1cfc8c65afde51e74a0fa649c054d2fee26)
#### Saturday 2020-10-24 04:45:03 by Anand

Create in-love-with-primes.py

https://www.hackerearth.com/practice/math/number-theory/primality-tests/practice-problems/algorithm/in-love-with-primes/description/


Little Arjit is in love with Deepa. They have always thought of themselves as the ideal couple - the best, possible match they could've managed. (No kidding!) And like every other couple, they promised each other not to fight after every other fight. But, when has that happened before?

But, this is a different couple - this is a programming couple - and they argue on weird things, like Fibonacci numbers, prime numbers, Sterling numbers, and what not!

Their recent fight might seem silly to a lot of people, but it is a matter of serious concern for both of them. They have bought a cake, and they weighed it in milligrams - the weight of the cake is always even and now they wish to divide the cake between them in some way, that both of them are satisfied.

Arjit challenges Deepa that if she can divide the weight of the cake as sum of two prime numbers between them, she can have the entire cake - and if she fails to do so, he'll get the cake.

The argument is getting more, and more heated now - please help them sort out their stupid arguments or an easier way would be to help them figure out who is going to have the cake.

Input Format:
The first line will contain a number, tc, denoting the number of test cases.

The next tc lines will contain an even number, denoting the weight of the cake in milligrams.

Output Format:
Print "Arjit" or "Deepa" according to the winner.

Constraints:
1 <= tc <= 100
1 <= n <= 100000
1 is NOT a prime number.

SAMPLE INPUT 
2
4
8
SAMPLE OUTPUT 
Deepa
Deepa
Explanation
4 can be represented as 2 + 2, so Deepa wins. 8 can be represented as 5 + 3, so Deepa wins.

---
## [TheUprightGuy/GS-ProtoThree](https://github.com/TheUprightGuy/GS-ProtoThree)@[ef9c578c3d...](https://github.com/TheUprightGuy/GS-ProtoThree/commit/ef9c578c3deff10f04e91229d0cb52a398187170)
#### Saturday 2020-10-24 05:33:25 by Jack

Hi, performance upgrades are done, also a commented out line of code is throwing a fatal error

Kill me please.
Douse this build with holy water on push, it is the only way to ensure its safety against the darkness of the merge errors.
May the Lord and Jesus Christ have faith that you complete your task.
Amen.

---
## [mrakgr/The-Spiral-Language](https://github.com/mrakgr/The-Spiral-Language)@[1896bb09c2...](https://github.com/mrakgr/The-Spiral-Language/commit/1896bb09c2aabe691551cdde665a6e3d395b893f)
#### Saturday 2020-10-24 08:58:38 by Marko Grdinić

"9:50am. Yesterday I went to bed at 12pm.

https://community.acer.com/en/discussion/449171/aspire-e-15-wifi-dropping

This crappy issue on my bro's laptop is part of the reason.

Both my father and I haven't had any luck in dealing with this. When the guy brought me the laptop he said that the connection kept disconnecting, but I myself can't get it to turn on at all. I can't find anything on the internet to fix it so I am thinking of alternatives. As it turns out USB stick adapters exist and they go for 5-15$. Sure they would take an USB slot, but that is a reasonable tradeoff in this situation.

I want to avoid the situation where my brother is forced to do a refund, so I will make this suggestion.

10am. Hmmmm, my father still wants to fiddle with it. Well so be it. He can have it - there are some choices like trying to install Windows 7 in case the newer OS updates are doing something strange, but at that point I would be trying out random things in hopes of a miracle. I have better things to do with my time.

10:10am. Let me chill. Besides this laptop distraction I've been in a mood last night.

The fact that I can literally feel right now, in the programming part of my brain that I can beat the market is rousing my spirits. This isn't just idle boasting. Look at a junk bond fund chart, and you will see them having very persistent uptrends and downtrends on the daily scale.

The stock market is similar except on the monthly scale. When a particular group is in a strong uptrend, it very rarely has a significant negative month. It is all either up or flat. You make some allowances for when the general market is correcting. If it does make a negative month, then you can hypothesise that that the uptrend is broken. You get out and wait a month - if the market retraces the losses, you get back in.

Towards the end of my trading journey years ago, I actually hadn't seen this.

Like for example, I read Darvas and O'Neil's books - and they all use a price sensitive trend following system. Cutting your loss if a stock falls 7-10% is the notable feature of such systems. Together with what I put here from elsewhere, this make me obsessed about stocks making new highs. I spent years tracking that kind of system and getting nowhere with it.

10:25am. At first I was very inexperienced, but one thing throughout the six year journey that I could never figure out is why general trend following fails.

By that I mean - even though the stock market has a strong upward bias, I could never get around the fact that buying new high and selling lows is actually a poor system in the stock market. Especially if you are trading something like stock indices.

Even towards the end of the journey when the accumulated evidence was large that I really should be ignoring the daily price swings and thinking in terms of two week moves, I could not really accept that there is no good way of avoiding market corrections. I mean, there were people like Gary Smith who after 20 years of failure went on to very rarely having losing months so why couldn't I?

Before the 00s, it does seem that the markets had a strong short term persistent momentum. You can see it on some illiquid instrumets even today. The traders of those days knew to take advantage of that.

10:35am. But ultimately it does not matter. I can finally see that now. It does not matter that I cannot avoid corrections these days. It does not matter that I will have losing months or have to withstand long periods where the market goes nowhere.

New high and new lows do not matter, I can finally state that now. Daily non-persistence does not matter.

What really matters is the dance you do with the market. By making simple assumptions about price movement 3 months in advance it is possible to fade the daily noise.

10:45am. The rhythm you are trading in really does matter.

I mean, it would be beyond my imagination that once you buy you should hold for a month - if the stock goes down, shouldn't you cut it regardless of how long you held it? That is good trading isn't it according to all the books? And if it goes up you should get more bullish and buy it back.

It is all just noise. The infromation price gives you is also dependent on time. None of the books I've read talked about time.

It is really hard to see. I can only really see it because I took a step back and threw in the towel. When you are in the market - you can't be a budha. The urge is to improve and to fight. You never want to accept luck. You want to impose your own reality and stuggle.

10:50am. Well, let me put that rant aside. I really should be focusing on programming, but even before that let me chill. I want to do my morning reading and have breakfast. No point in starting anything now.

I've been thinking about concurrency in general. I have some thought about where I am going wrong and how to resolve the struggle, but I'll leave that rant for the follow up entries.

10:55am. I've been thinking about my thinking when it comes to this latest challenge, and definitely have some holes in my approach."

---
## [amirothman/dmca](https://github.com/amirothman/dmca)@[9687a19b72...](https://github.com/amirothman/dmca/commit/9687a19b723ba152408fdc57fecf03b6daa13760)
#### Saturday 2020-10-24 10:11:57 by Amir Othman

suck my dick.

dumb fucks doing fucking dumb shit needs to stop

---
## [AA2Hackanon/AA2Face](https://github.com/AA2Hackanon/AA2Face)@[98c215b24b...](https://github.com/AA2Hackanon/AA2Face/commit/98c215b24b87a72e1d21cbe259dbafb069578360)
#### Saturday 2020-10-24 11:10:41 by AA2Hackanon

- filters personalities by gender so i dont have to listen to the fucking salamander every time i test this shit
- added support for random button
- questioned myself why anybody puts males into their classes. didnt find a conclusion
- disable page control if only 1 page of personalities exist

---
## [mrakgr/The-Spiral-Language](https://github.com/mrakgr/The-Spiral-Language)@[4d0016494c...](https://github.com/mrakgr/The-Spiral-Language/commit/4d0016494cecf35b714db859b7a00b22900654d6)
#### Saturday 2020-10-24 13:19:39 by Marko Grdinić

"11:50am. Wow, Baldur's Gate got another sequel just recently. Never would have expected that.

https://www.youtube.com/watch?v=9OdMpVd8CiY&list=PLBdeHt27rzNNpSekkQkRupWzfZkWgw0QE&index=10
Treantmonk Evaluates 9th Level Spells

I admit, I never understood Dnd wizards properly. They were pretty useless in BG and Icewind Dale. In those games the pace is just too fast and you are better giving everyone bows. So let me have some fun with this. Then I'll do the chores. Then I'll do some proper programming.

12:50pm. Chores.

1:10pm. Done. When I say indulgence, watching those spell rating videos is just what I mean. I do not even play Dnd and the information is completely useless to me, but I had fun.

This is the life.

Let me finally dedicate my focus to programming.

1:15pm. Focus. Right now my concentration has been frittered away again.

First let me put down my thoughts and I will move from there.

Let me see if I can get back the drive that I've been building up yesterday.

1:20pm. First of all, I am struggling greatly. I need to acknowledge this to start things off.

Why is that?

Well, let me pick a server. But anything will do.

```fs
type TypecheckerRes = (Bundle * Infer.InferResult) PersistentVector * bool
let typechecker (req : ParserRes Stream) : TypecheckerRes Stream =
    let req = Stream.values req
    let res = Src.create()
    let r = Src.tap res
    let rec waiting a = req ^=> fun b ->
        let rec loop s i b =
            match PersistentVector.tryNth i a, b with
            | Some(bundle,_ as r), bundle' :: b' when bundle = bundle' -> loop (PersistentVector.conj r s) (i+1) b'
            | _ -> s, b
        loop PersistentVector.empty 0 b.bundles |> processing
    and processing = function
        | a, [] -> Alt.prepare (Src.value res (a,true) >>- fun () -> waiting a)
        | a, b :: b' -> waiting a <|> Alt.prepare (Src.value res (a, false) >>- fun () ->
            let env =
                match PersistentVector.tryLast a with
                | Some(_,b : Infer.InferResult) -> b.blockwise_top_env
                | None -> Infer.default_env
            let a' = PersistentVector.conj (b,Infer.infer env (bundle b)) a
            processing (a', b')
            )
    Hopac.server (waiting PersistentVector.empty)
    r
```

So I did the typechecking server. For a single file, the above is absolutely perfect.

But every step beyond this has been hell in my mind. Multiple packages and multiple files has turned into a great war in my mind. A part of me wants to make things as little as concurrent as possible.

Why have multiple typecheckers in a package when they all need to be sequantial anyway? Would it not be better to retain control?

1:25pm. But what I wrote above really scratches at the surface of things.

It is not really about right or wrong. There isn't strictly a right way to program.

It is about the feeling of discomfort I've been trying to endure while approaching concurrent programming. Ultimately, the best way to program is the one that makes it the easiest for you to reason about your code. The best way is the one which is the easiest to think.

Consider regular programming with no concurrency and none of these Hopac servers.

I imagine the problem domain, imagine the data flow, neatly partition everything and carve it into code, each function responsible for its own purpose. Every step comes one after another.

1:30pm. But once you go into a concurrent regime the order of steps scrambled.

I keep agonizing about the order of steps, trying to pressure the mental model into shape - into a way of thinking I am familiar with and understand well. But this is foolhardy. As great as my regular patterns of thought are, this is extemely foolhardy. I did get an expensive and time consuming lesson in my early 20s why you should not try to force reality into a mold it cannot fit.

1:40pm. I need to become more comfortable with what concurrent programming really is. One of the main reason I am having such great difficulty is because I am trying to hard.

I keep setting wildly unrealistic standards of how understandanble and readable concurrent code should be.

Consciously, I know that concurrent programming is harder than sequential. If you ask'd me I'd say that I understand that without hesitation, but isn't the truth that deep down I am deeply unsatisfied? Deep down I feel that matching the elegance and ease of my regular programming is a goal I should meet in the concurrent regime.

1:45pm. It is obvious that I cannot meet my reasonability goals in the face of pervasive concurrency. Because of that I cannot really embrace concurrency. For the sake of those goals, I want control. I want A to B to C, not complicated chains of communication. I want clear hierarchies, not middied areas of responsibility.

Because it is ostensibly good programming, and indeed, those were the best principles for the kinds of programming I had been used to.

1:50pm. At first there was Assembly, but on top of that languages were built and programming was structured around primitives that are easier to reason about.

We've gone from having registers and having the memory be one giant array you could access at will to a world of abstract data types and functions.

Functions are great. I love them.

Function are cuts in one's own mind. The way the program is structured in code, is the way it is structured in my own mind.

Once the first cut is made, so is another. Readability and understanding comes naturally through an internal process of optimization. When everything is cut into pieces and neatly organized, then the undestanding is attained.

1:55pm. I am struggling to find the right way of getting to the point, that anyone or even me can come to an agreement.

But it is the realization - that there is no middle ground between giant blob of instructions assembly programming and modern functional programming. Suppose were a functional programmer just recently transported from the 70s to the present age and feel uncomfortable with all the restrictions of programming in F#.

You'd go 'Ahhhh, I can't access this or that whenever I want, what about the efficiency?'

You'd end up doing what I am drawn to when it comes to doing the multi-file typechecker server - which is writing a low level emulator under the hood, even though you don't really need it.

The fact that I myself am drawn to this is something that deeply bothers me. Did I not get this lesson before?

Remember when I did those GUI examples in the Lithe repo?

Remember what an eye opener it was that I could implement the MVC pattern and declarately describe the UI and compile it to a chain of observables? Whethas Elm and Fabulous, and React and other big frameworks do DOM diffing which is essentially an emulator of what a concurrent group of agents can express naturally and much more succinctly.

That was a lesson for me.

2:05pm. The lesson being - for efficiency embrace concurrency.

Can I learn that for abstraction I should embrace the same as well?

This is is actually a new way of thinking for me. In the real world everything is concurrent, but in programming I've only ever saw it as an expense. Why would I program GPUs for example? It was not because I liked them. It is just that I needed that to get performance and was willing to pay the added expense to get it.

2:35pm. Let me go to bed for a while. I'll do the same thing I started to do yesterday.

Right, and for the past few days, I've had everything reasoned out. The delay is not so much because because like before I had to think about how to find strong components in order to do proper cycle checking or had to think about how to load files in parallel.

Right now, the delay is because I am an Assembly programmer uncomfortable with functions.

I understand the entirety of the data flow, but I am uncomfortable where the code itself is trying to lead me.

2:40pm. In order for me to trully show my skill in programming, I need to make proper use of functions. I am a master at that.

But for the past few days, I've been feeling blocked because I do not want to take the next steps and embrace concurrent servers.

I keep finding issues.

For example, I know how to do concurrent cycle checking on a graph. I even know how to make it a server - but then I think that I also need to load files. And then I look at the existing project file server and feel completely blocked at how to fit it all together.

In regular programming this would not be a problem - split the relevant problems into functions. Do the tasks in isolation.

You know how to keep a track of a graph and its reverse, and use that to do cycle checking. You know how to load project files. You know how to do all the relevant validation for them.

In seqential programming, you would have no hesitation doing those tasks in isolation.

2:50pm. In order to move forward, maybe all I need to do is apply the same principles.

One thing that I've been spending a lot of time thinking about that might not even matter are communication protocols.

A regular function has just the input and the output, but servers are more complicated.

```fs
type ProjectCodeAction =
    | CreateFile of {|filePath : string|}
    | DeleteFile of {|range: VSCRange; filePath : string|} // The range here includes the postfix operators.
    | RenameFile of {|filePath : string; target : string|}
    | CreateDirectory of {|dirPath : string|}
    | DeleteDirectory of {|range: VSCRange; dirPath : string|} // The range here is for the whole tree, not just the code action activation.
    | RenameDirectory of {|dirPath : string; target : string; validate_as_file : bool|}

type ProjectReq =
    | ProjOpen of string
    | ProjChange of string
    | ProjLinks of ({|uri : string; range : VSCRange|} [] -> unit)
    | ProjCodeActionExecute of ProjectCodeAction * ({|result : string option|} -> unit)
    | ProjCodeActions of ({|range : VSCRange; action : ProjectCodeAction |} [] -> unit)

let project project_dir (req : ProjectReq Stream) =
```

The project server has these union types which act as function calls to it.

One reason why I've thought of emulating a state machine in the multi-file server is because it would free me of the burden of having to deal with these union types.

2:50pm. I reasoned out all the important details of the compilation pipeline in isolation. If I were making isolated servers, I'd be able to manage it. But then I start thinking of how the servers would communicate and how complex things would get and I fall into a slump.

2:55pm. I always pay attention to every detail, but maybe for concurrent programming, I've been overly sensitive about the importance of this.

Ok, so that bit where I replaced nested ivars with just single stream was important. I was right to worry about protocols in that position. In that position falling into my misgivings was the right move as it allowed me to think things through and achieve a breakthrough.

3pm. Let me go to bed as I said I would. I am going to take this time to think about protocols on a meta level. Now that I've come to this point, I really should reflect on my overall style and reach a conclussion.

I should take some time, and if I cannot get any better ideas, I will take the approach of thinking of concurrent agents as the new functions. I'll accept the conclussion that there is no middle ground that I can hope to attain in order to get the reasonability of sequential programming in the concurrent domain and embrace concurrent programming for what it is.

I'll set new standards and try to reach those instead. I will stop being so stingy about making fresh union types for concurrent servers. I am going to have to accept that, yes, to make concurrent servers, I am going to have to write a bit more down and set up the protocol beforehand instead of letting type inference do everything.

3:10pm. I am going to accept that since I cannot determine the order, I should stop worrying about it so much. Instead I will just focus on the required functionality for a server in isolation.

I won't try to merge things together for efficiency. I am not going to do package loading in the graph checker. Even though both of them should be a part of the supervisor, clearly those two for the sake of reasonability should be isolated.

Programming is great when you can focus on one thing only.

You can do that in concurrent programming. In fact, shouldn't not having to care about the order be an advantage?

I need to get into the habit of that.

The reason why I am agonizing so much is because I am trying to do the impossible and do not want to give up.

3:15pm. Reasonable thinking is one thing - I can do it, but reasoning is always bolstered or hindered by habit.

Forget about finshing the compilation pipeline. I do not need to focus on things big and great.

I neither do need any big insights in concurrent programming.

Instead I need to get my mind in order and adjust my habits in the new regime.

3:15pm. Let me just focus on this, and the inspiration will come to me. The energy and the willigness to put in effort will come to me. The routine will be reestablished and I will be able to give concrete form to my thoughts.

Let me dwell on this for a while. I'll turn off for a few hours here."

---
## [xFuney/rhea](https://github.com/xFuney/rhea)@[e7fe5d0e57...](https://github.com/xFuney/rhea/commit/e7fe5d0e577218fbaf9579d8a318964e71eab9d2)
#### Saturday 2020-10-24 17:31:19 by Funey

add msg edit regex blacklisting

fuck you The King#8694

---
## [LJmartin94/Codam06_MiniShell](https://github.com/LJmartin94/Codam06_MiniShell)@[80a2b2708e...](https://github.com/LJmartin94/Codam06_MiniShell/commit/80a2b2708e4a37ce1cc0c3eb5d0e816c2be7caf5)
#### Saturday 2020-10-24 19:39:59 by LJmartin94

24 October 2020, Been messing about with how to handle padding. more specifically, how to deal with it in Argument state. The problem is this: I have so far resisted making a separate padding state, as almost every other state would be validly reachable from such a state (padding can exist between any of the elements in an input line, and at both the start and end). However, making a separate padding state for each other state (e.g. entry_padding, meaning you're now in padding state but before were in entry_state) seems like a horrendous overkill and over complification of the way padding is treated. Instead, you can quite simply say that when double or single quotes aren't involved, the padding is largely ignored. There is however one exception: padding that exists between two arguments is preserved (but shortened to a single unit of padding). For our finite state machine this means all states can 'skip through' padding tokens, except the argument state. The argument state needs to save its own argument to the component block, skip through all but one unit of padding, and check whether the token after that is an argument too. If its not, it can skip padding entirely, but if it is, it needs to add a unit of padding in between itself and the next token of the argument. All this is easy enough to implement (in fact, it is already working in this commit). But the problem is that every approach I take seem to 'go against the spirit of a FSM' (checking ahead multiple states, making it so that states no longer treat padding in a fairly universal manner etc). Concretely what this means is also that if I come up with a highly particular solution to the problem, the FSM may not be as adaptable as we want it to be in other future scenarios. However I've spent so long thinking about what the best approach would be that my brain is a little fried, so I'm going home now.

---
## [dshadowwolf/vciv-disassembler](https://github.com/dshadowwolf/vciv-disassembler)@[02fe77de60...](https://github.com/dshadowwolf/vciv-disassembler/commit/02fe77de6052f651980e60c7024c36227292f282)
#### Saturday 2020-10-24 21:43:11 by Daniel Hazelton

variable rename

Decided to give CLion a shot after Doom-Emacs decided it was going to do some stupid "Let Me Help You\!" types of bullshit. It kept flagging these two variables as being badly named and needing a change. As I'm not looking at the docs for this (instead I have Discord on that screen) while making the change, I think I fucked it up, but...

---
## [dshadowwolf/vciv-disassembler](https://github.com/dshadowwolf/vciv-disassembler)@[f56f5e2316...](https://github.com/dshadowwolf/vciv-disassembler/commit/f56f5e2316434472a2160599766da685e7741c27)
#### Saturday 2020-10-24 21:44:47 by Daniel Hazelton

variable rename

Decided to give CLion a shot after Doom-Emacs decided it was going to do some stupid "Let Me Help You!" types of bullshit. It kept flagging these two variables as being badly named and needing a change. As I'm not looking at the docs for this (instead I have Discord on that screen) while making the change, I think I fucked it up, but...

---

# [<](2020-10-23.md) 2020-10-24 [>](2020-10-25.md)

