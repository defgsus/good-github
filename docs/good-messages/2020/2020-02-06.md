# [<](2020-02-05.md) 2020-02-06 [>](2020-02-07.md)

2,074,126 events, 1,054,884 push events, 1,753,589 commit messages, 132,059,052 characters


## [mrakgr/The-Spiral-Language@17f9b4707c...](https://github.com/mrakgr/The-Spiral-Language/commit/17f9b4707c07c7b385313f4a4d7cb9789423ddf0)
##### 2020-02-06 10:32:51 by Marko Grdinić

"9:05am. Today and yesterday sure are cold.

9:20am. Ah, fuck it. Let me chill. Since I haven't watched Bofuri yesterday let me do it now.

10:30am. Let me finally start. I even did the chores ahead of time.

10:35am. Focus me, focus.

Today in the morning the mission is to deal with the top level parsing issue where it expects an expression at the end.

I need to do it better.

10:50am.

```
let parser_expressions expr s = (expressions expr |> operators_unary |> application_tight |> application |> operators) s
let rec parser_inner s = (((statements false parser_inner |>> ParserStatement) <|> (exprpos (parser_expressions parser_inner) |>> ParserExpr)) |> indentations |> annotations) s
let parser_outer d =
    let i = col d
    (many1 (expr_indent i (=) (statements true parser_inner |>> ParserStatement)) .>>. preturn (Some RawB) >>= process_parser_exprs) d

let parser d = (parser_outer .>> eof) d
```

How about this? This should work. Let me give it a try.

10:55am. Stop reading the PL sub threads, focus. Do not go off on a rant on how great top down reasoning is.

Focus on getting closer to world conquest.

Run the damn thing.

11am.

```
let test1: SpiralModule =
    {
    name="test1"
    prerequisites=[]
    description="Does it run?"
    code=
    """
inl main () =
    inl a = 5
    inl b = 10
    dyn (a + b)
    """
    }
```

Wonderful. That is one issue down.

Done in a record time.

One thing...rather than main being (), I'll leave it as _.

```
inl main _ =
    inl a = 5
    inl b = 10
    dyn (a + b)
```

Who knows, maybe later I will be passing command line args and whatnot.

11:10am. Focus me, focus.

What is next? Let me just get on with it to the next thing.

Let me do a bunch more tests today.

Right now I am thinking about union types. Rather than having them be `R _ _ _` I think I will instead make it a tuple like F# does. The reason for that is that I frequently want to just put a `_` there. It would really be annoying to have to write out the exact number of _s every time.

But otherwise first class constructors should be fine.

11:15am. Forget Union types for the time being. They will come much later, after both typechecking and editor support is done.

For now just focus on the task at hand.

I might not have managed to go as far as I wanted with my RL agent plan, but I can go all the way to the end of the Spiral branch. It is really a pity - if ML was just a level higher than it is currently, I could have made up my mind to go for it. Instead the way it is now has put me seemingly permanently in the exploration stage.

Just a little bit more understanding, just a little bit more insight and progress will resume.

11:20am. Just like I would not use sloppy ML algorithms, I should not use sloppy languages.

Either way, in 2020 I am going to reach satisfaction when it comes to Spiral. I am not going to drop it here.

11:25am. Let me do the next few tests.

After that I'll take a break.

```
let test2: SpiralModule =
    {
    name="test2"
    prerequisites=[]
    description="Do the join points work?"
    code=
    """
inl main _ =
    inl a () = join 5
    inl b () = join 10
    a () + b ()
    """
    }
```

```
Unhandled exception. System.ArgumentException: An item with the same key has already been added. Key: Spiral.CodegenFsharp+H`1[Spiral.PartEval+JoinPointKey]
   at System.Collections.Generic.Dictionary`2.TryInsert(TKey key, TValue value, InsertionBehavior behavior)
   at System.Collections.Generic.Dictionary`2.Add(TKey key, TValue value)
   at Spiral.CodegenFsharp.Tagger`1.Tag(a ty) in C:\Users\Marko\Source\Repos\The Spiral Language\The Spiral Language v0.2\CodegenFsharp.fs:line 26
```

Now what is this?

```
member t.Tag ty = memoize dict (fun ty' -> let x = dict.Count in queue.Enqueue(ty,x); dict.Add(ty',x); x) (H ty)
```

Ah, why am I adding to dict twice. No wonder.

```
{ parse = 00:00:00.2480635
  prepass = 00:00:00.0263292
  peval = 00:00:00.0650761
  codegen = 00:00:00.0246395 }
let rec method_0 () : int64 =
    5L
and method_1 () : int64 =
    10L
let ((var_0 : int64)) = method_0 ()
let ((var_1 : int64)) = method_1 ()
let ((var_2 : int64)) = var_0 + var_1

C:\Users\Marko\Source\Repos\The Spiral Language\Testing v0.2\bin\Debug\netcoreapp3.1\Testing v0.2.exe (process 10384) exited with code 0.
```

The parse times are really large.

I really am going to have to do a performance deep dive of the parser at some point. But it is not important.

Let me try another test and I will take a break.

11:30am.

```
let test3: SpiralModule =
    {
    name="test3"
    prerequisites=[]
    description="Does `dyn` work?"
    code=
    """
inl main _ =
    inl a = dyn 5
    inl b = dyn 10
    a + b
    """
    }
```

Ok, enough. Let me stop here for a bit."

---
## [mpv-player/mpv@cce7062a8a...](https://github.com/mpv-player/mpv/commit/cce7062a8a6b6a3b3666aea3ff86db879cba67b6)
##### 2020-02-06 11:01:02 by wm4

lua: fix highly security relevant arbitrary code execution bug

It appears Lua's package paths try to load .lua files from the current
working directory. Not only that, but also shared libraries.

  WHAT THE FUCK IS WHOEVER IS RESPONSIBLE FOR THIS FUCKING DOING?

mpv isn't setting this package path; currently it's only extending it.
In any sane world, this wouldn't be a default. Most programs use
essentially random working directories and don't change it.

I cannot comprehend what bullshit about "convenience" or whatever made
them do something this broken and dangerous. Thousands of programs using
Lua out there will try to randomly load random code from random
directories.

In mpv's case, this is so security relevant, because mpv is normally
used from the command line, and you will most likely actually change
into your media directory or whatever with the shell, and play a file
from there. No, you don't want to load a (probably downloaded) shared
library from this directory if a script try to load a system lib with
the same name or so.

I'm not sure why LUA_PATH_DEFAULT in luaconf.h (both upstream and the
Debian version) put "./?.lua" at the end, but in any case, trying to
load a module that doesn't exist nicely lists all package paths in
order, and confirms it tries to load files from the working directory
first (anyone can try this). Even if it didn't, this would be
problematic at best.

Note that scripts are _not_ sandboxed. They're allowed to load system
libraries, which is also why we want to keep the non-idiotic parts of
the package paths.

Attempt to fix this by filtering out relative paths. This is a bit
fragile and not very great for something security related, but probably
the best we can do without having to make assumptions about the target
system file system layout. Also, someone else can fix this for Windows.

Also replace ":" with ";" (for the extra path). On a side note, this
extra path addition is just in this function out of laziness, since
I'd rather not have 2 functions with edit the package path.

mpv in default configuration (i.e. no external scripts) is probably not
affected. All builtin scripts only "require" preloaded modules, which,
in a stroke of genius by the Lua developers, are highest priority in the
load order. Otherwise, enjoy your semi-remote code execution bug.

Completely unrelated this, I'm open for scripting languages and
especially implementations which are all around better than Lua, and are
suited for low footprint embedding.

---
## [mpv-player/mpv@31acec5438...](https://github.com/mpv-player/mpv/commit/31acec543819cf56d63dddae59507858b1229b75)
##### 2020-02-06 13:16:48 by wm4

path: change win32 semantics for joining drive-relative paths

win32 is a cursed abomination which has "drive letters" at the root of
the filesystem namespace for no reason. This requires special handling
beyond tolerating the idiotic "\" path separator.

Even more cursed is the fact that a path starting with a drive letter
can be a relative path. For example, "c:billsucks" is actually a
relative path to the current working directory of the C drive. So for
example if the current working directory is "c:/windowsphone", then
"c:billsucks" would reference "c:/windowsphone/billsucks".

You should realize that win32 is a ridiculous satanic trash fire by the
point you realize that win32 has at least 26 current working
directories, one for each drive letter.

Anyway, the actual problem is that mpv's mp_path_join() function would
return a relative path if an absolute relative path is joined with a
drive-relative path. This should never happen; I bet it breaks a lot of
assumptions (maybe even some security or safety relevant ones, but
probably not).

Since relative drive paths are such a fucked up shit idea, don't try to
support them "properly", and just solve the problem at hand. The
solution produces a path that should be invalid on win32.

Joining two relative paths still behaves the same; this is probably OK
(maybe).

The change isn't very minimal due to me rewriting parts of it without
strict need, but I don't care.

Note that the Python os.path.join() function (after which the mpv
function was apparently modeled) has the same problem.

---
## [mrakgr/The-Spiral-Language@8b7993a376...](https://github.com/mrakgr/The-Spiral-Language/commit/8b7993a376681aede7229e5e77731d64bc32d24c)
##### 2020-02-06 13:46:28 by Marko Grdinić

"12:35pm. Let me finish reading Astrid and then I'll resume.

12:55pm. I finished it like 10m ago and then started reading Reddit ML sub threads...

Tch!

It is time to focus.

I know this is annoying as shit, but I have to do it.

I have to do the testing. There are like 100 tests to go through before I can conclude that the language is in decent shape.

I'll ignore those tests related to the union types, but I am going to have to put macros in before I am done.

1pm. No matter how this thing turns out, I absolutely must do the typechecking. I need the power of top-down reasoning unless I want to end up going through the same hardship that I did in 2018.

Editor support, jobs and whatever else is optional.

Without typechecking on the other hand, I can forget about ever scaling the language.

If I can at least do typechecking then I will have a lot of options open to me.

If I can do typechecking I will be capable of writing programs in the language properly the same as I do in F#.

1:05pm. Just this, just this much...

Ahhhh...damn it, I really should be doing ML...

But more than that, I need to be making strides into new things, I won't win a war by just standing in place.

Typechecking definitely qualifies as something new.

1:05pm.

```
let test4: SpiralModule =
    {
    name="test4"
    prerequisites=[]
    description="Does the and pattern work correctly?"
    code=
    """
inl f (a, b) (c, d) = dyn (a+c,b+d)
inl q & (a, b) = dyn (1,2)
inl w & (c, d) = dyn (3,4)
f q w
    """
    }
```

```
Error trace on line: 3, column: 7 in module test4.
inl q & (a, b) = dyn (1,2)
      ^
Expected one of: end of file
```

At least the error position is precise.

1:10pm. I have no idea, why is the pattern not getting parsed correctly?

...Ah, maybe because I forgot to put the `main`. Whops.

```
Unhandled exception. System.ArgumentException: The input array was empty. (Parameter 'array')
   at Spiral.Parsing.parse(SpiralModule m) in C:\Users\Marko\Source\Repos\The Spiral Language\The Spiral Language v0.2\Parsing.fs:line 875
   at Spiral.Compile.p@63.Invoke(Unit _arg1) in C:\Users\Marko\Source\Repos\The Spiral Language\The Spiral Language v0.2\Compile.fs:line 63
```

I've commented out the core library and I am getting this error now.

```
if d.Index = d.Length then fail [Array.last l, UnexpectedEof]
```

How unusual that this is raising an error.

```
        | Error [] ->
            if d.Index = d.Length then
                match Array.tryLast l with
                | Some x -> fail [x, UnexpectedEof]
                | None -> Error "Unknown parse error."
            else Error "Unknown parse error."
```

Let me do this.

1:20pm. I'll also change so that modules can have zero statements.

No need to push this any harder than it needs to be.

Now...

```
let test4: SpiralModule =
    {
    name="test4"
    prerequisites=[]
    description="Does the and pattern work correctly?"
    code=
    """
inl main _ =
    inl q & w = 1
    1
    //inl f (a, b) (c, d) = dyn (a+c,b+d)
    //inl q & (a, b) = dyn (1,2)
    //inl w & (c, d) = dyn (3,4)
    //f q w
    """
    }
```

I have to figure out why the and here is not getting parsed correctly.

Now that I have the core library commented out, tracking this down should be easier.

1:30pm.

```

        let inline name_pats_body on_else =
            tuple3 var_op (many pattern') (statement_body expr) >>= fun (name,pats,body) d ->
                match List.foldBack (<|) pats (join_point_entry_method body) with
                | RawInl _ | RawForall _ as x -> Ok(name,x)
                | x -> if is_global then d.FailWith ExpectedGlobalFunction else on_else (name,x) d
```

Ah crap. Note how it is expecting a `var_op` in the first place rather than a pattern.

```
inl main _ =
    inl (q, w) = 1, 2
    1
```

This does not work either.

Uf.

1:55pm.

```
let pattern_to_rawinl pat body =
    let inline f expr_pos = function
        | PatE -> RawInl("", expr_pos body)
        | PatVar name -> RawInl(name, expr_pos body)
        | _ -> RawInl(pat_main, expr_pos <| pattern_to_rawexpr(pat_main, [|pat, body|]))
    match pat with
    | PatPos x -> f (expr_pos x.Pos) x.Expression
    | x -> f id x
```

Agh, this stupid thing.

Let me adjust it a bit.

2pm.

```
let name_body pat body =
    let inline f expr_pos = function
        | PatE -> ("", expr_pos body)
        | PatVar name -> (name, expr_pos body)
        | _ -> (pat_main, expr_pos <| pattern_to_rawexpr(pat_main, [|pat, body|]))
    match pat with
    | PatPos x -> f (expr_pos x.Pos) x.Expression
    | x -> f id x
let pattern_to_rawinl pat body = name_body pat body |> RawInl
```

This is the power of abstraction.

2:10pm. Actually this part is giving me quite a bit of trouble.

```
let pat_body = pattern true false expr .>>. statement_body expr |>> fun (pat,body) -> name_body pat body
```

```
        | Error _ ->
            let name_pats_body d = name_pats_body (fun x _ -> Ok x) d
            if is_global then (name_pats_body |>> handle_inl_statement) d
            else ((attempt pat_body <|> name_pats_body) |>> handle_inl_statement) d
```

I just do not see how to do this one without backtracking.

Well, the error reporting right now is such a horrid state that it does not even matter.

```
Unhandled exception. System.Collections.Generic.KeyNotFoundException: The given key ' pat_main' was not present in the dictionary.
   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)
   at Spiral.Prepass.prepass@312.Invoke(PrepassError x) in C:\Users\Marko\Source\Repos\The Spiral Language\The Spiral Language v0.2\Prepass.fs:line 315
```

Ouh.

```
let handle_inl_statement (name, body) = fun on_succ -> l name body on_succ
```

This might be wrong.

2:20pm. I am such an imbecile. I mean I already had a solution a while ago, but I skipped it just because I wanted to optimize the expressions a little. Fuck.

```
        let pat_body = pattern true false expr .>>. statement_body expr |>> fun (pat,body) ->
            fun on_succ -> l pat_main body (pattern_to_rawexpr(pat_main, [|pat, on_succ|]))
```

Let me just go with this. For fuck's sake.

```
        let pat_body = pattern true false expr .>>. statement_body expr |>> fun (pat,body) ->
            fun on_succ ->
                match pat with PatPos x -> x.Expression | x -> x
                |> function
                    | PatE -> l "" body on_succ
                    | PatVar name -> l name body on_succ
                    | _ -> l pat_main body (pattern_to_rawexpr(pat_main, [|pat, on_succ|]))
```

Fuck. Let me go with this.

I often in situation like these have the urge to try to reuse past code and just end up spending time for no reason on this.

```
let pat_pos pos x = PatPos(Pos(pos,x))
let patpos expr d = (expr |>> function PatPos _ as x -> x | x -> pat_pos (pos' d) x) d
```

Let me do it like this so I absolutely do not make a mistake...

```
let expr_pos pos = function
    | RawPos _ as x -> x
    | x -> RawPos(Pos(pos,x))
let exprpos expr d =
    let pos = pos' d
    (expr |>> function RawB | RawType _ | RawInline _ | RawRecBlock _ | RawInl _ | RawForall _ as x -> x | x -> expr_pos pos x) d
let pat_pos pos = function
    | PatPos _ as x -> x
    | x -> PatPos(Pos(pos,x))
let patpos expr d = (expr |>> pat_pos (pos' d)) d
```

Let me do this.

2:30pm.

```
let test4: SpiralModule =
    {
    name="test4"
    prerequisites=[]
    description="Does the and pattern work correctly?"
    code=
    """
inl main _ =
    inl f (a, b) (c, d) = dyn (a+c,b+d)
    inl q & (a, b) = dyn (1,2)
    inl w & (c, d) = dyn (3,4)
    f q w
    """
    }
```

```
Unhandled exception. System.ArgumentException: An item with the same key has already been added. Key: f
   at System.Collections.Generic.Dictionary`2.TryInsert(TKey key, TValue value, InsertionBehavior behavior)
   at System.Collections.Generic.Dictionary`2.Add(TKey key, TValue value)
   at Spiral.ParserCombinators.ParserEnv.Ok[a](TokenPosition pos, String t) in C:\Users\Marko\Source\Repos\The Spiral Language\The Spiral Language v0.2\ParserCombinators.fs:line 81
```

Now what is going on here?

...Ah yes. Backtracking behavior is causing a var to get added twice.

Ok...

```
    member d.Ok (pos : TokenPosition, t) =
        d.var_positions.[t] <- {module_=d.module_; column=pos.start_column; line=pos.start_line}
        Ok(t)
```

Let me go with this.

2:35pm.

```
Unhandled exception. System.Collections.Generic.KeyNotFoundException: The given key '+' was not present in the dictionary.
   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)
   at Spiral.Prepass.prepass@312.Invoke(PrepassError x) in C:\Users\Marko\Source\Repos\The Spiral Language\The Spiral Language v0.2\Prepass.fs:line 315
```

This is unusual.

This should just be a regular error, why is it raising an exception?

```
match d.ReadOp' with
```

Ah, note that I am using the wrong op.

So far every time I did not take account of positional information, I've regretted it.

```
Error trace on line: 3, column: 27 in module test4.
    inl f (a, b) (c, d) = dyn (a+c,b+d)
                          ^
Error: Variable dyn not found in the environment.Error trace on line: 3, column: 33 in module test4.
    inl f (a, b) (c, d) = dyn (a+c,b+d)
                                ^
Error: Variable + not found in the environment.
```

Finally the thing parses properly.

2:40pm. Let me put the core library back in.

```
let ((var_0 : int64)) = 1L
let ((var_1 : int64)) = 2L
let ((var_2 : int64)) = 3L
let ((var_3 : int64)) = 4L
let ((var_4 : int64)) = var_0 + var_2
let ((var_5 : int64)) = var_1 + var_3
```

This seems right.

2:45pm. It is really amazing how many bugs there are even in simplest things.

Let me continue moving forward.

...Actually both Kumo and Kengan Omega are out. Let me take a break here."

---
## [KDE/user-manager@80ac93fa2b...](https://github.com/KDE/user-manager/commit/80ac93fa2b483fa8a2c4a6d746a5d48e1d50e64d)
##### 2020-02-06 15:21:59 by Noah Davis

Remove human avatars

Summary: There were some complaints about the female avatar and during a discussion in the VDG channel, someone mentioned that the male avatar was rather ugly too.

Reviewers: #vdg

Subscribers: davidedmundson, leinir, ngraham, niccolove, plasma-devel

Tags: #plasma

Differential Revision: https://phabricator.kde.org/D27194

---
## [hiddenswitch/Spellsource-Server@677658c0db...](https://github.com/hiddenswitch/Spellsource-Server/commit/677658c0dbb5f9d92db572bdf5772892f6acac68)
##### 2020-02-06 21:42:32 by doctorpangloss

0.8.66

 - The client now shows colors on cards.
 - Inspecting a card on mobile in the collection interface no longer leaves it stuck on screen.
 - Issues in the client related to some kinds of targeting have been fixed.
 - Star Sculptor now correctly gives the summoned minion Guard/Can't Attack and not the original. (1518)
 - Fixed an interaction when General Hun'Zho summons Lumina, Light of the Forest. (1516)
 - Necronomicon is now an Occultist card like it was supposed to be. (1523)
 - Forge Suit now properly only gives Health and not Attack. (1525)
 - Sand Filter now actually Decays, and is properly now only active on your own turn. (1525)

In addition, extensive edits by @Logovaz summarized here:

 - Jek the Bonelord, Firefoxie, Sunbender, Timebidding Magi, Toothpick Fighter, Pawshop Trader, Vanal Petkiper

 - Freying Faimiliar is now a Fae from a Beast and called "Forest Familiar"
 - Stone Sentinel (10/9/9 -> 10/10/10), Stalwart Sculptor (4/3/2 -> 4/3/4)
 - Skeletower (Costs 8 -> Costs 7)
 - Siege Elephant is now ("Whenever this minion takes damage, gain 2 Armor.") from 1 Armor.
 - Macabre Samaritan is now ("Whenever this minion takes damage, restore 4 Health to your champion.") from 2 Health.
 - Hunchback Supplier now has Lifedrain
 - Forest Magistrate (Opener: Deals 2 damage -> Opener: Deals 3 damage)
 - Floating Crystal (2/0/4 -> 2/0/6), Fae Horncaster (2/1/2 -> 2/1/3), Burst Bug (4/2/1 -> 4/3/1)
 - Bone Guard is now (5/3/5 "Guard. Opener: Draw a card.")
 - Mind Controlled Mech reflavored to be Blind Acolyte. Also: (4/2/8 -> 4/3/8). The skill has been renamed to Echolocation from Mental Command.
 - Warclub Ruffian is now a (4/3/2 Demon, Dodge, Guard)
 - Mindswapper (3/3/2 -> 3/4/2) and is now a Fae.
 - Lightning Elemental is now ("Whenever this takes damage, deal 1 damage to all other minions.") from "After this..."
 - Hold Hunter is now a (1/1/2 Pirate "After this attacks and kills a minion, gain Dodge.")
 - Giant Serpent now has Hidden for 1 turn and is a Common.
 - Captain of the Guard (4/3/3 -> 3/3/3)
 - Mrs. Merria is now (4/4/4 Fae "Opener: If you played 4 other cards this turn, take control of an enemy minion.") from (7/6/6) and 5 cards.
 - Fixed text on Marie Annette
 - Corona, Fae Defender's aura is now ("Your other Fae have +2/+1 and Elusive.") from +1/+1.
 - Wolfcrier (4/3/7 -> 3/3/7 and summons a 3/3 wolf instead of a 2/3 wolf)
 - Uccian Hydra (5/2/2 -> 4/3/3 and has Hidden for 1 turn)
 - Sonorous Spectre is now (6/4/4 Spirit "Opener and Aftermath: Silence all other minions.") from just Opener.
 - Oni's Eye (2/0/2 -> 1/0/2), Sleepy Scarecrow (1/0/2 -> 1/0/3)
 - Crew Commander properly has Pirate Tag
 - Blackboar is now (3/3/3 Beast "Opener: Your next Dash minion this turn costs (3) less.")
 - Hybreeder is now (3/1/4 "At the end of your turn, summon a 1/1 Mutt with Guard.")
 - Nice Cream is now (3/3/3 Elemental "Opener: Restore 3 Health to all other characters.")
 - Holdout Soldier is now a Rare (4/2/6 "Opener: If your opponent has 4 or more minions, draw 3 cards.") from 2 and 1 respectively.
 - Added missing minion: Henchman Helper (5/5/2 "Opener: Give a friendly Guard minion +4/+4.")
 - Disco Inferno (4/4/3 -> 3/4/3), Alien Ravager now says ("Extra Strike")
 - Timewalker Initiate renamed to Patient Initiate

 - Lead by Example now costs 3 and does not draw a card.
 - Insurgency Captain Krika now requires 4 Champion Attacks (from 3).
 - Ruffian Shiro (2/2/2 -> 3/2/2)
 - 4th Ring Warden's effect should no longer stack.
 - Bogovey Jester is now an Aftermath from an Opener.
 - Darkfire Blaster (5/3/6 -> 6/3/7)
 - Warmongering is now ("Give a minion 'After this attacks, gain +2/+2'.")
 - Thousand Year Hatred is now ("Choose an enemy minion. Destroy all minions on the battlefield and in hand with the same name.")

 - Witching Traveler now sets cost of card to 0 from 1.

 - Major changes to Soulseeker: “Obvious nerfs," card deletions, reflavoring and set changes, new cards, in particular Secrets archetype.
 - Reverse Volition: 1 mana common spell "Secret: When your opponent plays a minion, return it to their hand." (Replaces Dormant Spirits)
 - Rebirth: 0 mana common spell "Destroy a friendly minion. Summon a random minion with the same Cost."
 - Seeker of Mysteries: 2 mana 2/3 common "Opener: If you control a secret, Soulbind twice."
 - Render Imaginary: 2 mana common spell "Destroy a minion. Its owner draws 2 cards."
 - Transmute Life: 1 mana rare spell "Secret: When a friendly minion dies, give your other minions +1/+1."
 - Mirror Phantom: 1 mana 1/3 rare Spirit "While in your hand, this is a copy of the last Spirit you played."
 - Split Soul: 2 mana epic spell "Destroy a friendly minion. Add two 1/1 copies of it to your hand that cost (1)."
 - Soul Warden: 4 mana 3/4 Spirit "Opener: Summon 1/1 copies of your minions that died this turn."
 - Knowledge Feeder: 4 mana 3/3 epic Spirit "Opener: Destroy a friendly minion to put three Secrets from your deck into the battlefield."
 - Ranabosh, in Memory: 3 mana 4/2 Legendary Spirit "Aftermath: Go dormant. Trigger two friendly Secrets to revive this minion."
 - Prophet Elenthris: 4 mana 4/5 Legendary "Opener: Add five Soulstones to your hand. Play them all to summon Magoria."
 - Soulstone (Token): 2 mana spell "Destroy a friendly minion. If you've played all five of these, awaken Magoria!"
 - Mother Magoria: 10 mana 10/10 "At the end of your turn, fill your board with random minions."
 - Channeler Initiate costs (3).
 - Dominant Will now costs (3).
 - Extract Nightmare costs (6).
 - Domineer costs (7).
 - Spectral Host no longer gives guard.
 - Essence Harvester’s heal reduced to 8.
 - Rite of Promise costs (1) and only Soulbinds once.
 - Rite of Pain costs (2) and only Soulbinds once.
 - Rite of Passage costs (3) and only Soulbinds once.
 - Stranded Memory is reworked into “Twisted Pathology”, a 5 mana 3/4 common spirit with “Dash. Opener: Each player draws 2 cards.”
 - Ravenous Soul has been reworked into Devoted Denizen,  2 mana 2/2 Spirit with Guard and "Aftermath: Soulbind."
 - Osiris is now a 5 mana 3/6 with "Opener: Return your other minions to your hand. Summon random minions with the same Costs."
 - Wailing Banshee is deleted.
 - Delve Into Memory is deleted.
 - Vaash Trinity is deleted.
 - Dormant Spirits is deleted.
 - Otherworld Wayfinder is deleted.
 - Olivia, the Successor is now a 4/3.
 - Channeler Initiate is now called "Seeker Initiate"
 - Jekk Trinity is now called "Lost Legionnaire"
 - Stranded Thought is now called “Afterthought”
 - Tortured Soul is now called "Dormant Soul"
 - Brink of Reality is now called "Brink of Existence"
 - Awaken is now a basic card (was core/classic).
 - Essence Harvester is now a core (classic) card (was setless).
 - Lost Legionnaire (formerly Jekk Trinity) is now a core (classic) card (was setless)

---

# [<](2020-02-05.md) 2020-02-06 [>](2020-02-07.md)

