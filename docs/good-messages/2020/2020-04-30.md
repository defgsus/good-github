# [<](2020-04-29.md) 2020-04-30 [>](2020-05-01.md)

3,178,738 events, 1,372,756 push events, 2,168,693 commit messages, 155,732,872 characters


## [juansolo816/HabitsTracker](https://github.com/juansolo816/HabitsTracker)@[287f98268c...](https://github.com/juansolo816/HabitsTracker/commit/287f98268c86fd0f534253c361ef35e55fa80ace)
#### Thursday 2020-04-30 03:33:52 by wolfderby

Tried moving sign-in to log-in/starting page.  Started getting same error as yesterday, I think google might have blocked the device thinking I'm a hacker. Button's now ugly, sorry Juan

---
## [david-fong/SnaKey-NTS](https://github.com/david-fong/SnaKey-NTS)@[b3f94ce39a...](https://github.com/david-fong/SnaKey-NTS/commit/b3f94ce39a5eacfc64ed5a8553e1dd55104647e4)
#### Thursday 2020-04-30 05:44:14 by david-fong

debug tslib missing import of private field polyfill

this took so long to figure out. Interesting note: It would have taken
significantly less time if I had faith to believe that the weird problem
I was experiencing with __classPrivateFieldGet/Set was not just bad
luck and just googled it so specifically. oh well.

on a more reflective note, web development is insane. I wanted to make
a comparison to development in C++ based on my experience with sudoku,
but I guess the context is not very comparable, and now that I think
about it, I also remember feeling that C++ development is a little
insane based on all its nuance and gotchas. I guess in that respect,
they are comparable and both very insane.

---
## [maxieds/MyProtestToTheIllinoisDMCATakedownActOf2017](https://github.com/maxieds/MyProtestToTheIllinoisDMCATakedownActOf2017)@[c50d4f7b9e...](https://github.com/maxieds/MyProtestToTheIllinoisDMCATakedownActOf2017/commit/c50d4f7b9e28b48fe98e35db66381c525f89d482)
#### Thursday 2020-04-30 06:56:04 by Maxie D. Schmidt

Nice guy :heart:

Can't say I wasn't warned by a truly elite, legendary hacker that Mr. Zych is not a "nice guy". Typically when someone from your past Alma Mater shows up to greet you in your new home in the Pacific Northwest, pledges allegiance to being our husband to all of our peers, social engineers my former skeptical mentor about my "husband" working at Microsoft Research (?!?, WTF), and promises my moom a ring (? -- sure, you actually want to take *that one* off our hands, not B%$^@##), we expect a little more breadth of conversation (so to speak). In reality he was only ever interested in showing up to stall, disrupt, and otherwise insert bullshit and chaos into an already dandy trip through Ph.D. land. What this guy is actually interested in doing is forever fucking me over for doing better than his expected value. Jared's refreshingly devoid of "toxic masculine" anger assures me that there are still good guys around that can hack it in that department.

---
## [scottnm/scottnm.github.io](https://github.com/scottnm/scottnm.github.io)@[fc834db5df...](https://github.com/scottnm/scottnm.github.io/commit/fc834db5dff9ed10199b4f9e4fc1169bb40fb084)
#### Thursday 2020-04-30 07:11:40 by Scott Munro

Google Page Insights said my page was garbage so I'm simplifying

- fix titles
- style update
- fix albumsof2018 post
- we red now
- align -est, -er naming to the color var naming
- dropping blue from names of css vars
- use css color vars
- fix video links
- drop pagination for better mobile experience
- prune some projects and remove the youtube links which was slowing shit down

---
## [maxieds/MyProtestToTheIllinoisDMCATakedownActOf2017](https://github.com/maxieds/MyProtestToTheIllinoisDMCATakedownActOf2017)@[296e9ad66b...](https://github.com/maxieds/MyProtestToTheIllinoisDMCATakedownActOf2017/commit/296e9ad66b0036ad2929cae8a2b85064ea8daa02)
#### Thursday 2020-04-30 07:40:02 by Maxie D. Schmidt

In defense (so to speak) of the incomplete notes archived here

I would be remiss to mention this little diddy, a saccharine for sure thinly veiled insult to some and obscene public fellation of yet others ([original citation](http://slice.cs.uiuc.edu/pubs/peiper_thesis.pdf)). It provides an effective defense of what I will point out again (and probably later again if it comes up) constitute a bored, half assed, incomprehensible set of data structures notes scribbled by a famous, however desperately hung over alter ego from a decade's past, that has still been defended as a golden saint in some online holy war debates (sadly no longer online). 

My tour through a slow grinding, lecturer-at-me eyeball gaze scorching tour through an already hellish set of first-time material for anyone in this class was over the Spring of 2005 (Cinda's class was not easier when I re-took it years later for credit with all the fantastic improvements, with the exception of some long archived missing lab code) -- ladies, and well gentlemen and worlocks that be, can we all together scream SEGFAULT really loud one more time for Jason at the back of the room (iff and only if you are totally cool and raise your hand)? :troll face: Personally, I preferred to take notes in class (a feature I have been mocked for by the "prankster", or court jester penguin, that was at the front of the room that year, because it never rendered correctly from the original language choices otherwise (C++, English, Jas0n). Judge yourself from the facts and artifacts left to us in the collected time capsule of this PR whether my methodology was correct.

I was actually unaware of this socially relevant teaching experiment in CS225 from 2005 until recently. My experiences with it in CS242 were to play with the terminal printing on the distributed tablets over WIFI in front of Professor Kamin standing next to me that day. Why my fanboy [242 TA](https://www.facebook.com/notes/maxie-schmidt/𝙄-𝙝𝙖𝙙-𝘾𝙞𝙣𝙙𝙖-𝙝𝙚𝙧-𝙛𝙞𝙧𝙨𝙩-𝙨𝙚𝙢𝙚𝙨𝙩𝙚𝙧-𝙤𝙛-𝘾𝙎225-𝙗𝙧𝙞𝙣𝙜-𝙗𝙖𝙘𝙠-𝙩𝙝𝙚-𝙘𝙖𝙨𝙚𝙨-𝙤-𝘽𝙖𝙬𝙡𝙨/616040372542752/) didn't mention his participation in the research project until we found this today remains elusive, but not a detail we ought really be preoccupied with for too long, right? 

Mostly, I want this note defending the honorable legacy of Jason's good qualities to be remembered in case I make the old boy look to foolish by reproducible authentic example elsewhere. In all fairness to historical scholars that seek to portray an accurate depiction of things as they lie, we cannot neglect this fan club of tri-colored ink. I always thought after viewing the online recordings from other CS classes that the clipped view of the whiteboard was an intentional delusion from the fact that Mr. Zych literally stared at me from minute 1-50 for nearly a semester incanting memorized material was done by him to dispose of his skeletons to speak of around that time. This account clearly contradicts, and accordingly negates, any way for me to claim otherwise. For that I am sorry (that I cannot omit verbose this tribute).

The original citation is freely available online as cited above. The author apparently received his thesis, or original research based, MS for this contribution to the course literature and departmental lore of lecturer personas past. Unfortunately, JZ's coursework based MCS tour through post graduate education did not allow us to capture the distinct essence of his stylistic contributions to this vast, fertile area of, well, CS and AP stats well enough to single out his pathological natural grasp on this stuff.

---
## [bilko94/lem.in](https://github.com/bilko94/lem.in)@[006b08f441...](https://github.com/bilko94/lem.in/commit/006b08f441c6548d65588b72e86374d4a1804c6d)
#### Thursday 2020-04-30 08:23:38 by Shane

omg yay my algo runs whoopy fuck you lemon you dickhead

---
## [brauner/linux](https://github.com/brauner/linux)@[8885700750...](https://github.com/brauner/linux/commit/88857007504993c7d59bcb48cbf56219453413e7)
#### Thursday 2020-04-30 09:10:03 by Christian Brauner

nsproxy: attach to namespaces via pidfds

For quite a while we have been thinking about using pidfds to attach to
namespaces. This patchset has existed for about a year already but we've
wanted to wait to see how the general api would be received and adopted.
Now that more and more programs in userspace have started using pidfds
for process management it's time to send this one out.

This patch makes it possible to use pidfds to attach to the namespaces
of another process, i.e. they can be passed as the first argument to the
setns() syscall. When only a single namespace type is specified the
semantics are equivalent to passing an nsfd. That means
setns(nsfd, CLONE_NEWNET) equals setns(pidfd, CLONE_NEWNET). However,
when a pidfd is passed, multiple namespace flags can be specified in the
second setns() argument and setns() will attach the caller to all the
specified namespaces all at once or to none of them. Specifying 0 is not
valid together with a pidfd.

The obvious example where this is useful is a standard container
manager interacting with a running container: pushing and pulling files
or directories, injecting mounts, attaching/execing any kind of process,
managing network devices all these operations require attaching to all
or at least multiple namespaces at the same time. Given that nowadays
most containers are spawned with all namespaces enabled we're currently
looking at at least 14 syscalls, 7 to open the /proc/<pid>/ns/<ns>
nsfds, another 7 to actually perform the namespace switch. With time
namespaces we're looking at about 16 syscalls.
(We could amortize the first 7 or 8 syscalls for opening the nsfds by
 stashing them in each container's monitor process but that would mean
 we need to send around those file descriptors through unix sockets
 everytime we want to interact with the container or keep on-disk
 state. Even in scenarios where a caller wants to join a particular
 namespace in a particular order callers still profit from batching
 other namespaces. That mostly applies to the user namespace but
 all container runtimes I found join the user namespace first no matter
 if it privileges or deprivileges the container similar to how unshare
 behaves.)
With pidfds this becomes a single syscall no matter how many namespaces
are supposed to be attached to.
A decently designed, large-scale container manager usually isn't the
parent of any of the containers it spawns so the containers don't die
when it crashes or needs to update or reinitialize. This means that
for the manager to interact with containers through pids is inherently
racy especially on systems where the maximum pid number is not
significicantly bumped. This is even more problematic since we often spawn
and manage thousands or ten-thousands of containers. Interacting with a
container through a pid thus can become risky quite quickly. Especially
since we allow for an administrator to enable advanced features such as
syscall interception where we're performing syscalls in lieu of the
container. In all of those cases we use pidfds if they are available and
we pass them around as stable references. Using them to setns() to the
target process namespaces is as reliable as using nsfds. Either the
target process is already dead and we get ESRCH or we manage to attach
to its namespaces but we can't accidently attach to another process'
namespaces. So pidfds lend themselves to be used with this api.

Apart from significiantly reducing the number of syscalls from double
digit to single digit which is a decent reason post-spectre/meltdown
this also allows to switch to a set of namespaces atomically, i.e.
either attaching to all the specified namespaces succeeds or we fail. If
we fail we haven't changed a single namespace. There are currently three
namespaces that can fail (other than for ENOMEM which really is not
very interesting since we then have other problems anyway) for
non-trivial reasons, user, mount, and pid namespaces. We can fail to
attach to a pid namespace if it is not our current active pid namespace
or a descendant of it. We can fail to attach to a user namespace because
we are multi-threaded, because our current mount namespace shares
filesystem state with other tasks, or because we're trying to setns()
to the same user namespace, i.e. the target task has the same user
namespace as we do. We can fail to attach to a mount namespace because
it shares filesystem state with other tasks or because we fail to lookup
the new root for the new mount namespace. In most non-pathological
scenarios these issues can be somewhat mitigated. But there's e.g.
still an inherent race between trying to setns() to the mount namespace
of a task and that task spawning a child with CLONE_FS. If that process
runs in a new user namespace we must have already setns()ed into the new
user namespace otherwise we fail to attach to the mount namespace. There
are other cases similar to that and we've had issues where we're
half-attached to some namespace and failing in the middle. I've talked
about some of these problem during the hallway track (something only the
pre-COVID-19 generation will remember) of Plumber in Los Angeles in
2018(?). Even if all these issues could be avoided with super careful
userspace coding it would be nicer to have this done in-kernel. Pidfds
seem to lend themselves nicely for this.

The other neat thing about this is that setns() becomes a full
counterpart to the namespace bits of unshare().

A few notes on implementation specifics.

Cc: Eric W. Biederman <ebiederm@xmission.com>
Cc: Serge Hallyn <serge@hallyn.com>
Cc: Jann Horn <jannh@google.com>
Cc: Michael Kerrisk <mtk.manpages@gmail.com>
Cc: Aleksa Sarai <cyphar@cyphar.com>
Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>
---
If we agree that this is useful than I'd pick this up for for v5.8.
There's probably some smart trick around nsproxy and pidns life-cycle
management that I'm missing but I tried to be conservative wrt to taking
references.
/* v2 */
- Michael Kerrisk <mtk.manpages@gmail.com>:
  - Michael pointed out that the semantics for setns(nsfd, 0) and
    setns(pidfd, 0) are not comparable. setns(pidfd, 0) is now
    disallowed completely. Users wanting to attach to all namespaces
    should simply specify them explicitly just as with unshare() and
    clone3().
- Jann Horn <jannh@google.com>:
  - Jann pointed out that the setns() in its first form wasn't atomic in
    that userspace could end up in an intermediate state where e.g. the
    process had moved into the target user namespace but failed to move
    into the target mount namespace.
    In this new version I've removed all intermediate states. There's an
    installation/preparation state and a commit state similar to
    prepare_creds() and commit_creds().

---
## [derrod/legendary](https://github.com/derrod/legendary)@[8f7db143a6...](https://github.com/derrod/legendary/commit/8f7db143a6ee5d68f1a3dcf3bb4f27e86147e935)
#### Thursday 2020-04-30 10:03:51 by derrod

[downloader] Greatly simplify download task creation

This is a change to something that was so massively stupid and
overcomplicated that I feel like I need to explain and justify myself:

After figuring out the format for manifests and spending countless
hours staring at IDA/Ghidra I kinda was sick of that, so I decided to
figure out what to do with the manifest myself by playing around with
it, which was also a lot more fun than looking through disassembly.

When looking at the chunks and files it quickly became obvious that the
way they're created is by concatenating all files into 1 MiB chunks that
can be downloaded and reassmebled (mostly) sequentially. What I did not
know was how the order of files in this "stream" was determined.

In playing around with it I came up with the old method: essentially
forming a chain of files, because each file's end generally pointed to
the start of the next file. And it worked great! At least until now...

Yesterday somebody alerted me to a game where this failed and it took me
a bit to figure out. Essentially the chaining had failed because
multiple files started at the same offset, but some of them would follow
another chain that never went back to the chunk it started at,
effectively skipping those files. This was rather annoying to deal with,
I came up with a workaround but it wasn't pretty. So I decided to jump
back into IDA/Ghidra and find out how Epic does it for real.

Well it took me a while, but thanks to symbols (yay macOS!) and a decent
decompiler in Ghidra even a noob like me was able to find it eventually.
The answer is as simple as it can be: the files are sorted alphabetically
(case-insensitive).

So really all I ever had to do was to sort files alphabetically and then
run through them to create the list of tasks.

I feel so stupid.

P.S.: I tested a few games and for the most part the resulting file
processing order is identical between the old and the new method. The
cases where it differs is when there's heavy de-duplication happening
(e.g. Diabotical's small model files) but the runtime cache size remains
the same so both methods are equally efficient, the old one just can't
handle certain cases.

---
## [BeloneX/BeeStation-Hornet](https://github.com/BeloneX/BeeStation-Hornet)@[d7be1b2c2c...](https://github.com/BeloneX/BeeStation-Hornet/commit/d7be1b2c2cba922234e0b0bcc9dfae4cee61662a)
#### Thursday 2020-04-30 11:04:28 by anconfuzedrock

makes fire axes 1 shot rwindows again (#46357)

About The Pull Request

this just makes fire axes smash windows properly again. not much to say.
Why It's Good For The Game

I don't think I can call the fire axe nerf intended, but even if it is, it was unwarranted if the rwindow buffs were supposed to do what they were supposed to do. Only places that get fire axes are atmos and bridge. for atmos, it does fuck all since atmos can easily get an rcd anyways. CE, HOP, HOS, and cap give minimal shits about reinforced windows anyways, and the RD has access to tools, so it just changes much for the CMO. the fire axe is especially crucial now that any douchebag can cover a hall in impenetrable windows. It's physically painful to watch a ce try to clean that up himself. this won't break windows much faster than an RCD, but it is cheaper. Note that a fire axe can currently break windows at similar speeds to a pre changes toolbox.
Changelog

cl
fix: The fire axe instakills windows again.
/cl

---
## [Caldony/tgstation](https://github.com/Caldony/tgstation)@[2bd5b0db06...](https://github.com/Caldony/tgstation/commit/2bd5b0db06e56e366b3f84e6d3c41ff0926edce5)
#### Thursday 2020-04-30 11:43:26 by Caldony

Adds the warping crossbreed!

all the warping crossbreeds are here! and they work! I still have very shitty MS paint coder sprites for each of them so sorry about that.

---
## [newstools/2020-the-times](https://github.com/newstools/2020-the-times)@[ebc6b43258...](https://github.com/newstools/2020-the-times/commit/ebc6b432583d985bd3c22f3ec2ed32e790b80592)
#### Thursday 2020-04-30 12:56:47 by NewsTools

Created Text For URL [www.timeslive.co.za/sport/2020-04-30-we-have-lost-a-brother-friends-remember-much-loved-umhlobo-wenene-presenter-loyiso-sitsheke/]

---
## [JOJ0/discodos](https://github.com/JOJ0/discodos)@[0a04023acf...](https://github.com/JOJ0/discodos/commit/0a04023acf83e38889b314070f042d6452ea5546)
#### Thursday 2020-04-30 13:07:35 by J0J0 T

utils: Config: fix win wrappers when packaged

also rename setup.exe to winconfig.exe for a very stupid reason:
seems like whenever a programs filename (!) contains the term "setup",
Windows 10 launches a security dialog first and then launches the program
_not in terminal mode_ even though the program was not packaged to run
in windowed mode! A console window showing the programs terminal output is
popping up and closing quickly again - reading impossible.
Thanks a lot M$ for this bullshit wanna-be-security-feature! What were
you thinking? This is helping against the ugly hackers? Goddamnit.....

---
## [SvetaMorkva/QA_KA-76](https://github.com/SvetaMorkva/QA_KA-76)@[73e08b8c0b...](https://github.com/SvetaMorkva/QA_KA-76/commit/73e08b8c0b83fcd9fed2a2b37b83dc013dbe39a1)
#### Thursday 2020-04-30 13:40:23 by Dmytro Ihnatov

One gun is definitely not enough.
Team 'motherfucking Abrams tank' anyone? FIND ME A GOD DAMN NUCLEAR
MISSILE PLZ!!!!!!!!!!

---
## [vgtmhl/crwn-clothing](https://github.com/vgtmhl/crwn-clothing)@[a3d22d91b7...](https://github.com/vgtmhl/crwn-clothing/commit/a3d22d91b75f90fa541612cc8d32c06971ec8d62)
#### Thursday 2020-04-30 14:27:18 by vgtmhl

implemented sign in with google and sign in with email through sagas. logout feature and persistence need fix now :) i hate my life

---
## [brauner/linux](https://github.com/brauner/linux)@[997a920cb2...](https://github.com/brauner/linux/commit/997a920cb2cd0f71d5ed87bef494cfb626bcfd9c)
#### Thursday 2020-04-30 15:51:20 by Christian Brauner

nsproxy: attach to namespaces via pidfds

For quite a while we have been thinking about using pidfds to attach to
namespaces. This patchset has existed for about a year already but we've
wanted to wait to see how the general api would be received and adopted.
Now that more and more programs in userspace have started using pidfds
for process management it's time to send this one out.

This patch makes it possible to use pidfds to attach to the namespaces
of another process, i.e. they can be passed as the first argument to the
setns() syscall. When only a single namespace type is specified the
semantics are equivalent to passing an nsfd. That means
setns(nsfd, CLONE_NEWNET) equals setns(pidfd, CLONE_NEWNET). However,
when a pidfd is passed, multiple namespace flags can be specified in the
second setns() argument and setns() will attach the caller to all the
specified namespaces all at once or to none of them. Specifying 0 is not
valid together with a pidfd.

The obvious example where this is useful is a standard container
manager interacting with a running container: pushing and pulling files
or directories, injecting mounts, attaching/execing any kind of process,
managing network devices all these operations require attaching to all
or at least multiple namespaces at the same time. Given that nowadays
most containers are spawned with all namespaces enabled we're currently
looking at at least 14 syscalls, 7 to open the /proc/<pid>/ns/<ns>
nsfds, another 7 to actually perform the namespace switch. With time
namespaces we're looking at about 16 syscalls.
(We could amortize the first 7 or 8 syscalls for opening the nsfds by
 stashing them in each container's monitor process but that would mean
 we need to send around those file descriptors through unix sockets
 everytime we want to interact with the container or keep on-disk
 state. Even in scenarios where a caller wants to join a particular
 namespace in a particular order callers still profit from batching
 other namespaces. That mostly applies to the user namespace but
 all container runtimes I found join the user namespace first no matter
 if it privileges or deprivileges the container similar to how unshare
 behaves.)
With pidfds this becomes a single syscall no matter how many namespaces
are supposed to be attached to.

A decently designed, large-scale container manager usually isn't the
parent of any of the containers it spawns so the containers don't die
when it crashes or needs to update or reinitialize. This means that
for the manager to interact with containers through pids is inherently
racy especially on systems where the maximum pid number is not
significicantly bumped. This is even more problematic since we often spawn
and manage thousands or ten-thousands of containers. Interacting with a
container through a pid thus can become risky quite quickly. Especially
since we allow for an administrator to enable advanced features such as
syscall interception where we're performing syscalls in lieu of the
container. In all of those cases we use pidfds if they are available and
we pass them around as stable references. Using them to setns() to the
target process' namespaces is as reliable as using nsfds. Either the
target process is already dead and we get ESRCH or we manage to attach
to its namespaces but we can't accidently attach to another process'
namespaces. So pidfds lend themselves to be used with this api.

Apart from significiantly reducing the number of syscalls from double
digit to single digit which is a decent reason post-spectre/meltdown
this also allows to switch to a set of namespaces atomically, i.e.
either attaching to all the specified namespaces succeeds or we fail. If
we fail we haven't changed a single namespace. There are currently three
namespaces that can fail (other than for ENOMEM which really is not
very interesting since we then have other problems anyway) for
non-trivial reasons, user, mount, and pid namespaces. We can fail to
attach to a pid namespace if it is not our current active pid namespace
or a descendant of it. We can fail to attach to a user namespace because
we are multi-threaded or because our current mount namespace shares
filesystem state with other tasks, or because we're trying to setns()
to the same user namespace, i.e. the target task has the same user
namespace as we do. We can fail to attach to a mount namespace because
it shares filesystem state with other tasks or because we fail to lookup
the new root for the new mount namespace. In most non-pathological
scenarios these issues can be somewhat mitigated. But there are cases where
we're half-attached to some namespace and failing to attach to another one.
I've talked about some of these problem during the hallway track (something
only the pre-COVID-19 generation will remember) of Plumbers in Los Angeles
in 2018(?). Even if all these issues could be avoided with super careful
userspace coding it would be nicer to have this done in-kernel. Pidfds seem
to lend themselves nicely for this.

The other neat thing about this is that setns() becomes an actual
counterpart to the namespace bits of unshare().

Cc: Eric W. Biederman <ebiederm@xmission.com>
Cc: Serge Hallyn <serge@hallyn.com>
Cc: Jann Horn <jannh@google.com>
Cc: Michael Kerrisk <mtk.manpages@gmail.com>
Cc: Aleksa Sarai <cyphar@cyphar.com>
Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>
---
If we agree that this is useful than I'd pick this up for for v5.8.
There's probably some smart trick around nsproxy and pidns life-cycle
management that I'm missing but I tried to be conservative wrt to taking
references.
/* v2 */
- Michael Kerrisk <mtk.manpages@gmail.com>:
  - Michael pointed out that the semantics for setns(nsfd, 0) and
    setns(pidfd, 0) are not comparable. setns(pidfd, 0) is now
    disallowed completely. Users wanting to attach to all namespaces
    should simply specify them explicitly just as with unshare() and
    clone3().
- Jann Horn <jannh@google.com>:
  - Jann pointed out that the setns() in its first form wasn't atomic in
    that userspace could end up in an intermediate state where e.g. the
    process had moved into the target user namespace but failed to move
    into the target mount namespace.
    In this new version I've removed all intermediate states. There's an
    installation/preparation state and a commit state similar to
    prepare_creds() and commit_creds().

---
## [newstools/2020-daily-dispatch](https://github.com/newstools/2020-daily-dispatch)@[a53b12584d...](https://github.com/newstools/2020-daily-dispatch/commit/a53b12584dda4abd18a0084124090f38d9227302)
#### Thursday 2020-04-30 15:52:06 by NewsTools

Created Text For URL [www.dispatchlive.co.za/news/2020-04-30-we-have-lost-a-brother-friends-remember-much-loved-umhlobo-wenene-presenter-loyiso-sitsheke/]

---
## [brauner/linux](https://github.com/brauner/linux)@[f6552336c7...](https://github.com/brauner/linux/commit/f6552336c7a7149b0b055a4357aaa7ba148c7c03)
#### Thursday 2020-04-30 16:15:25 by Christian Brauner

nsproxy: attach to namespaces via pidfds

For quite a while we have been thinking about using pidfds to attach to
namespaces. This patchset has existed for about a year already but we've
wanted to wait to see how the general api would be received and adopted.
Now that more and more programs in userspace have started using pidfds
for process management it's time to send this one out.

This patch makes it possible to use pidfds to attach to the namespaces
of another process, i.e. they can be passed as the first argument to the
setns() syscall. When only a single namespace type is specified the
semantics are equivalent to passing an nsfd. That means
setns(nsfd, CLONE_NEWNET) equals setns(pidfd, CLONE_NEWNET). However,
when a pidfd is passed, multiple namespace flags can be specified in the
second setns() argument and setns() will attach the caller to all the
specified namespaces all at once or to none of them. Specifying 0 is not
valid together with a pidfd.

The obvious example where this is useful is a standard container
manager interacting with a running container: pushing and pulling files
or directories, injecting mounts, attaching/execing any kind of process,
managing network devices all these operations require attaching to all
or at least multiple namespaces at the same time. Given that nowadays
most containers are spawned with all namespaces enabled we're currently
looking at at least 14 syscalls, 7 to open the /proc/<pid>/ns/<ns>
nsfds, another 7 to actually perform the namespace switch. With time
namespaces we're looking at about 16 syscalls.
(We could amortize the first 7 or 8 syscalls for opening the nsfds by
 stashing them in each container's monitor process but that would mean
 we need to send around those file descriptors through unix sockets
 everytime we want to interact with the container or keep on-disk
 state. Even in scenarios where a caller wants to join a particular
 namespace in a particular order callers still profit from batching
 other namespaces. That mostly applies to the user namespace but
 all container runtimes I found join the user namespace first no matter
 if it privileges or deprivileges the container similar to how unshare
 behaves.)
With pidfds this becomes a single syscall no matter how many namespaces
are supposed to be attached to.

A decently designed, large-scale container manager usually isn't the
parent of any of the containers it spawns so the containers don't die
when it crashes or needs to update or reinitialize. This means that
for the manager to interact with containers through pids is inherently
racy especially on systems where the maximum pid number is not
significicantly bumped. This is even more problematic since we often spawn
and manage thousands or ten-thousands of containers. Interacting with a
container through a pid thus can become risky quite quickly. Especially
since we allow for an administrator to enable advanced features such as
syscall interception where we're performing syscalls in lieu of the
container. In all of those cases we use pidfds if they are available and
we pass them around as stable references. Using them to setns() to the
target process' namespaces is as reliable as using nsfds. Either the
target process is already dead and we get ESRCH or we manage to attach
to its namespaces but we can't accidently attach to another process'
namespaces. So pidfds lend themselves to be used with this api.
The other main advantage is that with this change the pidfd becomes the
only relevant token for most container interactions and it's the only
token we need to create and send around.

Apart from significiantly reducing the number of syscalls from double
digit to single digit which is a decent reason post-spectre/meltdown
this also allows to switch to a set of namespaces atomically, i.e.
either attaching to all the specified namespaces succeeds or we fail. If
we fail we haven't changed a single namespace. There are currently three
namespaces that can fail (other than for ENOMEM which really is not
very interesting since we then have other problems anyway) for
non-trivial reasons, user, mount, and pid namespaces. We can fail to
attach to a pid namespace if it is not our current active pid namespace
or a descendant of it. We can fail to attach to a user namespace because
we are multi-threaded or because our current mount namespace shares
filesystem state with other tasks, or because we're trying to setns()
to the same user namespace, i.e. the target task has the same user
namespace as we do. We can fail to attach to a mount namespace because
it shares filesystem state with other tasks or because we fail to lookup
the new root for the new mount namespace. In most non-pathological
scenarios these issues can be somewhat mitigated. But there are cases where
we're half-attached to some namespace and failing to attach to another one.
I've talked about some of these problem during the hallway track (something
only the pre-COVID-19 generation will remember) of Plumbers in Los Angeles
in 2018(?). Even if all these issues could be avoided with super careful
userspace coding it would be nicer to have this done in-kernel. Pidfds seem
to lend themselves nicely for this.

The other neat thing about this is that setns() becomes an actual
counterpart to the namespace bits of unshare().

Cc: Eric W. Biederman <ebiederm@xmission.com>
Cc: Serge Hallyn <serge@hallyn.com>
Cc: Jann Horn <jannh@google.com>
Cc: Michael Kerrisk <mtk.manpages@gmail.com>
Cc: Aleksa Sarai <cyphar@cyphar.com>
Signed-off-by: Christian Brauner <christian.brauner@ubuntu.com>
---
If we agree that this is useful than I'd pick this up for for v5.8.
There's probably some smart trick around nsproxy and pidns life-cycle
management that I'm missing but I tried to be conservative wrt to taking
references.
/* v2 */
- Michael Kerrisk <mtk.manpages@gmail.com>:
  - Michael pointed out that the semantics for setns(nsfd, 0) and
    setns(pidfd, 0) are not comparable. setns(pidfd, 0) is now
    disallowed completely. Users wanting to attach to all namespaces
    should simply specify them explicitly just as with unshare() and
    clone3().
- Jann Horn <jannh@google.com>:
  - Jann pointed out that the setns() in its first form wasn't atomic in
    that userspace could end up in an intermediate state where e.g. the
    process had moved into the target user namespace but failed to move
    into the target mount namespace.
    In this new version I've removed all intermediate states. There's an
    installation/preparation state and a commit state similar to
    prepare_creds() and commit_creds().

---
## [manavmehta/zulip](https://github.com/manavmehta/zulip)@[689aca9140...](https://github.com/manavmehta/zulip/commit/689aca91407ea105c89bdfd526de7b82ab9f0134)
#### Thursday 2020-04-30 17:02:49 by Steve Howell

refactor: Extract validate_email_is_valid().

This has two goals:

    - sets up a future commit to bulk-validate
      emails

    - the extracted function is more simple,
      since it just has errors, and no codes
      or deactivated flags

This commit leaves us in a somewhat funny
intermediate state where we have
`action.validate_email` being a glorified
two-line function with strange parameters,
but subsequent commits will clean this up:

    - we will eliminate validate_email
    - we will move most of the guts of its
      other callee to lib/email_validation.py

To be clear, the code is correct here, just
kinda in an ugly, temporarily-disorganized
intermediate state.

---
## [d8ahazard/HueDream](https://github.com/d8ahazard/HueDream)@[5a1f673985...](https://github.com/d8ahazard/HueDream/commit/5a1f67398530c641cbae370c3a54d980c0fa2038)
#### Thursday 2020-04-30 17:07:10 by d8ahazard

LINT ALL THE THINGS!

Because being obsessed with fixing every warning and suggestion in your IDE is both a blessing and a curse. Clean, happy code...spending lots of time just making things pretty.

---
## [alexanderogle/infection_simulation](https://github.com/alexanderogle/infection_simulation)@[e847f9821c...](https://github.com/alexanderogle/infection_simulation/commit/e847f9821cdd5905e0ca487a74409665a6783e1d)
#### Thursday 2020-04-30 18:24:12 by Joelle Murray

i totally still don't understand what i'm doing, but i think i pushed these 2 files from my local to alex's repository. 
1. codeSIR.py is a stand alone program that uses coupled linear ODEs to find the compartment populations in a simple SIR model. I'll rewrite it as a function.
2. connmod.py is a simple function that calculates the number of connections an individual has based on the population density and the interaction area. I'll probably change it to number of steps in a day and distance within infection is possible (social distancing recommended distance).

Please don't laugh too hard at the old lady learning new tricks - and thank you guys for all of your patience and guidance. You both would make excellent teachers some day if you ever feel like having a satisfying job that doesn't pay you very well. Hahaha. I'm pretty sure these summaries aren't supposed to be this long. sorry!

---
## [asl677/cromwell](https://github.com/asl677/cromwell)@[b290967444...](https://github.com/asl677/cromwell/commit/b290967444e8011f7787877315ae1db0fc8f51e4)
#### Thursday 2020-04-30 21:42:13 by Alex

shit fuck fixes

- mobile stagger was horrible
- split width adjustments
- match mock anim timing

---
## [NetBSD/src](https://github.com/NetBSD/src)@[08e5f5529c...](https://github.com/NetBSD/src/commit/08e5f5529cc4da0076e73eb0e2f15f7394f07797)
#### Thursday 2020-04-30 22:12:38 by tsutsui

Add workaround typedefs for awful hack.

XXX: It's completely unacceptable for me to refer libsa files from userland.
XXX: Nowadays we no longer have serious size restriction in install media,
XXX: so I think it's much better to simply remove this ugly SMALLPROG hacks.
XXX: If you really want to share files, please move them into src/common
XXX: with defined APIs.

---

# [<](2020-04-29.md) 2020-04-30 [>](2020-05-01.md)

