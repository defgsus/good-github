# [<](2020-07-07.md) 2020-07-08 [>](2020-07-09.md)

2,771,732 events, 1,225,838 push events, 2,003,637 commit messages, 150,516,210 characters


## [Atheos/Atheos](https://github.com/Atheos/Atheos)@[d28a1dc458...](https://github.com/Atheos/Atheos/commit/d28a1dc458893dd16eb10357af0b8cc8cdc25326)
#### Wednesday 2020-07-08 00:36:47 by Liam Siira

Honestly should have commit more often because the amount of changes to the website are quite drastic.
Luckily the website is still pretty basic and not really a "for-production" codebase. In summary, I've been trying to update the site to be a fully fledged home page for Atheos and provide everything I feel users of Atheos would deserver. I've turned the website into more of a PHP router with markdown files and some probably stupid complex PHP action in the background. Hopefully this is a good direction, if not, I just wasted my time; no big deal. It's not a hard site to code for or make changes to. I'm sorry about not committing more often for each individual change.

---
## [TravisGM92/battle_ship](https://github.com/TravisGM92/battle_ship)@[f219f6f08d...](https://github.com/TravisGM92/battle_ship/commit/f219f6f08d870a4a620f5a8b67a870af36ddf7c2)
#### Wednesday 2020-07-08 01:44:10 by Luke Hunter James-Erickson

Merge pull request #1 from TravisGM92/travis_branch

Great work tonight.  You really know your stuff!  Thanks for not only being a good collaborator (mainly in that you listened to some of my crazy ideas haha), but a chipper fella.  Can't wait for tomorrow!

---
## [petre-symfony/modern-react-udemy](https://github.com/petre-symfony/modern-react-udemy)@[f5623135ed...](https://github.com/petre-symfony/modern-react-udemy/commit/f5623135ed5efce0cceaa69aa2fdf3bf68cf5a45)
#### Wednesday 2020-07-08 04:51:58 by petrero

285. OAuth-Based Authentication 286. OAuth for Servers vs Browser Apps 287. Creating OAuth Credentials(Section 21: Handling Authentication with React)

I think that we've now got a pretty good idea of how re-act router Dohm works inside of application

and we've also written out a pretty good amount of code to set up some initial idea around navigation.

So we're not going to start to pivot our attention and focus on handling authentication inside of our

app.

In this video we're going to have a general discussion on how we handle authentication in general like

any type of web application and then we will very quickly start to talk about how we're going to work

it specifically into a react and redux application.

So let's get to it.

All right.

So first off the idea here is that inside of her head her we're going to have some button that says

something like log in with Google to handle authentication.

We're going to use Google's off to authentication flow.

I can almost guarantee you that you have gone through a lot flow before in your own experience.

So any time that you ever click on some button like log in with Google or log in with Facebook or logging

into LinkedIn that is you going through a lot 2.00 flow the pinnacle or the very traditional screen

that you see anytime you go through a lot.

Flow is someone window like this over here is something that says hey this application wants to know

your e-mail address or access your profile or whatever else it might be.

And then you as a user can either accept or reject that request.

So in this video we're going to get a better idea of what it really is and how the flow works.

Let's get to it.

All right.

So in many applications that you've used You've probably also seen e-mail and password authentication.

Even Google itself when you sign into Google or Facebook you have to use e-mail and password authentication

with this very classic form about an occasion over here.

We generally store a record inside of some type of database and that record is going to maintain the

user's e-mail address and their encrypted password.

And so with email and password authentication you're essentially inside of your own application or maintaining

a record of who each user is.

And you have some very intricate and detailed information about each and every user and each time that

a user tries to log in with email and password authentication we're essentially going to take and compare

the e-mails entered e-mail and password with whatever is saved inside the database.

And then a user is considered to be logged in to an application whenever they enter the correct email

and password.

So again that is traditional email and password authentication.

So let's kind of compare that kind of easier or more traditional sense of authentication with Olof authentication

which is what you and I are going to use.

So with authentication a user is going to first authenticate with some outside service provider through

email and password authentication means an outside service provider is any provider such as Google or

LinkedIn or Facebook as very popular examples.

Now with this flow we are essentially getting a user to authorize our application to access their information

stored on Google's or LinkedIn or Facebook servers.

So this outside provider is going to essentially tell us some information about this user such as their

email their name or whatever other info you and I request.

So we are really trusting this outside provider quite a bit to identify this user and we are absolutely

trusting this outside provider that they are telling us correct information here.

A good analogy here is to imagine if you are running some type of like lottery operation like lets say

you put a lottery together and someone comes through your door inside of your office and says Hey I

just won the lottery Ive got a winning ticket.

If you are the lottery provider and youre running this lottery chances are the first thing you want

to do is make sure that this person is who they say they are right.

You want to make sure that they are so and so and that they actually won the lottery with that ticket

in hand.

And so you can either kind of take that person's identification like maybe a driver's license or something

like that.

Or if that person has some friend who will vouch for them it would be like you trusting that friend

to say oh yes this person is who they say they are.

So with email and pass TROETH indication that is like you collecting credentials on your own like some

identification for the user.

Whereas with authentication we are essentially trusting some friend of that person saying that they

are who they say they are now with Oh.

It's really a kind of two sided thing that we get with off with email and password authentication this

is solely about authentication.

It is just about identifying a user and associating some information with them or with oh off we actually

get kind of two results out of this flow.

On the one hand we still get that same type of user identification inside of application.

So when the user goes through the flow we get some information that says oh yeah this is Jane Doe and

this is their email address and here is their picture or whatever it is.

But with the flow we also can request access to make actions on behalf of the user through that service

provider.

Now classic examples of that would be like if we put together some application that wanted to manage

a user's e-mail account like maybe filter their emails or try to read their emails.

We would use a lot flow to get access to that user's e-mail account.

So Olaf is not only about authentication it's also about letting our application get access to all that

user's data on some outside service provider.

Now in our case we're only concerned about use case number one here.

We are just making use of oath to identify a user we are not going to use cloth to try to like make

actions on behalf of the user and try to access Google services.

Now on that note on that.

Number two right there.

Very common question that I get is how do you use a watch to do that.

You know how do you actually use this offload to make actions or requests over to Google on behalf of

a user.

Just so you know as a quick side topic here every time that you go through a lot flow its eventually

is going to say something like Hey this Apple wants to know your e-mail access your profile maybe it

will also say read your browser history or access all of your e-mails or whatever else that might be

a list of things that the app wants to do is known as its list of scopes.

A scope is essentially a permission that you are granting to an application.

Now with Google in particular you can get a list of all valid scopes at this address right here.

Now keep in mind google very frequently changes.

You are or else.

So by the time you watch this video this link right here might be broken if that link is broken you

can always do a very simple Google search for something like Google.

Olof I don't know.

Scope list or something like that and you should see something like this right here on Earth 2.0 scopes

for Google API is so on this page is a list of all the different scopes that you can ask for.

And each of these different scopes are going to give you access to a different portion of the users

account.

Now in our case the only thing that you and I really care about is probably going to be like a user's

e-mail just so we can confirm that they are who they say they are and that we have some piece of information

too tied to a user.

So in our application we are probably going to ask for a scope of email somewhere inside of here.

We go.

So here's the list of scopes for Google sign in.

We can ask for a user's e-mail or their profile very easily and get the e-mails or the user's email

address or their basic profile info.

So we would use a scope named profile or email to get access to those two pieces of information if we

had asked for a scope of something like I don't know about this one right year.

So Google API is dot com slash off cloud platform that would allow us to manage the user's data across

all Google Cloud platform services or what have you if we wanted to access their email.

We would probably do a search on this page for Gmail like this right here.

And this is a list of scopes that we could ask for to get access to the user's e-mails so if we ask

for this scope right here then we would get the ability to read compose send in primally deletes all

email from G-mail.

And one thing I would make clear is that this scope is intended to be a string like a string value that

we are going to pass over to Google when we go through the overflow.

The scope even though it looks like a r l is not something that you're going to like add into your address

bar.

Let's talk more about scopes later on.

But like I said this is a very common question I get.

So I just want to very quickly give you a heads up on how you would kind of get access to a user's account.

All right.

So back over here a diagram.

Now if you've ever gone through one of my other courses before I have many courses that make use of

Google off and just about every Google overflow that I show and every single other course makes use

of a wealth for servers in this course for the first time ever.

So if you've gone through all that with me before this time it's going to be a little bit different.

So this is the first I'm going to show you how to do a lot for javascript browser apps or some javascript

code that is running inside the browser.

And so there's a little difference between these two flows right here.

Let's take a quick pause.

When we come back the next section I'll describe the differences between the two and how it's going

to affect how our application is set up.

So quick break and I'll see you in just a minute.

286. OAuth for Servers vs Browser Apps

In this video we're going to continue talking about how life works.

Now at the very end of the last video I had mentioned that if you've ever gone through a lot with me

before inside of another course I have shown you the oath for servers flow.

But in this application we're going to be using a slightly different flow or a slightly different setup.

This is going to be a flow specifically made for enabling authentication of users who are making use

of a javascript application running inside of a browser.

Let me tell you a couple of differences between the two.

The first thing the first difference is not really a difference at all.

So I want you to understand if you have learned this flow over here the flow we're going to be making

use of is very very similar in nature.

So at the end of the day both of these different flows are both these different approaches to handling

oath where the user is going to effectively kind of have the same result at the end of the day we are

asking the user to provide us access to information about them through some outside service provider.

And as a result of this process we're going to get some identifying information for the user such as

a profile or an e-mail address or an identification number.

And we're also going to get a token that is going to allow us to take some action on behalf of a user

without them directly involved or being involved.

So that's true of both these different flows.

Now usually we are going to be making use of the auth for servers flow.

Anytime that you are building an application that needs to access user data when they are not actively

logged into application or actively making use of it.

So an example of when you might definitely want to use this flow over here is if you are building some

application that is going to attempt to access the user's e-mail every 10 minutes and maybe attempt

to delete some e-mails that are flagged to spam or something like that but that type of application

you would want to be able to access their e-mail account every 10 minutes regardless of whether or not

the user is actively logged into your application and making use of it.

So for that type of application you would want to use this law for servers flow.

Now in our case we're not doing anything like that.

We are only making use of Google Earth just to allow a user to log in and then attempt to create a stream.

So we're not really associating a lot of information with the streams that are being created from each

of these users.

And we also don't have any need to attempt to access that user's data on Google servers so we're going

to instead use this other flow over here because we are only trying to kind of deal with this user when

they are actively logged into our application and making use of it.

All right.

So like I said we're going to be using this other flow over here.

Now I want to now show you a diagram that's going to help you understand exactly how this flow is going

to work.

At the end the day the flow that we're going to go through is going to be really easy and straightforward

because we're going to make use of a javascript library created by Google themselves to automate this

entire authentication process.

OK.

So here's the flow.

So the entire flow for a lot is going to be some interaction between our user and Google servers.

And there's actually going to be very little that you and I have to do inside this flow.

So we're going to start at the top left hand side and go through this step by step so everything is

going to begin when the user clicks on the log in with Google button inside of our header.

When that occurs we are going to hook up a click event handler to that button.

And so whenever user clicks on it we are going to run some code that is going to call Google's javascript

library and initiate the process.

When we do that call to that javascript library then that javascript library is going to automatically

automatically make an authentication request over to Google.

The result of which is going to be a little pop up window that appears inside the user's browser.

So this is going to be like a separate window that appears and prompts the user the user is going to

be prompted to grant access to our application to access their user account and get some information

about them.

So the user is going to click some Except button and then when that occurs that pop up window is going

to automatically close when the user accepts and that window closes the javascript library running inside

of our application is going to invoke a callback essentially inside of our react and redux application.

This callback is going to be invoked with some authorization token and profile information about the

user.

And that's what's going to identify this user and essentially prove that they are successfully logged

in through Google.

At that point in time we will then consider the user to be logged in as well.

Now as a part of this process but not shown on this diagram right here if the user ever happens to log

out of our application or happens to log out of Google servers we are going to get another callback

in vote and this other callback is going to essentially say hey the user just logged out.

So we'll need to make sure that we also wire up our application to listen for that call back then as

well.

Now if it seems like the flow rate here is really brief or you know kind of simplistic.

Well like I said this is a really easy way to get started with the flow.

Very simple very easy to get started with really easy to get a user to be signed in inside of your application

and then make requests on behalf of them or allow them some advanced access inside of your application.

OK so now that you've got kind of a vague idea of what's going to go on here let's take a quick pause.

When we come back the next video we're going to start doing a little bit of setup for Google authentication

inside of rap.

So quick break and I'll see you in just a minute.

287. Creating OAuth Credentials

In the last video we spoke about the flow that a user is going to go through whenever they initiate

a layoff inside of our application.

So now in this video we're going to start going to the actual setup process.

All right so here's the general idea of what we're going to do.

If you've already gone through that previous application building that YouTube application a couple

of these steps might feel a little bit familiar.

So the first thing we're going to go go to is the developers council at Google.com.

We're going to create a new project once we create this new project we're going to first set up in the

confirmation screen that confirmation screen is essentially the same one that you go through any time

that a user starts that flow.

And we asked the user for access to their e-mail or profile or whatever else after that.

We're then going to generate a lot Client ID.

This is going to be an identifying token that is going to identify our application to Google servers

following that will then install Google's API library and initialize it with that oath client id and

then we'll make sure that any time that the user clicks on that log in with Google button we make use

of that Google API library to start the process.

So let's get to it.

We're going to first begin by setting up a new project at council that developers start google.com.

So inside of a new browser tab I'll go to cons..

I always mix up the order there.

I always do.

Developers dot con..

All right console developers dot Google dot com.

Now once you come here remember you might see a project already on the screen.

If you have ever created a project with Google before you probably don't do NOT want to reuse a project

that you've already created.

Instead we want to create a new project so we're going to find the project dropdown up here at the top

left down side and then click on it.

Once we have this dropdown open or this pop up open then click on new project up here at the top right.

We then get asked to enter in a project name and so I'm going to use a project name of simply screamy

and then click on Create.

Now remember when you generate a project with Google you're going to see a little notification spinner

appear even though you think that you just create the project.

It is still in the process of being created.

And so when you get dumped back at this page you're still probably going to be looking at a previously

generated project.

So it's only after that notification spinner ends and I see that little one right there that my project

has been created and I can now successfully select it.

So I got to go back up to this dropped down on the top left hand side and select screamy.

So now I have the correct project selected.

All right so now we've generated our project.

We now need to set up an a confirmation screen so to do so we're going to find the credentials button

on the left hand side.

I'm going to go to a Watkin's sent screen and we're going to generate a new screen right here.

Now all we have to do is really enter in our application name going to entry in an application name

of stream me like so then I can go down to the bottom and click on safe.

After that I'm going to go back to the credentials section or select the credentials sub menu and then

I'll see this big notice right.

You're in the middle that says that we need to create a set of credentials.

So going to click on that button right there and we're going to make sure that we select a wath Client

ID.

We're not making an API key here.

We're making a client I.D. It's going to select that.

We then get asked what type of application we are making we're making it webapp will then see this little

form appear.

Now the only thing we have to add in here is a authorized javascript origin.

This little check right here or whatever you are right here is essentially a little security check.

Google is only going to allow requests to come in from a domain that is equal to whatever we list right

here.

So at present we are making use of our re-act application at local host 3000.

So I'm going to put in HTP colon slash slash localhost Kulin 3000 like so.

And notice that I did not put in HTP.

It is simply HTP.

And then I'll click on Create at the bottom I then see this pop up right here for my client and it has

my client ID.

So the only thing that we care about is the client id.

We are not going to be making use of our client secret.

We would only make use of that client secret if we were creating a flow with the first server's flow.

But we are doing a lot for G-S browser applications and for that type of flow we only need the client

id right here.

So I'm going to copy this ID and then I'm going to go back over to my code editor.

I'm going to create a new file.

I'm not going to create it in my project directory I'm just going to essentially go to file new file

and inside of here I'll say Client ID and L-Space that in like so.

Now again I'm not going to save this file because we're going to make use of this key in just a moment.

I just want to make sure that you don't lose it and have to go back over to the dashboard and get access

to it a second time.

OK that's it.

We've now got our client I.D..

So let's take a quick pause right here.

We can't close that window when we come back in the next video.

We're going to start to install the Google API library and then initialize it with that client id and

then set up that click event handler.

So quick pause and I'll see you in just a minute.

---
## [petre-symfony/modern-react-udemy](https://github.com/petre-symfony/modern-react-udemy)@[2b9a6c3563...](https://github.com/petre-symfony/modern-react-udemy/commit/2b9a6c3563d1890f57b22d404c3f3cfb11dbb078)
#### Wednesday 2020-07-08 04:56:11 by petrero

288. Wiring Up the Google API Library 289. Sending a User Into the OAuth Flow(Section 21: Handling Authentication with React)

In the last section we generated our oath Client ID.

So now the next thing we're going to do is install the Google API library into our project.

Now unfortunately Google themselves do not offer this library over NPM So we're not going to install

it via NPM.

Instead we're just going to add a manual script tag into our index.

It's simple file.

So to get started I'm going to open up my code editor or find my public directory and open up the index.

A html file inside there or then find the head tag.

And anywhere inside of the head tag I'm going to add in a script tag like so.

And then I'm going to give it a source of HTP.

Yes Colon slash slash a.p eyes.

Google dot com slash J.S. slash API Dutchie us like so.

And that's pretty much it.

Then I'll save this and then flip back over to the browser.

Now once I'm back over here I'm going to make sure that I refresh the page and then I'm going to open

up my javascript console once they have this open I should be able to write out the API like so.

And I should see an object like this right.

You're a peer So this object right here is the Google API that is available to us on the windows scope

inside of our browser.

So we're now going to create a new Riak component that's going to essentially wrap this Google Library

and Usher our user through the entire process.

We're going to have a discussion later on about how much this stuff should be included inside of redux

versus react.

But right now we're just going to get our waterflow working in re-act alone.

So in sodomite code editor I'm going to find my component's directory and insight there I'll make a

new file called Google off.

J.S. like so.

And then inside if you're going to put together some boilerplate for a class based component so let's

say import re-act from re-act or then define a class of Google off extends re-act dot component I'll

put together my render method all return.

For right now a simple div that says Google Earth.

And then of course I'll do my export default Google auth at the bottom.

Next up I'm going to flip back over to my app.

Actually not the app file.

You can flip over to the hetter because you want to eventually show a button related to authentication

in the header.

So we're going to hook up this component right here inside of our head or component or open up heterodoxy

Yes.

And in the very top I'll put an import Google off from Google off like so or then find the div with

the class name of right menu.

Inside there is the one link tag right now.

And so right next to that I'm going to create an instance of my Google off Riak component.

All right.

Let's save that.

We'll flip back over.

And I'm just going to make sure I see the text Google off the pier and sudden my application inside

the headers specifically and there it is right there.

That looks pretty good.

All right so now that we've got a component put together I want to tell you a little bit more about

how this Google API library works.

You see this GAAP thing right here is a multipurpose Google API library.

And we can use it to interact with the waterflow but we can also use it to work with all different types

of Google services.

Now this GAAP library is incredibly used are incredibly well distributed across the Internet a tremendous

number of Web sites load up this library.

So as such Google tries to keep this library as small as possible.

So any time that we want to use some particular aspect of functionality in this library we have to first

literally load up the javascript code related to the part of the library that we want to use when you

print out GAAP.

Right now you'll see that it only has a single function tied to it called load load right.

You're literally means load up some internal library by making a follow up request over to Google servers

and fetching some additional amount of javascript code and then adding it essentially to this Google

Library.

So to do so we're going to call G API dot load and then we're going to pass in a string of client colon

off to like so.

Now if you open up your network request tab before running that and clear your counsel or cleared the

log right there and make sure you're filtering by all we can then run that line of code and we'll see

this additional request automatically made to fetch some additional javascript code and load it up into

that library.

So now that that request has been completed we can then do a GA API doc client.

RC let's just print out the API by itself and you'll very quickly see that it has some additional properties

inside that object.

So your shape API now in addition to that load function.

We also have a couple of other functions inside of your as well.

We have something called off to and client and so on.

And as you might guess that to stuff is pretty darn relevant for what we're going to be trying to do.

So after we load up that additional library we can then register or initialize it with our off client

id by calling API client dot net.

And then we can pass in an object with Client ID and we'll put our client ID in there.

I'm not going to actually put it in there I just want to give you an idea of what we're going to end

up doing.

OK.

So we're going to essentially flip back over to our Google Earth component and go through this series

of steps right here.

Now remember we probably only want to initialize that library or kind of like load up the client portion

of the library.

One time when this component is first rendered onto the screen.

So with that in mind I'm going to define a component did MT lifecycle method inside of the Google off

component and then inside of here we would call window G API.

Load client colon off to like so now we have the window on here to make sure that it's really clear

that this is a variable g API that is available on Windows scope inside of our browser.

If you leave off the window Daut and save this then you're going to very quickly see a warning message

saying Hey this variable right the API is not known even though you and I know that it is available

on Windows scope.

So we saved that and then flip back over you're going to very quickly see exactly that error right there.

So all we have do is prefix it with window and then react create react up is going to say oh OK I get

it.

This variable is available on Windows scope.

So if we flip back over everything is working again OK.

So now any time that our component is rendered onto the screen we're going to try to load up that client

portion of the library.

Now when we load up that library it takes some amount of time for the library to reach over to Google

servers and download some additional Javascript code.

So we need to essentially get a callback of when that process is complete.

So to add in a callback we can add in a second argument year of an arrow function and this function

is only going to be called after this client or to library has been successfully loaded up into the

API.

So then inside of this callback function we're going to call window GA API client dot in that we'll

pass in an object and this object is going to have our client ID.

So after we successfully load up the client library we're going to initialize our application with the

client id that we had generated in the last video.

So I'm going to flip over to that other file that we had created with my client ID inside of it and

I went to copy the entire client id right here and then I'll paste it in for my client id right there

like so.

Now there's one other option we have to pasted in here in addition to the Client ID.

So I'm going to put a comma at the end of that line.

And then on the next line down I'm going to say scope right here we're going to specify the different

scopes that we want to load up when we take that user or that we want to fetch when the user goes through

the process as a reminder.

Scope's stuff is essentially talking about what different parts of the user's profile or the user account

that we want to get access to.

So in our case we're just going to say that we want to get access to the user's e-mail member.

We're not actually using their e-mail or their profile or anything like that.

I just want to give you an example of how we can somehow access their email.

All right.

So scope right here as a string will out in e-mail.

All right.

So that's pretty much it.

Now this right here is just going to initialize the library.

It's not going to actually take the user through the process.

Let's take a quick pause right here.

When we come back the next section we're going to talk about how we can actually use this now initiated

G API client thing to initiate the A D awat process.

So quite possible see you in just a minute.

289. Sending a User Into the OAuth Flow

In the last video we wired up the API library to our project.

We then loaded in some additional code to the library and then we initialized the authentication client

with our client id right here.

And we asked for a scope of e-mail.

Now in this video I want to show you some documentation around this library and help you understand

how to interact with it in general.

So quickly Greg you're this is kind of a long link to the documentation for this API client library

so you can either copy that link into your browser or you can just do a google search for API documentation.

I'll do the Google search just to make this little bit easier for you to find.

So I can open up a new tab and search for the API documentation and then I should see a first link of

something like.

Developers start Google dot com API client library blah blah blah.

So I'm going to go there.

We'll take a look at some of the different methods and classes available on this library.

Now of course if you want to you can also look at the guides or samples.

It's totally up to you but frankly if you look at the documentation that's going to give you a pretty

clear answer on how we interact with this library.

All right so on this right hand nav I'm going to find the authentication section right there and then

I'll click on it.

We'll take a look at some of the different methods that are available to us.

OK.

So authentication section we can call the API off to get off instance when we call that method is going

to return a google off object.

This Google Earth Object has a ton of different functions signed assigned to it that allow us to figure

out whether or not the user is signed in Currently we can initiate the flow and we can also use that

to sign that user out.

Remember when I told you that this client side of the flow is really easy to work with it's basically

all because of the methods that you see right here.

It's just really easy to figure out if the user is signed in to a event listener right here to figure

out any time that the user does sign in.

We can initiate the flow and all that kind of good stuff all through this library.

Now let's flip back over to our consul inside the browser and we'll try working with this thing a little

bit and just try calling a couple of of these different functions and seeing how they work.

All right so I'm going to flip back over.

I've got my counsel open right here.

Now the first thing I want to do is get a reference to that Auth. instance object.

So I'm going to say Konst auth equals G API.

Off to get off instance.

So now I should be able to reference off and see a object like this appear.

Now when you look at this object right you're going to see a couple of different methods attached to

it that appear to be coming from the documentation we were just looking at or example I see a sign in

method right there and a current user method right there.

And so you're going to see both those lists inside the documentation or example here is the sign in

method and I'm sure we could scroll around and find some the others on here as well but you'll also

notice that there are some of these very strange key value pairs inside if you're with like some randomly

generated keys like capital BT or FDA and those are all methods.

So all these randomly generated keys that you see are essentially private methods that are only used

internally by this library and there is zero reason for us to ever try to call any of these different

functions.

They are essentially functions that are built in here for the internal operation of this library.

You and I are only ever going to reference properties or methods inside this Google API library with

very plainly defined names such as is signed in or sign in or sign out.

And so on OK.

So with that in mind let's try now triggering the flow for the user manually.

So rather than clicking on any button or anything like that we're going to just try to manually use

this object right here to get the user to sign it.

So to do so basically all we do is call that sign in method.

All right so I'm going to call off dot sign in like so and when I do so you're going to immediately

see a pop up window appear right here.

You can then select when you get your different Google accounts.

I've got a couple so I'm going to select one of these once and that's going to essentially sign me in.

Now I've already signed in under this project before so I've already granted access to my profile to

the project we've just created.

But you might get a little question saying something like hey are you sure that you want to allow me

to get access to your e-mail address or something like that.

You also sometimes might not see any pop up at all.

So if you don't see any pop up break like that totally fine.

In order to figure out whether or not you just successfully signed in we can again use this off object.

So one of the properties on here one of the methods is is signed in right there so we can also go and

check the documentation right here you'll see that we can call Google off.

Dot is signed in get and that's going to return either a boolean true or false if the user is signed

in or signed out.

So now that I have signed in I'm going to reference off dot is signed in get and then I get a true response

right here and that tells me that I am currently signed into Google via US.

So in theory if we had asked for any other scopes around this user such as the ability to modify their

email or their Google Drive files we could now use this library to modify those files or those emails.

But as we said earlier we're not going to actually be doing a lot of that stuff.

We really just want to have the user to be able to sign in to our application and that's pretty much

it.

OK.

Now that we understand how to generally work with this API library let's take a quick pause.

When we come back the next section we're going to make sure that any time we render this Google off

to the screen we try to show a button that the user can click to then sign in or eventually sign out.

So quick pause and I'll see you in just a minute.

---
## [daid/LADXR](https://github.com/daid/LADXR)@[2c61c25688...](https://github.com/daid/LADXR/commit/2c61c256884ad353a0143241cff336e2a42d702d)
#### Wednesday 2020-07-08 05:24:28 by dragonc0

Introducing hell logic + fixes (#9)

* hell logic (minus pit buffers)

Fix d3 raised blocks chests as one ways for glitch logic
d3 glitched:  Add flock clip / dodongo skip for logical boots chest access
d4: add attack req for sidescroller key
d4: remove bracelet from flippers chest requirements since you can speed through the room + easy to get back if you fail with s+q
d5 tablet chest add attack req
d5: write out logic for stalfos 4 for glitched/hell
d7 hard: include weapons for evil eagle to 3 cycle, avoiding the feather attack. Also add bow to hard as a weapon with shield
d7 glitched: add off screen kill as options and bomb dropping on screen barrier
d8: add passage from up_left to bottom left into logic
d8: add passage from cueball staircase to upleft in logic one way, adjust logic to allow flexibility in glitched/hell
overworld/init: move dungeon requirements from init to overworld to allow flexibility for glitched/hell
hard: add wall clip into d2 entrance
Hell: Too much to account for, see comments

* pit buffer logic glitched/hell + combine ghost hut beach area

Finish up all the pit buffer logic that was seperately discussed:
glitched: d1 miniboss access from hell moved to glitched
hell: d3 boots bonk across pits to nightmare key
hell: d4 right side crossroads needs boots + hookshot to get across center
glitched: d5 all 4 gaps to chests are crossible with single pit buffers (apart from nightmare key)
hell: d5 all 4 gaps to chests are crossible with boots bonk pit buffers
glitched: d8 sparks chest obtainable with pit buffer (req are dummy to fill in the blank)
glitched: fix heart piece of shame requiring graveyard access to bomb trigger
glitched: pit buffer to heart piece of shame from graveyard area (north)
glitched: pit buffer across 3 gaps in front of kanalet with feather (hell: boots)
glitched: enter richard's maze from the north area with a pit buffer
glitched: get through boots crystal cave to mountains with feather with a pit buffer to access chest and rightmost exit
glitched: get across mountain bridges with boots and feather and a pit buffer (hell: either boots or feather)
glitched: access to d7 area through pit caves with 2 pit buffers, no further requirements
hell: add access to tail key chest with hookshot spam across pit
hell: early rooster skip pit buffer strat with boots + feather

* keys d3/d8 + small hard glitch logic d8

8 keys for d3 crossroad non right doors, because 7 keyblocks can be opened without opening the unlocking door
6 keys for d8 nightmare key, can be left last. Technically same for blaino staircase but put 5 for now to allow vanilla
hard logic: kill vire with powder or bombs
hell logic: boots bonk through blaino 2d section with boots without feather

* Hell flavor text

* Final cleanup before PR

fix villa skip bush breaking requirements (bush over pit can not be broken with power bracelet)
Clean up spaces and add comment for dungeon entrances req

---
## [petre-symfony/modern-react-udemy](https://github.com/petre-symfony/modern-react-udemy)@[3218558f3b...](https://github.com/petre-symfony/modern-react-udemy/commit/3218558f3baf05fa30d719069ee1c912240f97f6)
#### Wednesday 2020-07-08 06:35:43 by petrero

294. Redux Architecture Design(Section 21: Handling Authentication with React)

In the last video we implemented these two callbacks of on sign in and on sign out we made sure that

we called both those anytime the user clicked on either the sign out button or the sign in button right

here.

Now at the end of the last video I was looking at both these callback methods we just put together and

I realized that the naming of them is really unclear.

They're named on sign in and on sign out.

I don't know about you but when I see the term on seinen it makes me think that the user just successfully

signed in.

But that is not the intent of this cold act function right here on CNN is supposed to be called when

the user is attempting to first sign it.

And so in order to make that a little bit more clear I think that we should probably change the name

of both these event handlers.

So I don't change on SIGN INTO on sign in click and on sign out to on sign out.

Click.

So the idea here is that this name is a little bit more descriptive.

This is a function that is going to be called when the sign in button is clicked.

There is no functional change here.

Again it's just to communicate the functionality to other engineers who might work on our project.

Now since we updated these event handler names we need to make sure that we update the references down

in both the buttons as well.

So I'm going to change this to on sign out click and on sign in.

Click Like so OK.

So now in this video we're going to continue by talking about how this component our Google component

is going to play around with redux because we have not yet integrated redux into our application so

I'm going to show you two different possible ways in which we might integrate this Google authentication

with redux.

All right.

So here's the first way.

The first way that I'm showing you right here is essentially going to leave our Google off component

for the most part untouched.

Now this way that I'm showing you right here is not closely following the conventions of redux.

So I would say that if we wanted to 100 percent follow redux conventions this might not be the best

approach.

The reason we're going to take this approach right here is that at the end of this project you're going

to end up with a single component.

This Google component that shows you the entire process with Google from start to finish and that's

what I really want you to have.

I want you to have a component that shows you from start to finish how to set up Google off.

So even though this is not super optimal it's still going to leave you with a single reference for hey

here's how.

Here is how it works.

OK.

So let's walk to this flow and I'll show you an alternate flow that more closely follows redux conventions.

All right.

So inside of our component we've got on signing click and on sign out click whenever we call those We're

going to essentially be accessing the off to instance and that's going to start either the sign in flow

or the sign outflow.

Either way this library is going to eventually call our on of change inside of our class or inside of

our Google Earth component in order to integrate redux into this flow.

We're going to make sure that any time that on off change is called we call some appropriate action

creator.

So either an action creator called something like sign in or something called Sign out.

Now these two action creators right here are going to be called any time that the user successfully

signs in or successfully signs out.

So remember just a moment ago I had said oh yeah the name on sign in or on sign out was kind of unclear

because it wasn't clear if that was the user completing the sign in process or starting the sign in

process.

So these action creators their intent is to be called once the user has successfully signed in or successfully

signed out.

So when we call this action creators they will return in action.

That's going to show up inside of a new reducer that's going to be called something like our reducer.

This author reducers probably going to be an object or something like that that is going to hold a simple

boolean value that reflects whether or not the user is currently signed in or signed out.

Now you might be kind of curious why are we going to reflect whether the user is signed in or signed

out inside of a redux store.

Because we are already recording that inside of our Google off component.

Well the reason for this is simple.

Right now only our Google component knows whether the user is signed in or signed out.

That is really inconvenient for a lot of things that we want to eventually do inside of application.

Eventually we are going to have entire screens and different components that are going to function very

differently depending upon whether the user is signed in or signed out.

And so we need to make sure that we have the facts of whether the user is signed in or signed out in

some very centrally accessible location inside of our app.

Having that inside this component is not centrally accessible.

It would be very challenging for other components to somehow reach into this component and figure out

if that user is signed in or signed out.

So rather than leaving the state of whether the user is signed in or signed out inside this component

alone we're going to instead move that to our retail store.

So the redux store is going to have a boolean flag inside of it either true or false or no.

If we don't know if the user is signed in at any given time that's going to reflect whether that user

is signed in or signed out.

This is going to lead to some kind of weird things.

However I want you to know that right now we don't want to reflect whether the user is signed in in

multiple locations.

We really want to reflect whether they are signed in or signed out and only one spot inside of our app.

And so we're going to make that the redux store but then the side effect of that is that our Google

off component needs to know whether to show the sign or the sign out button.

And it only knows which one to show depending upon whether or not the user is signed in or signed out.

So we're going to make sure that the redux store communicates whether the user is signed in or signed

out as a prop Drew that map stage props function down to google off.

So the reason that I say that that this is kind of awkward is that right now this component has component

level state that says whether or not the user is signed in.

And so I'm now telling you that essentially we're going to take this little piece right here or this

little piece of state that says whether or not the user is signed in and move it into the reducer and

then go through a ton of like you know all the map state to props all the connect function all that

nasty stuff just to get this simple boolean or no value back into the component.

And so that's what I find is kind of awkward.

We're going to remove some piece of data that is already into the component into some other location

that is way harder to get access to just to get it back inside the component anyways.

Now again the reason that we are doing this is to make sure that other components can very easily read

this data as well.

Nonetheless it will feel a little bit awkward when it comes back to refactoring the Google off component.

OK.

So that's kind of my spiel around how we're going to do some of the redux design around this component.

Now I want to show you an alternate way of designing our story here in designing the red oxide the application.

Now this other way I'm going to show you like I said is following redux conventions a little bit more

closely but it's also going to spread a lot of our authentication logic out all over our application.

And so if you want to reference this Google stuff in the future it would be a lot harder to figure out

the entire flow if you use this other approach like so

OK.

So in this approach the general idea is that we want to have our action creators always responsible

for changing the state of our application at present with this flow.

We are Google off composed right here is responsible for changing the state of our app.

Like truthfully it really is because this component is accessing the API to object right here.

And this object right here kind of is a part of state of our application.

So it's not really best practice to have a component manage state like that.

But again we're going to take that approach instead it would be a little bit better approach to have

our action creators manage access to that API object instead.

So in this approach we would still have a Google off component and it would still have some callback

functions like on sign and click or on sign click.

Anytime someone invokes one of those callback functions we would call inappropriate action creator something

named like try sign in or try sign out.

Now the reason I named these Try sign in and try sign out is to make sure that it's clear that these

are going to attempt to sign the user in or attempt to sign the user out.

Is the start or the beginning of the authentication process.

So these action creators would essentially called this API auth to object right here.

And then once the user is either signed in or signed out successfully the API object is still going

to call some callback function called something like change off.

And this would also be an action creator.

Change Auth. right here would be essentially equivalent to our current onchange auth function right

here.

So any time that the user successfully signs in or signs out change Auth. would be called that would

dispatch an action that would update our piece of state and then just before as in the last diagram

our redux store would communicate whether or not the user is signed in or signed out through Mount St.

to prop's down to our Google off component okay.

Like I said this is a alternate approach that would follow conventions of redux a little bit more closely

because it is blocking access to the API object right here behind our action creators at the end of

the day it's really not a big difference at all.

I just wanted you to be aware that we could have taken this alternate approach and probably done just

as well as what we're doing.

OK.

So now that we understand the general idea here let's take a quick pause.

When we come back the next video we're going to start wiring redux up to our project and implementing

these action creators and some 3DO as well.

So quick break and I'll see you in just a minute.

---
## [petre-symfony/modern-react-udemy](https://github.com/petre-symfony/modern-react-udemy)@[b9ab3e3cfd...](https://github.com/petre-symfony/modern-react-udemy/commit/b9ab3e3cfd1f746f1dd3ace34678f8d2c9f39c58)
#### Wednesday 2020-07-08 06:35:43 by petrero

293. On-Demand Sign In and Sign Out(Section 21: Handling Authentication with React)

Blessing we do inside of render off button is make sure that both button has a click event handler to

either sign the user in or sign them out when appropriate.

So I want to make two additional helper methods on my class right underneath on off change.

I'm going to add in on sign in and I'm going to make this an arrow function because it is going to be

a callback and I'll add an on sign out and this will be a arrow function as well.

So then in each of these We're going to want to access our auth instance which is assigned to this start

off.

Now we want to call either the sign in or the sign out method on either one OK so on on sign in right

here I'm going to call this dot off dot.

Sign in.

And then when I try to sign out I want to call this dot dot sign out like so.

Now one thing I want to point out here we don't really have to make these helper methods.

We could have just passed the sign in and sign out methods directly to these two buttons that we have

right here creating the two helper methods is a little bit of extra work.

However it also would make this component a lot more clear to other engineers in the future if they

ever took a look at what was going on inside this thing.

So personally I kind of like defining helper methods just because they helped describe what is going

on inside of a component.

But again it's totally up to you.

OK so now we need to wire up these click event handlers.

So on the sign out button right here I'm going to add a On Click event handler and each time that someone

clicks this thing I'm going to call this dot on sign out.

And then on the second button all do an on click and I'll do this start on sign in.

Now one quick thing to keep in mind dear we do not want to put on parentheses on either of these methods.

If you put parentheses on there then that means that that method is going to be called the instant this

component is rendered to the screen which is probably not the behavior that you want at all.

So make sure that you do not have parentheses after either of those method names.

All right.

So will now save this and then we'll finally do a quick test inside of our browser.

OK.

So I see signing with Google.

So I'm going to click that I get my pop up right here I'll select an account or get kicked back over

to my application and the button changes to say sign out and then next I'll try clicking sign out and

I instantly get signed out and the button goes back to sign it with Google.

That's pretty much it.

Not that bad.

All right.

So this looks fantastic.

We've got a single Rehab component that encompasses everything having to do with Google authentication

inside of our application.

So we are going to use redux inside this up so might be a bit curious whether or not it is best practice

to do all this kind of business logic looking stuff inside of a rock component.

Well I do have some thoughts about that.

So let's take a pause right here.

When we come back the next section we're going to start laying out some the redux design of our application

and talk about exactly how authentication is going to work into the redux side of our app.

So quick pause and I'll see you in just a minute.

---
## [petre-symfony/modern-react-udemy](https://github.com/petre-symfony/modern-react-udemy)@[2ea6c899d5...](https://github.com/petre-symfony/modern-react-udemy/commit/2ea6c899d5a7ecee410b83aa2508cf3f93d83213)
#### Wednesday 2020-07-08 06:35:43 by petrero

291.1. Updating Auth State(Section 21: Handling Authentication with React)

We've now wired up our Google off component to print out whether or not the user is currently aloft

through our application but the only issue here is that if we attempt to sign in or sign out on the

fly like while the user is visiting the application the text does not update.

So in this video I want to figure out how to fix that.

The first thing I want to show you is another method that is tucked or hidden away on that object.

So at my console I going reference GAAP dot off to get off instance at just a moment ago in the last

video you had seen that we got reference to this start off dot is signed in and then we get to figure

out whether or not the user is actually signed in.

So let's try running that again over at her console so I can do that is signed in and then get.

Like so in this case I am signed in.

So I see you right here.

Now I want to inspect.

This is signed in objects you're a little bit more closely you know we could reference the documentation

to figure out what different methods are available on this site in property right here.

But this is actually a pretty good learning opportunity for javascript in general so I want to show

you something kind of interesting about this object.

It's going to do the API to get off instance that is signed in by itself without any parentheses or

anything like that.

So when I reference that object I see a print up of an object right here.

And just as before I see a couple of very mysteriously named properties on it.

So again these are private functions that you and I are not supposed to call but very interestingly

and this is the kind of javascript interesting part here.

You'll notice that there appears to not be any get function assigned to this object but just two seconds

ago we were able to call some get function.

So where is that function actually defined.

Well if you've ever been curious I'm sure anytime you can log an object inside your browser you've always

seen this underscore underscore produ property right here.

And I'm sure you've always been kind of curious what the heck that thing was.

So this is a little bit behind the scenes stuff.

Essentially this underscore underscore produ reference right.

There is a reference to this object's prototype property.

Now if you study javascript in depth you will know that prototypes are how javascript does inheritance

between different so-called classes.

Because remember in javascript we don't actually have classes.

Instead we have prototypes internally.

This API library uses inheritance all over the place for assembling all these different functions that

we are making use of and all these different objects that we're making use of.

So the actual get function that we care about right there is actually available through the prototype

of this object.

And again this underscore underscore protip property is a reference to the prototype of this object.

So if I expand this you're going to see that the get function that we just called is actually tucked

away on the prototype of the is signed in object.

Now again that is just a little kind of interesting thing.

I thought you might be interested in more relevant to the problem at hand and figuring out how to update

our Hetter appear text any time the user signs and or signs out.

You'll notice that there's also a method on this prototype called listen.

So this is a method that we can pass a callback function to.

If we pass a callback function to listen it will be invoked any time that users on authentication status

is changed.

And so we can pass a callback to that thing and then maybe call set state or something like that inside

there and then we could somehow update the text inside the header.

Any time these are signs in or signs out.

So let's try wiring that up right now.

Back inside my code editor I'm going to find the component did mount lifecycle method.

Here's the then statement where we initially set our states with the current value of is signed in.

So immediately after that I'm going to set up a little event listener.

So I'll say get a reference to that thought ject is signed in.

And then I will call the listen function that we just spoke about and to the thing I'm going to pass

a callback function I'm going to call it this dot on off change.

So we don't have a function with that name or a method on this class just yet.

So I going to add it as an additional method underneath the component did mount.

So I will say on off change

and because this is a callback function I'm going to set it up as a ero functions that its context is

bound to my component.

So then inside of your dysfunction right here is going to be called any time that users authentication

status changes.

So instead of you're probably going to want to update our state and update the state which whether or

not the user is currently signed in so inside of you're all called this set states all update is signed

in property on my state object and for the value of that I'm just going to reach back into the library

and get the users current authentication status just as we did before wifi is signed in.

Get all say this off.

Remember that is our reference to the thought ject that is signed in.

Get like so

I guess that's definitely not bad.

So now in theory if we flip back over to our application we can do a quick refresh.

We're still going to see the text appropriately appear for either we are signed in or we are not.

But now any time that we sign out or sign in we should see some updated text right there even if we

do not refresh the page.

So I'm going to try manually signing out of my library right now so I'll say gee API ought to get instance

dot sign out like so.

If you are currently signed out you could do sign in instead to go to the auth process.

But we're going to do sign out right now.

It's going to call sign out and then you'll notice that the text appears says immediately.

I am not signed in and now we can get that to flip back to being signed in by doing a same call but

for sign in instead.

So when we do that we'll go through the flow again.

It's all select my account and then I see the text appear automatically update to reflect the fact that

I now signed it perfect.

So we now have the ability to date our authentication state on the fly.

---
## [petre-symfony/modern-react-udemy](https://github.com/petre-symfony/modern-react-udemy)@[671c682ca3...](https://github.com/petre-symfony/modern-react-udemy/commit/671c682ca3a13fd7341bb357faadb502ca40e115)
#### Wednesday 2020-07-08 06:35:43 by petrero

290.1. Rendering Authentication Status(Section 21: Handling Authentication with React)

In the last video we played around with the API library a little bit more inside the browser console.

We saw that we can call that get off instance method.

And anytime that we call that it's going to give us a object back that has a ton of different functions

assigned to it that we can use to essentially manipulate the user's authentication status.

So now in this video we're going to continue developing our Google Earth class right here.

Let me set up a couple of quick goals for what we're going to try to do.

All right.

So inside of my component or the Google off component I want to try to get a reference to that off object

after it is initialized.

Now when I say object right here I'm talking about how just in the last video we were able to say API

to get off instance when we call that this is the author object I'm talking about.

So this is the thing that has all those different methods assigned to it that we can use to manipulate

the user's authentication status or even figure out if they are currently signed in.

So we're going to get a reference to that object after we initialize the library.

Then after that we're going to attempt to figure out whether or not the user is currently signed in.

Remember in the last video we went through the authentication flow.

So right now in theory we are currently a lot with Google inside of our application.

So I want to figure out whether or not the user using our application is signed in.

And then once we figure that out I want to somehow print out that authentication status on the screen.

It's just a very quick little goal here to make sure that we understand the basics of Google both in

how to interact with this library.

Remember right now we're not going to worry about redux at all.

I just want to get this component up and running by itself.

OK.

So back inside of my code editor I'm going to find my google off class.

So remember when we loaded up that additional library right here we had to pass in a callback function

that was invoked after this additional module inside the library was success successfully loaded up

in a very similar fashion.

When we call client Dom init right here that executes an asynchronous operation or an asynchronous network

request over to Google's API server in order to initialize our client.

So we want to get some type of callback function or some type of notice for when that initialization

set up is all done.

So to do so we're going to chain on a then statement right here.

All right let me tell you why we are doing that.

When we called Load up here load only allows us to get a signal or a notification of when the loading

process is complete bypassing in a callback function.

But when we call init we do not have to use a callback function when we called in it it returns a promise

a promise is an object that will give us a little tap on the shoulder so to speak after this client

library has been successfully initialized.

So by chaining on this.

Then steepen right here and passing in an Aero function.

This aero function is going to be automatically invoked after a library has successfully initialized

itself.

So inside of here we can write some amount of code that will be only executed once our entire API library

is ready to go.

So it's at this point right here that we can start to figure out whether or not the user is currently

signed in and then attempt to print out that status on the screen.

So inside if you're going to first begin by getting a reference to that off object and saving a reference

to it on my component class.

So I'm going to say this dot off equals window dot G API.

Off to get off instance.

So now after running this code right here inside of any other function inside my class I can reference

this dot off and that will give me a reference to that Auth. instance that I can use to sign the user

in or sign them out or get the users current on the nation status.

Because remember our goal right now is to somehow figure out whether or not the user is signed in and

then print out that authentication status on the screen.

So keep in mind that when this component or this method right here gets called our component has already

been rendered to the screen.

So now if we want to essentially update the text or what content this component shows we need to somehow

get the component to the render.

So we're going to be making use of component level state here.

---
## [petre-symfony/modern-react-udemy](https://github.com/petre-symfony/modern-react-udemy)@[7550a32466...](https://github.com/petre-symfony/modern-react-udemy/commit/7550a324662f0b7217a1a9a4adaffe827ca2bd52)
#### Wednesday 2020-07-08 07:48:51 by petrero

298. Handling Auth Status Through Redux(Section 21: Handling Authentication with React)

We've now got a producer put together and we need to make sure that we get that off piece of states

back into our Google component.

Now remember this is the part of this retractor or introducing redux that gets to be a little bit kind

of awkward or confusing.

We already had our Google off component wired up to have component level state inside of it.

And so the component itself knew whether or not the user was signed in.

So we've now Accenture essentially extracted that information to a redux store.

And so now we need to pipe that information back into the component that was already containing that

data.

And so I know it feels a little bit awkward to do this but this is the correct way to do it.

So I'm going to open up my components directory and find that Google file and inside of here we're going

to go down to the very bottom and add in a map state to prop's function so right above my export default

statement.

I'll put in Konst map state to prop's So that will be called it's my state object.

And then inside if you're going to return an object with a property is signed in that's going to have

state DOT DOT is signed in like so

it's now the value of is signed in is going to be either Null true or false just as the state value

of is signed in.

Inside of your Was value added value of before.

So now we're going to go through this component and do a pretty good refactor to update.

Yeah a couple of different things inside of your.

And make sure that we're not making use of component level state anymore.

So first off inside of my class at the very top on which removed the state initialization.

Next up inside the then statement right here.

I need to make sure where we need to make sure that we dispatch some initial action when we finish initializing

our library to indicate whether or not the user is actually signed in.

Right now we are immediately calling set state.

So essentially we want to call either sign in or sign out depending upon whether or not the user is

signed in now to do so.

We could either write out some if statement like this right here inside that door then what.

Another way that we could write this to reuse a little bit of code is to just call on or change directly

with whether or not the user is signed in.

So we can call on all change will pass and whether or not the user signed in.

And then this function is going to call the appropriate action creator member.

This is all code that is going to be running at initialization.

So right when this library first boots up.

All right so we went to remove the set state and I'm going to instead call this start on off change

and I'm going to pass in the users current authentication status so I'll say this spot on we're going

to stuff off.

Dot is signed in Dot get like so.

So now when we finished initializing our library we're going to assign the author instance to this start

off well then immediately update our state inside of our redux store and then we will basically sit

around and wait for that authentication status to change at some point in the future.

All right cool so I think there's probably just one other thing we have to change.

So down inside of render off button we are currently looking at state is signed in.

So we no longer have a state object inside of here.

So rather than referencing state we're just going update that to process because that is where the is

signed in property is now going to be coming from.

So a data inside the if statement I'll update it in the is it else.

If right here so this stop Propst is signed in.

And I think that's about it.

Inside this file I can do one quick search and search for state and make sure I don't have any other

references to state besides inside the map stage props function.

Ok I think I'm good to go.

So I'm going to save this and we'll flip on over to our browser and do a test.

All right.

So I want you to know that as you go to this test right here is entirely possible that we might have

made a typo or a mistake at some point.

So if you see any error message I would highly encourage you to take a look at the error message you

got and try to figure out exactly you know what is going wrong here.

Now I'm already getting a warning message right here.

A classic mistake that I personally make all the time.

I define that state to props at the bottom of the file and I never actually passed it into K'NEX so

I'll make sure that I do that right now.

Like so OK it's now going to flip back over.

And now I should be able to click on the sign in button I'll see the pop up appear.

That's good.

I'll select an account.

And then I see the button flip back over to sign out.

Now I can refresh the page.

I still see it say sign out and when it doesn't say sign out when the page is first initialising I don't

see any button there at all which is definitely good.

Now Asheville The click on sign out and it's going to go back to sign in with Google.

Now Asheville to refresh again and still sees sign it with Google.

All right that's it looks perfect to me.

So again if you saw anything that didn't not quite go correct here that's totally fine.

First off check to see if you have any error messages.

The other thing that might be going wrong is something that we're going to talk about in this next video.

So if it feels like you are clicking that button but nothing is actually happening then what's the next

video.

Because we're going to go over a little refactor to our reducer that might fix an issue that you have.

So quick pause and we'll take a look at some little retractor that we're going to do in the next video.

---
## [petre-symfony/modern-react-udemy](https://github.com/petre-symfony/modern-react-udemy)@[957a38cc32...](https://github.com/petre-symfony/modern-react-udemy/commit/957a38cc32ab009d8add21e7dc1dbf58942a6183)
#### Wednesday 2020-07-08 07:48:51 by petrero

296. Connecting Auth with Action Creators(Section 21: Handling Authentication with React)

In the section we're going to continue working on the redux side of our application by setting up some

action creators and then wiring them up to our Google component.

So inside of my actions directory I'm going to open up my index file.

So inside of here we want to eventually have two action creators one called Sign in and one called sign

out these are going to be extremely straightforward action creators.

We're only going to call them after we have successfully either logged user in or logged the user out

through the API library.

So inside of my index as file I'm going to define a action creator called Sign in and inside this thing

I'm going to return an object and it will have a type of sign in.

And that's pretty much it.

So we're going to eventually have a Auth. reducer or something with that particular name or something

similar to it.

Anytime that it sees a action of type sign in it will probably have some internal boolean flag that

updates the sign in status to true.

That's pretty much it.

So we'll also have a nother action creator called sign out and this one will basically have the exact

same opposite effect so all return an object with that type of sign outs.

And now any time that our author reduces that we'll eventually put together CS that action.

It's going to flip that boolean flag of whether or not these are signed into false.

So pretty straightforward on the creator side let's don't hook these up to our Google off component

using the reactor redux library.

So I'm going to flip back over to the Google file at the top.

I'm going to import connect and I'll also import my two action creators of sign in and sign out from

up one directory actions like so and then we'll hook all this stuff up at the bottom of the file.

So down here at the bottom I'll find my export default.

I'm going to wrap it with the second set parentheses have a connect call.

At present we don't have a map state to prop's functional personal as the first argument and then as

the second argument I'll put an OT option is to be an object in which sign in and sign out.

All right so now inside of our component we need to make sure that once the user successfully signs

in or signs out we call the appropriate action creator.

So I'm going to find my on off change callback.

Remember we wired this thing up to the Google API library with the is signed entlassen colorant year.

So this function is going to be called Anytime that our authentication status changes according to the

Google API.

Now at present we are getting whether or not the user is signed in from a call to this dot dot is signed

in get.

In reality I didn't mention this at the time but this callback function right here actually gets called

with a boolean argument of either true or false to indicate whether or not the user is signed in.

So we don't actually have to reach back into the odd instance and call the is signed in get.

We can instead just receive it as an argument.

So I'm going to receive that as an argument called is signed in

next inside this function.

We no longer want to have any component level state that is keeping track of whether or not the user

is signed in.

So I'm going to remove the entire set state call and I'll replace it with an if statement.

So I'll say if is signed in is equal to true and we want to call our action creator this Propst not

sign in otherwise.

So L's case will say this stock props that sign out like so and that's pretty much it right there.

All right.

So let's flip back over your browser.

I want to very quickly just test out this code.

Now we're not going to see any impact or any change on here.

In fact we're not even see any updates the button any more because we are no longer updating the state

inside of our component.

Nonetheless I just want to make sure that we don't have any error messages or anything like that when

we change our authentication state.

So back inside the browser I will refresh the page and then attempt to sign an so I click that button

and then we don't see anything occur again that is totally fine if you have the sign out button up there

right now because you are signed.

Or if you sign up on because you are signed in.

You can click the sign out button.

And again you just don't want to see an error message.

That's all we're checking for right now.

Now I don't see any error message which means we are doing pretty well.

So we're going to take a quick pause right here in the next video we're going to start working on in

3DO sir.

That is going to record whether or not our user is signed in.

So quick break and I'll see you in just a minute.

---
## [TerryCavanagh/VVVVVV](https://github.com/TerryCavanagh/VVVVVV)@[09e15db878...](https://github.com/TerryCavanagh/VVVVVV/commit/09e15db87875fde905d6f986269708a525d49ca8)
#### Wednesday 2020-07-08 11:18:07 by Misa

Fix Vitellary looking left for one frame in "Now Stay Close To Me..."

There's a bug in the cutscene that plays if your companion is Vitellary
in the room "Now Stay Close To Me...". The relevant gamestate is
gamestate 43, which for Vitellary calls the script `int1yellow_4`.

When Vitellary says the text box "That big... C thing! I wonder what it
does?", Terry intended for Vitellary to change his facing direction to
the left, as you can see with the command `changedir(yellow,0)` in the
original scripting. `changedir()` just changes the `dir` attribute of an
entity, and a `dir` of 0 means face left and a `dir` of 1 means face
right.

Then when Vitellary says "Maybe we should take it back to the ship to
study it?", Terry intended for him to face rightwards once again, as
indicated by the `changedir(yellow,1)` command.

Unfortunately, what happens instead is that when Vitellary says the
first text box ("That big... C thing! I wonder what it does?"), he turns
left for precisely one frame, and then afterwards goes back to facing
right. Then the second text box comes around, but he's already facing
right. How come?

Well, the problem here is that Vitellary's AI for "follow Viridian" is
overriding his `dir` attribute. Vitellary's AI says "get close to
Viridian", but Vitellary is already close enough to them that he stays
put. However, he still turns to face them as part of that AI.

To fix that, we need to put him in the AI mode that specifically says to
face left, with the command `changeai(yellow,faceleft)`. That way, he no
longer has the AI mode of following Viridian, and he will actually look
left for the intended duration instead of only looking left for one
frame.

But then we have another problem. When the cutscene ends, Vitellary no
longer follows Viridian. I mean it makes sense - we just placed him in
"only face left" mode, not "follow Viridian" mode! And this is not
merely a visual problem, because Vitellary is a supercrewmate and the
game won't let the player walk off the screen if Vitellary isn't
offscreen yet.

To fix THAT issue, we'll need to put Vitellary back in "follow Viridian"
mode. It turns out that the `changeai()` command was more intended for
scripting crewmates (entity type 12), NOT supercrewmates (entity type
14). As such, the command assumes that you'll want state numbers that
apply to entity type 12, such as 10, 11, 12, 13, and 14, even though the
only one that applies to entity type 14 is state 0, and every other
state number just makes it so that the entity doesn't move an inch. And
specifying faceleft/faceright is just state number 17.

Luckily, we can still pass the raw state number to `changeai()`, we
don't have to use its intended names. So I do a `changeai(yellow,0)` to
set Vitellary's state number back to 0 when it comes time to make him
face right again.

As a bonus, I added comments to the changed lines. This is a semi-obtuse
method of scripting, so it's always good to clarify.

---
## [mrakgr/The-Spiral-Language](https://github.com/mrakgr/The-Spiral-Language)@[b155b72a94...](https://github.com/mrakgr/The-Spiral-Language/commit/b155b72a94b092b4b58a65be4d27371eb338966c)
#### Wednesday 2020-07-08 11:25:38 by Marko Grdinić

"9:25am. I am up. Today it is parser time, but let me do my chilling first.

10:25am. Let me start.

I wasted enough time in the morning to satisfy me.

10:30am. Right now I am looking at `Parsing.fs` and the first thing I will note is that it is 900 lines long. Spiral's parser is just so damn complex. The redo I did in January really spiked its complexity to uncomfortable levels. If I wasn't the one that wrote this code and got it dumped in front of me, I'd definitely be intimidated.

Right now the parser just does so many special things.

To make things worst, I am not even done with it.

I need to put in union types and nominal prototypes. I need to optimize it. I need to make it so that in patterns the union cases match.

The way it works right now is unacceptable. I need to redo it.

Since the top level is so important now, the top level will have to have its own pass.

And since the top level is made out of blocks that is where I need to start.

One issue that I haven't touched upon is how to parse `and` statements. The contents of them will depend on whether that and is a mutually recursive nominal, union, inl or let statement. Leaving the `and` bare means I can't parse the block in isolation.

How about I diverge from F#'s way of doing things?

```
let f x = ...
and inl g x = ...
and let h x = ...
```

There is no reason why I can't do it like this.

And doing it like this will allow me to do things like.

```
nominal Qwe x = ...
and union Asd = ...
```

11:05am. Had to take a short break. I've been thinking about macros during it.

```
macro Array x = @x []
```

I am going to have to put in some special tokenizer support for it. In particular it is not enough for me do the usual tokenization past the `=` sign. I am going to make it so that it expects a single whitespace past it, and `!`, `@`, `#` and going to be the lit, typevar and var operators specifically. In Spiral, macros can be both syntax and types.

Since doing this kind of indirection in the tokenizer will be difficult, I will just have macro keyword read the thing up to the rest of the line.

11:15am. Let me leave macros for later. They won't be hard to deal with and do not want to occupy myself with them now.

11:35am. I am getting lost in daydreams, but maybe it is fine. I am not realistically going to start off programming right away. Today I should be mostly getting my bearings.

11:40am.

```fs
    if is_outside then
        (
        choice [|var; parenths recurse|]
        ) d
    else
        (
        choice [|var; parenths recurse; record recurse; keyword recurse|]
        |> tapply |> pairs |> arr_depcon |> arr_funs_cons |> forall
        ) d
```

Inner and outer types are fine, but...

```fs
    if is_outer then
        (
        choice [|pat_wildcard; pat_var; pat_value; pat_record recurse; pat_keyword_unary; pat_rounds recurse|]
        |> pat_and |> pat_pair |> pat_keyword
        ) s
    else
        (
        choice [|pat_wildcard; pat_var; pat_active recurse; pat_value; pat_union recurse; pat_record recurse; pat_keyword_unary; pat_rounds recurse|]
        |> pat_type |> pat_and |> pat_pair |> pat_keyword |> pat_or |> pat_as |> pat_when
        ) s
```

This stuff with the patterns is cancer. It is so arbitrary.

You know what, forget type operators. If I allow type operators I won't be able to write...

```
inl x : i32 = 1
```

...because that `=` might be a type operator.

...Actually this stuff with the patterns here is fine. I might just want to get rid of `pat_and` in the outer level.

...And I should allow `pat_type`. Yeah, type annotation and type patterns are a real troublemaker. Actually, yeah, I have to get rid of `pat_type`.

```
let rec pattern_template is_outer is_box expr s =
```

`is_box`...

Yeah, I meant to have boxing annotations, but that will just make Spiral's code uglier and more complicated.

Let me have the ordinary `let` and `inl` and if the user wants boxing, he can just use `dyn` together with let. Or an outer `inl` and and inner `let`.

```fs
    if is_outer then
        (
        choice [|pat_wildcard; pat_var; pat_value; pat_record recurse; pat_keyword_unary; pat_rounds recurse|]
        |> pat_and |> pat_pair |> pat_keyword
        ) s
    else
        (
        choice [|pat_wildcard; pat_var; pat_active recurse; pat_value; pat_union recurse; pat_record recurse; pat_keyword_unary; pat_rounds recurse|]
        |> pat_type |> pat_and |> pat_pair |> pat_keyword |> pat_or |> pat_as |> pat_when
        ) s
```

Going back to this, I will in fact allow type patterns in the outer level. What I will do to allow this is to get rid of return type annotation in `fun`.

Ah, no wait. Now I remember why I disallowed outer type annotations...

```
inl ((f : i32) : i32) : f32 = 1
```

Because it would allow their nesting.

And if that is valid then...

```
inl f a (b : i32) : i32 = ...
```

...it would be impossible to make i32 there refer to the return of the function. Instead it would just refer to the type of `b`.

Not a good thing.

12pm.

```fs
    if is_outside then
        (
        choice [|var; parenths recurse|]
        ) d
    else
        (
        choice [|var; parenths recurse; record recurse; keyword recurse|]
        |> tapply |> pairs |> arr_depcon |> arr_funs_cons |> forall
        ) d
```

Ok, if I am going to accept the inside outside split then I should also just accept type operators.

```
    let arr_funs_cons next =
        pipe2 next (many (((arr_fun >>% Funs) <|> (arr_cons >>. assert_allowed ConstraintNotAllowed >>% Cons)) .>>. next))
```

That having said, Instead of using `=>` for constraints like in Haskell, I am going to fold constraints into foralls.

```
inl sqr forall a [number a]. (x : a) = x * x
```

Something like that.

```
inl f forall a b c [cons a] [cons b] [cons c]. ...
```

This sort of form in general. Except `forall` is too wordy for my taste and I will have the editor replace `\a` with the unicode forall at some point.

This sort of form will make it much easier to parse constraints.

```fs
    if is_outside then
        (
        choice [|var; parenths recurse|]
        ) d
    else
        (
        choice [|var; parenths recurse; record recurse; keyword recurse|]
        |> tapply |> pairs |> arr_depcon |> arr_funs_cons |> forall
        ) d
```

Going back to this yet again, constraints will be a separate thing from type annotations. Definitely do not want them there. And I do not want them outside of a forall because I might want to use the `[]` brackets for lists.

12:20pm. https://github.com/microsoft/vscode-extension-samples/issues/

Got a reply to issue 324. It seems that fading out of unused variables is done through diagnostics.

Not what I expected. It might be good to do it via semantic tokens instead.

> Users can overwrite theming rules through the editor.semanticTokenColorCustomizations setting:

```
"editor.semanticTokenColorCustomizations": {
    "[Rouge]": {
        "enabled": true,
        "rules": {
            "*.declaration": { "bold": true }
        }
    }
}
```

I am going to have to try this out. Later. Right now I am still thinking. I am really into parser design now.

12:30pm.

```fs
        | PatBoxVar x -> l x (box' (v arg)) on_succ
        | PatBoxAnnot(exp,typ) ->
            let on_succ = cp arg exp on_succ on_fail
            RawAnnotTest(true,typ,arg,on_succ,on_fail)
```

Ugh, there was all this bullshit with boxing in the v0.2 prototype.

12:35pm. Forget that.

I spent while thinking about that since 5 months ago and I am not going to do it the same way. Let me statement arguments should just be wrapped in a `dyn`.

`dyn` should not be a function anymore. Rather functions themselves should have their argument and return type as a part of their structure.

Since I will have a type segment I cannot have functions `inl id x = x`. Rather they will have to be `inl id forall a. (x : a) = x`. That `forall` will have to be there.

12:45pm. Yeah, if I need to get rid of `dyn`, the best substitute for it would be `let`. I meant to have..

```
let x = 1
inl x = 1
```

...be the same thing, but without `dyn`, I'd be better off making the first one take its place.

12:55pm. Also, I am going to be strict and have `Dynamize` throw an error if it cannot do closure convertion.

For the real segment, I am going to introduce the `Annotate` op.

Real and Top segments are going to have to have separate Core libraries.

1:05pm. I am not going to have `real` automatically open it.

With regard to patterns it is just as I said...

```
inl ~x = ...
```

I am not going to play tricks with syntax to get boxing behavior here.

If the user wants non-boxing, he should write...

```
inl map f l =
    let f = f
    ...
```

...rather than...

```
inl map ~f l = ...
```

Though even as I write this I am starting to feel less sure.

The first one is pretty ugly.

But if I allow the later, I will how to deal with `~` in patterns and such. I do not want that headache. So nevermind that.

1:20pm. Now I am thinking how I am going to deal with `real` functions in the top segment.

`real inl id x = x` should be valid syntax.

But if I pass that sort of function into the typed segment what should the type of this be?

There is no way around it - I am going to have to introduce some kind of void type. Otherwise I won't be able to do anything.

1:25pm. Enough thinking. I am way overdue for breakfast."

---
## [oibind/awesome-copycats](https://github.com/oibind/awesome-copycats)@[05aa2a6c34...](https://github.com/oibind/awesome-copycats/commit/05aa2a6c34f19bbac068f315d9eca4ad3cd39f21)
#### Wednesday 2020-07-08 15:02:43 by Aoibhinn Nic Aoidh

White it's my new obsession...

Yeah, white it's not even a question
White on the lips of your lover, cause
White is the love you discover
White as the bing on your cherry
White cause you are so very
White it's the color of passion
Because today it just goes with the fashion...

---
## [oibind/dwm](https://github.com/oibind/dwm)@[5f6a915d63...](https://github.com/oibind/dwm/commit/5f6a915d6352d39f294e95d8affa3d591e6e9a22)
#### Wednesday 2020-07-08 15:36:31 by Aoibhinn Nic Aoidh

White it's my new obsession...

Yeah, white it's not even a question
White on the lips of your lover, cause
White is the love you discovah
White as the bing on your cherry
White cause you are so very
White it's the color of passion
A-cause today it just goes with the fashion...

---
## [mrakgr/The-Spiral-Language](https://github.com/mrakgr/The-Spiral-Language)@[f31d9f73ac...](https://github.com/mrakgr/The-Spiral-Language/commit/f31d9f73aca5bd54b6b9d7dd28d1f6bc38e8499a)
#### Wednesday 2020-07-08 16:55:46 by Marko Grdinić

"2:10pm. Just a bit more and I will resume.

I've changed my mind on the `~` thing. I'll disallow it for `let` statements (right now in the prototype it actually suppresses it) but allow it `inl`. It would just be too useful not to have.

2:55pm. I've been thinking for a bit now. Let me step away from the screen. I want that thinking nap.

Right now I am thinking about foralls. I am going to allow them in type expressions after all, and on the partial evaluation side. By allow - I mean, that the partial evaluator might encounter `inl f (x : forall x. x) = x` in type annotations. But it will raise a type error on that.

Doing it any other way is too complicated.

I think the reason I had those...

```fs
    | PatVar of VarString
    | PatBoxVar of VarString
    | PatBoxAnnot of Pattern * RawTExpr
    | PatAnnot of Pattern * RawTExpr
```

...numerious complications last time regarding `dyn` and why I did not decide to allow type annotations in functions directly is because of the issues with foralls. The partial evaluator requires monomorphic types everywhere, but the typechecker does not and there is tension between the two over that.

There is one thing I am going to make a type error in the typechecker directly.

```
inl f forall a. (x : a) forall b. (y : b) = ...
```

Those nested foralls I am going to disallow. I am going to disallow a function having a forall in its range - the right side of the function arrow. Similarly since the typechecker will be stripping annotations from functions, the partial evaluator should not encounter type level foralls in practice except by accident.

...Actually...

Actually, no. I do not need to restrict the types in the range specifically. The usual universe level restrictions that I already have should be fine. Anything more than that I'll leave to the partial evaluator to raise on.

Restricting it completely would just get rid of useful functionality for no real benefit.

3:10pm. Like foralls are problem in the partial evaluator, but even if he gets a function that has a forall in its type, it is not like this is an issue unless it actually evaluates such a type. And that would only happen during closure conversion anyway.

Rest of the time I can just leave it staged, much like with regular functions.

The place it might run into illegal foralls is there, and in type patterns.

Right now I actually have the parser guarding the scope so they don't accidentally manifest there.

3:15pm. ...This is actually good. I should do this bit of typechecking during the parsing stage itself. I'll also make constraints errors. This is something I did in the prototype and did not like, but I think if I could clean up the code little, I would find it acceptable.

3:20pm. Let me just check type expressions. How do I deal with them in the partial evaluator now?

```fs
and [<ReferenceEquality>] TExpr =
    | TV of VarTag
    | TPair of TExpr * TExpr
    | TFun of TExpr * TExpr
    | TRecord of Map<KeywordTag,TExpr>
    | TKeyword of KeywordTag * TExpr []
    | TApply of TExpr * TExpr
    | TInl of TExpr * Data
    | TUnit
    | TPrim of PrimitiveType
    | TArray of TExpr
    | TModule of Map<KeywordTag, TExpr>
    | TPos of Pos<TExpr>
```

I do not have foralls which as bad idea. I do have type level `TInl` which is also a bad idea. I also do type application literally and can apply symbols to records.

All this is a bad idea. The only type level functions that should be allowed are nominal types. Taking 5 months off to study webdev and concurrency really did allow me to work out the design of the language on the side.

Back in December I really resumed work on Spiral out of the blue, so I needed time to work out the kinks.

3:35pm. Right now I am thinking how I am going to do renaming for those type level foralls in the prepass.

3:40pm. Hmmmm...yeah, even if the partial evaluator could bear having them, the prepass cannot. It is the prepass which would encounter those type annotations first.

...I could always do fake renaming. But I do not want to reason how things would work in such an eventuality. I want all variables to be valid.

3:45pm. So I think I will in fact bring in the idea that foralls can only be on the argument side in the function annotations.

...Actually, they cannot be there either. It is true that the real segment allows foralls, but it should not allow their annotations.

So the base universe level restriction should be in effect in both the prepass and the partial evaluator.

And if it is in effect in the prepass, no way will it get to the partial evaluator. I do not have to worry about it there.

4pm. No wait...if I restrict it even in the partial evaluator, that means that even though function with higher ranked arguments will be not allowed.

I keep thinking of type annotations as being erased, but that is not necessarily true. In the scheme I have in mind they would just be moved to the function annotation.

4:05pm. I have two choices here for dealing with higher ranked functions in type annotations during the prepass.

1) Restrict them entirely by raising an error. I've been looking for a sensible way to restrict the language to just prenex polymorhism for a while - this was an open problem for me, and this would in fact be a good scheme for it.

2) Stage the error until the partial evaluation stage. This is a bit similar to fake renaming, but rather than do that, or allowing foralls, I just leave a message with the location that the partial evaluator fires off instead if it ever evaluates that expression.

4:15pm. Hmmm, if I decide to go with the later, I would not actually have a need for any universe level restrictions in the language at all in the typechecker. Actually the same goes with the first thing.

Like, I could apply...

```
inl f (x : forall a. a -> a) : (forall a. a -> a) = x
inl main _ =
    inl _ = f ~id
    0
```

4:20pm. But that is just the identity.

```
inl main _ =
    inl _ = ~id `(forall a. a -> a) id
    0
```

Could I do something like this?

...No this, would be restricted if not by the parser, then in the prepass, and if staged there, the partial evaluator would raise an error.

4:30pm. Ok, regarding foralls, let me bring up all the relevant points going through my mind.

1) Parsing restriction for foralls (and contraints) in the real segment.
2) Typechecker base universe level restriction when doing applying foralls with a type.
3) The prepass forall renaming restriction.
4) The partial eval monomorphism restriction.

Obviously, I can't get rid of the last one, but getting rid of any of the first 3 would just cause the error to be deferred to the later stage.

4:35pm. If I accept the third restriction then I've restricted higher ranked types almost completely from the language. It will be impossible to have functions that accept other higher ranked functions as an argument and the language will have a rank-1 type system.

4:40pm. Which might be fine. I honestly think higher ranked type are a vanity.

If it was the 2017 or 2018 me, I'd take all the advantages that I can get...

4:45pm. But honestly, I think I am fine leaving rank-2 polymorphism out. This subtle thing is something I could easily add later without much issue.

I am fine with the language being nice and simple.

5pm. Unlike partial evaluation, the prepass can be done in a blockwise fashion just like typechecking. If I want unused variable detection I should do it right away. At least a part of it.

On the surface, the find reference operation and the fading out of unused vars are similar, but the first one would need to search across the entire project, while the later can just be applied to the individual blocks.

The prepass is the ideal time to do this kind of analysis.

And I do want this feature as detecting unused vars has saved me from shadowing errors plenty of times.

I think F# does it for the top level as well, but I won't bother with that...

Ah, no it does not.

Nevermind, it is fine.

5:10pm. With regard to the prepass restriction, since the typechecker can do it as well, I think I will just move it there. If I've decided on something, it would be good to do it as soon as possible.

5:10pm. Agh, now once again...

```
forall a. (forall b. b -> b) -> i32
```

Is this universe 1 or 2?

Let me load up Agda.

```agda
_ : Set₁
_ = (∀ (a : Set) → (∀ (a : Set) → (∀ (a : Set) → a → a) → a) → a) → Set
```

The first thing that greets me when I load it up is this. This was something I was wondering about back then.

So function argument restriction is not the same thing as the base universe level restriction.

5:35pm. I will keep up this intense thinking session for a while longer and then I will stop for the day.

5:40pm. Actually, I'll go against `and let ...` and `and inl ...`. I will in fact just pass the type of the previous block in the parser...

No wait, that would complicate things. Even if I did that, this would couple the blocks textually.

```
inl rec ...
and ...
and ...
```

If I changed that first one to `let` then I'd need to reparse the other 2.

It is not worth it.

5:45pm. Typing one extra word won't kill the language's elegance, but it will make my job a lot easier.

5:50pm. Right now I am thinking about macros again. I think I understand completely how to do them in the simplest possible way.

I'll implement a short parser for them directly in the tokenizer.

6pm. Ah, no wait. I can do the parser easily enough, but how will I deal with type variables in ops?

Ok, it is true - they won't be a problem in the macros I have in mind as they will be directly be wrapped by the parser, but if I were contructing them in the partial evaluator directly, how would that go?

Well, I suppose I could contruct a macro specifically for types.

```
macro TM forall x. = ~x
```

Then I could use the macro contruct to do something like...

```
macro_create
```

...No it won't go.

Forget this. I do not need the capability to do arbitrary macros.

The regular ones will suffice and those will give me no trouble at all with the scheme I have in mind.

6:10pm. My brain is still going at it.

Thanks to today's session I feel like I have a much better grasp on the language than I had before. Definitely, before I can start parsing I also need to grasp how the later stages will be using the AST it gives them.

I am not sure if I will just plan tomorrow, but I think I probably will start work on the parser itself.

6:15pm. I think this time I will in fact just start with a parser for all the top level statements and make my way from there.

I'll take care of the union type and the nominal prototype parsers right away.

Now I am thinking how to improve printing of errors. I will leave that for later.

5:30pm. There is one thing I've overlooked about the typechecker. Much like the parser, if one of the blocks has an error, it can in fact skip it over and move to the next one. It can substitute type errors for the most general type and continue working.

The difference from the parser is that if one of the previous blocks got fixed, it has to redo the work.

...I think I might want to do unused variable analysis separately from the prepass simply because it can be done regardless of the errors in the previous block.

The prepass also does inlining which makes things more difficult when it comes to incrementality.

I should consider doing the renaming separately from inlining of globals.

6:35pm. Agh, what a bother. I'll do it in due time.

I think at this point I should really just call it a day. Tomorrow, instead of brainstorming so much, I should just do what I set out to do.

The irony of higher ranked types is that I will still have to do the unification and things along those lines properly for them regardless of whether or not I decide to have them in the language. So I am not really losing much from restricting them. They will be in close reach either way should I ever need them.

Tomorrow I will start on the parser. Once I do the parser and make it a server, I will have something substantial.

Tokenization is not much, but with the parser I can try out writing real Spiral code and seeing how it feels in the editor. That will be a new experience for me.

v0.2 prototype has still really shitty parser errors that I need to figure out why they are getting lost. I'll want to deal with that before I move on to typechecking.

Also this time rather than parsing those Pos nodes, in order to make it easier for the typechecker to highlight a whole expression where the error occurs I am going to have to move to a different system. Every node is going to have to have a position this time.

6:45pm. This will complicate the partial evaluator, but whatever. I always hated dealing with those `Pos` nodes in the parser, so I will welcome this bit of hardship.

6:50pm. This time everything will be perfect. This time I will reach my goal. I will make a perfect language fit for the next generation of neuromorphic hardware.

This was my intention even back in 2017, but back then such hardware was far in the future. I closed my eyes and when I opened them, the vision I saw is closer to reality. I will not give up on it. I need to keep going as far as I can.

6:55pm. With exquisite skill and all the weight of my experience, I will deal with the parser in its fullness."

---
## [freebsd/freebsd](https://github.com/freebsd/freebsd)@[8609d6883f...](https://github.com/freebsd/freebsd/commit/8609d6883fea23576d1aba3c4cf0beee3f8f707a)
#### Wednesday 2020-07-08 18:31:29 by kevans

MFC r361798, r361800: vfs: default disallow read(2) of a directory

This MFC is in accordance with the original MFC plan outlined in the commit
message for r361798, appearing in full (with exception to metadata) below.

To summarize: this MFC only merges back the sysctl with a default disallow
policy, as in head, to ensure we hit any issues quickly but in a fashion
that end users can easily revert. Interested parties can flip the
security.bsd.allow_read_dir sysctl back to 1 to fully honor the previous
behavior of allowing read(2) of any dir, filesystem permitting.

r361798:
vfs: add restrictions to read(2) of a directory [1/2]

Historically, we've allowed read() of a directory and some filesystems will
accommodate (e.g. ufs/ffs, msdosfs). From the history department staffed by
Warner: <<EOF

pdp-7 unix seemed to allow reading directories, but they were weird, special
things there so I'm unsure (my pdp-7 assembler sucks).

1st Edition's sources are lost, mostly. The kernel allows it. The
reconstructed sources from 2nd or 3rd edition read it though.

V6 to V7 changed the filesystem format, and should have been a warning, but
reading directories weren't materially changed.

4.1b BSD introduced readdir because of UFS. UFS broke all directory reading
programs in 1983. ls, du, find, etc all had to be rewritten. readdir() and
friends were introduced here.

SysVr3 picked up readdir() in 1987 for the AT&T fork of Unix. SysVr4 updated
all the directory reading programs in 1988 because different filesystem
types were introduced.

In the 90s, these interfaces became completely ubiquitous as PDP-11s running
V7 faded from view and all the folks that initially started on V7 upgraded
to SysV. Linux never supported this (though I've not done the software
archeology to check) because it has always had a pathological diversity of
filesystems.
EOF

Disallowing read(2) on a directory has the side-effect of masking
application bugs from relying on other implementation's behavior
(e.g. Linux) of rejecting these with EISDIR across the board, but allowing
it has been a vector for at least one stack disclosure bug in the past[0].

By POSIX, this is implementation-defined whether read() handles directories
or not. Popular implementations have chosen to reject them, and this seems
sensible: the data you're reading from a directory is not structured in some
unified way across filesystem implementations like with readdir(2), so it is
impossible for applications to portably rely on this.

With this patch, we will reject most read(2) of a dirfd with EISDIR. Users
that know what they're doing can conscientiously set
bsd.security.allow_read_dir=1 to allow read(2) of directories, as it has
proven useful for debugging or recovery. A future commit will further limit
the sysctl to allow only the system root to read(2) directories, to make it
at least relatively safe to leave on for longer periods of time.

While we're adding logic pertaining to directory vnodes to vn_io_fault, an
additional assertion has also been added to ensure that we're not reaching
vn_io_fault with any write request on a directory vnode. Such request would
be a logical error in the kernel, and must be debugged rather than allowing
it to potentially silently error out.

Commented out shell aliases have been placed in root's chsrc/shrc to promote
awareness that grep may become noisy after this change, depending on your
usage.

A tentative MFC plan has been put together to try and make it as trivial as
possible to identify issues and collect reports; note that this will be
strongly re-evaluated. Tentatively, I will MFC this knob with the default as
it is in HEAD to improve our odds of actually getting reports. The future
priv(9) to further restrict the sysctl WILL NOT BE MERGED BACK, so the knob
will be a faithful reversion on stable/12. We will go into the merge
acknowledging that the sysctl default may be flipped back to restore
historical behavior at *any* point if it's warranted.

[0] https://www.freebsd.org/security/advisories/FreeBSD-SA-19:10.ufs.asc

r361800:
RELNOTES and UPDATING: Document the new policy on read(2) of dirfd

These changes have been completely flushed as of r361799; note it.

PR:		246412
Relnotes:	yes 100%

---
## [digital-asset/daml](https://github.com/digital-asset/daml)@[9a03276c89...](https://github.com/digital-asset/daml/commit/9a03276c89a8e6157df60f03cf6bf6a759648175)
#### Wednesday 2020-07-08 18:32:53 by Moritz Kiefer

Generate JS + typings to speed up dam2js

This speeds up daml2js to the point where it’s basically instant on
the GSG.

Most of this is fairly straightforward. I looked at the generated code
from typescript and the docs for declaration files and adapted things.

There is one interesting point here:

TypeScript does not generate code using ES6 modules. Using ES6 modules
works just fine in a browser in a browser but unfortunately it works
less fine in nodejs and in particular in jest. I spent some time
trying to fix it and in the end decided that this is not worth doing
since all our users have to do the same which sucks.

Therefore, the codegen uses the same hacks that typescript/babel use
to emulate modules.

The tests work almost completely but unfortunately I’m struggling to
figure out how to setup eslint on the new generated code.

changelog_begin
changelog_end

changelog_begin
changelog_end

---
## [SammyYue/UX-Projects](https://github.com/SammyYue/UX-Projects)@[18c8d3f467...](https://github.com/SammyYue/UX-Projects/commit/18c8d3f46783829ccc39d6e7feda224d0a106c07)
#### Wednesday 2020-07-08 19:55:09 by Samantha T

01_Introduction and research

Project Title *

HardWorker: stay focused and achieve goals

Write your app’s name and tagline.

HardWoker

A village-life-game version of time focused App.
Write a short paragraph describing your app. Make sure to mention what the app does and
what problem it solves.

This App is a role-playing game. Users plan tasks on a to-do-list with a period of time. When the
user runs the timer in the App, the user starts to do the task, and the game character takes care
of the garden. After the timer, the user will see the garden has plants growing. The user uses
this App more, there will be more plants growing in the garden.

Describe four specific functions that your app will do. List these ideas in order of
importance, with the first idea being the most important.

1. User can set the timer to begin focusing on doing tasks;
2. Users can plan the tasks in the to-do list in a period of time;
3. Users will get rewarded in the game by continuously staying in time focusing in the real world;
4. Users can relax by exploring the game.

List 4 potential roles that are a part of your initial user target group. Then, expand on one
of the roles with a detailed profile description of one of these potential users.

1. Mr. and Mrs. Queen try to teach their game addicted child to stay in studying.
2. Jack wants to finish his painting before the due date but he loves to goofy around.
3. Lauren is 25 years old and tries to lose weight. She has a hard time being disciplined in
exercising.
4. AJ tries to quit his smoking addiction. He wants to hold off smoking longer and longer until he
quits smoking.

Come up with 4 client/designer goals for your app design. You don't have to assign these
to a category (political, social, etc). List your goals in order of importance, with the first
goal being the most important.

1. This App encourages users to stay focused on doing things.
2. This App helps users to achieve goals.
3. This App helps users to create better habits.
4. The client makes money when users pay for hidden options in the game.

Name and briefly describe 3 existing apps that are similar to your app idea.
The similar Apps are Study Bunny, Focus Plant, Forest: Stay focused.

1. Study Bunny - gain a better mood and more money for the rabbits in the game by adding
up duration time, so the rabbit has a smiling face and uses the money to buy decorations
for the house and other places.
2. Focus Plant - have plants to grow by adding up duration time. Users can choose seeds
and grow them on a field of land.
3. Forest: Stay focused - Duration of time triggers rain to water the user’s garden. The
longer the duration of time, the bigger drop in the rain to water the garden. The plants
grow faster.

---
## [SammyYue/UX-Projects](https://github.com/SammyYue/UX-Projects)@[e5f9e78320...](https://github.com/SammyYue/UX-Projects/commit/e5f9e78320948de9b210ecb30727d0e43fcad85c)
#### Wednesday 2020-07-08 19:57:22 by Samantha T

01_RiceRoll Strategy 

RiceRoll 

Samantha Tang 

Restaurant Concept (Project Idea) -What will be your restaurant’s name and URL? 

RiceRoll 
Riceroll.com 

-Describe the type of food or drink and the related options the restaurant will serve. 

Rice rolls Customization 

● Base: White rice, Sticky rice, Brown Rice, Red rice, Purple rice 
● Meat: Barbeque Pork, Sesame Beef, Teriyaki Chicken, Salt & Pepper Turkey 
● Veggie: Saute Tofu, Roasted Onion, Lettuce, Green/Red/Yellow Bell Pepper, Spinach Leave. 
● Other: Roasted Seaweed, Mung Bean Paste, Guacamole. 
● Flavor/Sauce: Salt&Pepper, Teriyaki Sauce, Oyster Sauce, Soy Sauce, Chili Oil Sauce, Black Bean Sauce 

-Describe the country, city, and neighborhood where the restaurant and its customers will be located.

 La Mirada, California, United States Delivery radius: La Mirada area 

-Choose the main target audience that your restaurant is focusing on. 

College students: Breakfast, lunch, dinner. (Open from 7 am-7 pm) 

-Estimate how much your restaurant's food will cost. 

$ - $$ Depends on what kinds of ingredients the customer choose. 

-Write an elevator pitch for your restaurant. 

A traditional Asian food. Healthy fast food with varied options of whole grains, fresh protein, and a variety of vegetables. Warm rice brings you a warm body and rich nutrition gives you the energy to get ready for all day!

---
## [RyanTimmons91/Dragonspire-Tech](https://github.com/RyanTimmons91/Dragonspire-Tech)@[416e694d41...](https://github.com/RyanTimmons91/Dragonspire-Tech/commit/416e694d4137e669f919f267de78b089e7c4bef0)
#### Wednesday 2020-07-08 22:56:19 by Ryan

Initial Config Updates

Disabled the Extra utilities BAG of holding due to a bug that causes the contents to be lost

Enabled Foam fix experamental options

Enabled a dimension unload delay of 5 seconds

Hardcore darkness levels in the overworld outside now depend on moon light

Disabled Harder Branch Mining hunger mechanic, needs balanced a bit

Tweaked rough mobs to be a little less rough:
Creeper fuse time is now 60
Creeper invisability is now 1 block
Disabled enderman item theft
Ghasts do not drop TNT
Pigmen are no longer always agressive
Pigmen will be agressive if you touch them, don't do that, PERSONAL SPACE
Silverfish will not split
Skeleton bows have some cooldown (75%)
Rough mobs only spawn 512+ blocks from spawn
Spiders aren't guaranteed to slow and will not web targets

Added more spice of life levels

---

# [<](2020-07-07.md) 2020-07-08 [>](2020-07-09.md)

