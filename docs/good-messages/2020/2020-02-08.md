# [<](2020-02-07.md) 2020-02-08 [>](2020-02-09.md)

1,402,167 events, 781,904 push events, 1,141,897 commit messages, 69,881,933 characters


## [Flare-Client/Flare-Client](https://github.com/Flare-Client/Flare-Client)@[ccb045e63e...](https://github.com/Flare-Client/Flare-Client/commit/ccb045e63e14360fb6d7860a014c8189b6119506)
#### Saturday 2020-02-08 02:02:40 by DisabledMallis

REALIZE IM A FUCKING IDIOT AND FIX THE FUCKING MEMROY LEAK STACK FUCK YOU

---
## [newstools/2020-sundiata-post](https://github.com/newstools/2020-sundiata-post)@[b4e7f122c5...](https://github.com/newstools/2020-sundiata-post/commit/b4e7f122c598b005ea9fbd741494cd1d18e5443e)
#### Saturday 2020-02-08 02:18:13 by NewsTools

Created Text For URL [sundiatapost.com/10-year-old-boy-impregnates-his-13-year-old-girlfriend-photos/]

---
## [FrequencyX4/CTBot](https://github.com/FrequencyX4/CTBot)@[b64c6eab46...](https://github.com/FrequencyX4/CTBot/commit/b64c6eab46663c6ab19982a1615b81d79f803746)
#### Saturday 2020-02-08 06:51:50 by Lach993

made it a bit more flexible

added .lower() to message.content to make caps not matter
added a dictionary containing the statements so if we want to add more later its not a big deal to add like 3 lines per message.
--end--

now for another one of my commit changes where i tell my life story: i haven't programmed in like 8 days cause school is getting harder and i don't have time, its actually really disappointing and i noticed that the amount of things i have forgotten is INSANE. like im second judging myself if i even wrote that correctly or if the syntax is just 100% wrong. idek at this point. anyway i need to learn to put some time aside so i can do more projects and mess around with python again.

---
## [petre-symfony/form-symfony-system](https://github.com/petre-symfony/form-symfony-system)@[ed0295c9e5...](https://github.com/petre-symfony/form-symfony-system/commit/ed0295c9e53678d7e8b6f07e2ac4e65ab42561ba)
#### Saturday 2020-02-08 07:44:35 by petrero

11.1.Form Rendering Functions: form_*{The Form Rendering Functions; CSRF Tok
en; form_widget and form_row()}

To render the form, we're using a few form functions: one that makes the form start tag, one that makes the end tag and one that renders all the fields, labels and errors inside.
This was easy to set up. The problem is that we have almost no control over the HTML markup that's used! Sure, we were able to activate a "form theme" that told it to use Bootstrap-friendly markup. But, what if you need more control?
This is probably the hardest part of Symfony's form system. But don't worry: we're going to learn several different strategies to help you get the markup you need... without going crazy... probably.

The Form Rendering Functions
Go to your other tab and Google for "Symfony form rendering functions" to find a page that talks all about the functions we're using and a few others.
First, form_start(), yes, this does just render the form start tag, which might seem kind of silly, but it can come in handy when you add a file upload field to your form: it automatically add the enctype attribute.
Oh, but notice: form_start() has a second argument: an array of variables that can be passed to customize it. Apparently you can pass method to change the method attribute or attr to add any other attributes to the form tag - like a class.
Next: find form_end(). This one seems even sillier because it literally prints... yep! The form closing tag! But, it has a hidden superpower: it also renders any fields that we forgot to render. Now, that might not make sense yet because this magic form_widget() function seems to be rendering everything automatically. But, in a moment, we'll render the fields one-by-one. When we do that, if we've forgotten to render any of the fields, form_end() will render them for us... and then the closing tag.
That still may not seem like a good feature... and, in many ways, it's not! In reality, the purpose of this is not so that we can be lazy and form_end() will save us. Nope - the true purpose is that form_end() will render any hidden fields automatically, without us needing to even think about them. Most importantly, it will render your form's CSRF token

CSRF Token
Inspect element near the bottom of the form. Woh! Without us doing anything, we have a hidden input tag called _token. This is a CSRF token and it was automatically added by Symfony. And, even cooler, when we submit, Symfony automatically validates it.
Without even knowing it, all of our forms are protected from CSRF attacks.

form_widget and form_row()
Back to the form rendering goodness! To print the form fields themselves, the easiest way is to call form_widget() and pass the entire form. But, if you need a little bit more control, instead of form_widget(), you can call form_row() and render each field individually. For example, articleForm.title. Copy that and paste it three more times. Render articleForm.content, articleForm.publishedAt and articleForm.author.

---
## [petre-symfony/form-symfony-system](https://github.com/petre-symfony/form-symfony-system)@[c674df8b7e...](https://github.com/petre-symfony/form-symfony-system/commit/c674df8b7e6e9476565a5f9d09b2c7c0095d62bc)
#### Saturday 2020-02-08 07:44:35 by petrero

13.5.The Edit Form{Reusing the Form Rendering Template}

Reusing the Form Rendering Template
Cool except... I don't love having all this duplicated form rendering logic - especially if we start customizing more stuff. To avoid this, create a new template file: _form.html.twig. I'm prefixing this by _ just to help me remember that this template will render a little bit of content - not an entire page.
Next, copy the entire form code and paste! Oh, but the button needs to be different for each page! No problem: render a new variable: {{ button_text }}.
Then, from the edit template, use the include() function to include article_admin/_form.html.twig and pass one extra variable as a second argument: button_text set to Update./bin/console doctrine:fixtures:load Copy this and repeat it in new: remove the duplicated stuff and say Create./bin/console doctrine:fixtures:load
I love it! Let's double-check that it works. No problems on edit! And, if we go to /admin/article/new... nice!

---
## [petre-symfony/form-symfony-system](https://github.com/petre-symfony/form-symfony-system)@[2ea09eeee5...](https://github.com/petre-symfony/form-symfony-system/commit/2ea09eeee51d821ce3134ff58d7406fd28666f7e)
#### Saturday 2020-02-08 07:44:35 by petrero

12.1.Form Rendering Variables{Discovering the Form Variables}

Find the form_row() documentation. There is one super important thing that almost all of these functions share: their last argument is something called variables.
These variables are key to controlling how each part of each field is rendered. And it's explained a bit more at the bottom. Yep - this table describes the most common "variables" - which are kind of like "options" - that you can pass to most fields, including label.
Let's override that variable for the title. Pass a second argument to form_row(): an array with a label key. How about, Article title.
Try that! Reload the form. Boom! Label changed!

Discovering the Form Variables
There are tons of variables that you can pass to the form rendering functions to change how the field is rendered. And the list of those variables will be slightly different for each field type. The best way to see all the possibilities is back inside our best friend: the form profiler.
Click on the field you want to customize - like title. I'll collapse the options stuff. Remember: options are what we can pass to the third argument of the add() function in our form class.
For rendering, we're interested in the "View Variables". Behind the scenes, each part of each field is rendered by a mini Twig template that lives inside Symfony. We'll see this later. These variables are passed to those Twig templates and used to control, well, almost everything.
Hey! There's the label variable we just overrode! Notice, it's null: the values inside the profiler represent the values at the moment the form object is passed into the Twig template. So, if you override a value, it won't show up here. No big deal - just don't let that surprise you.
Ah, and there's a help message and a whole bunch of other things that help the form do its job, like full_name, which will be the name attribute, and even the id attribute.

---
## [petre-symfony/form-symfony-system](https://github.com/petre-symfony/form-symfony-system)@[73ba2133f5...](https://github.com/petre-symfony/form-symfony-system/commit/73ba2133f536f772d91b6a54e688d1600eef30e7)
#### Saturday 2020-02-08 10:01:05 by petrero

18.1.Agree to Terms Checkbox Field

The User class has an agreedTermsAt property that expects a DateTime object. But, our form has an agreeTerms field that, on submit, will give us a true/false boolean value. How can we make these work together? As I so often like to say: there are two options.
First, we could be clever! There is no agreeTerms property on User. But, we could create a setAgreeTerms() method on User. When that's called, we would actually set the agreedTermsAt property to the current date. We would also need to create a getAgreeTerms() method that would return a boolean based on whether or not the agreedTermsAt property was set.
This is a fine solution. But, this is also a good example of how the form system can start to make your life harder instead of easier. When your form and your class don't look the same, sometimes you can find a simple and natural solution. But sometimes, you might need to dream up something crazy to make it all work. If the solution isn't obvious to you, move on to option two: make the field unmapped.
Let's try that: set agreeTerms to mapped false. To force this to be checked, add constraints set to a new IsTrue()... because we need the underlying value of this field to be true, not false. Set a custom message:

  I know, it's silly, but you must agree to our terms
Excellent! Thanks to the mapped = false, the form should at least load. Try it - refresh! Yes! Well... oh boy - our styling is so bad, the checkbox is hiding off the screen! Let's worry about that in a minute.

---
## [petre-symfony/form-symfony-system](https://github.com/petre-symfony/form-symfony-system)@[b8ac9822bd...](https://github.com/petre-symfony/form-symfony-system/commit/b8ac9822bddae7b60ceb449ef6db8f6e2e4d00c7)
#### Saturday 2020-02-08 10:01:05 by petrero

14.1.Registration Form{./bin/console make:form}

Head back over to /register. We built this in our security tutorial. It does work... but we kind of cheated. Back in your editor, open src/Controller/SecurityController.php and find the register() method. Yep, it's pretty obvious: we did not use the form component. Instead, we manually read and handled the POST data. The template - templates/security/register.html.twig - is just a hardcoded HTML form.
Ok, first: even if you use and love the Form component, you do not need to use it in every single situation. If you have a simple form and want to skip it, sure! You can totally do that. But... our registration form is missing one key thing that all forms should have: CSRF protection. When you use the Form component. you get CSRF protection for free! And, usually, that's enough of a reason for me to use it. But, you can add CSRF protection without the form system: check out our login from for an example.

make:form
Let's refactor our code to use the form system. Remember step 1? Create a form class... like we did with ArticleFormType. That's pretty easy. But to be even lazier, we can generate it! Find your terminal and run:

php bin/console make:form
Call the class, UserRegistrationFormType. This will ask if you want this form to be bound to a class. That's usually what we want, but it's optional. Bind our form to the User class.
Nice! It created one new file. Find that and open it up!

---
## [mrakgr/The-Spiral-Language](https://github.com/mrakgr/The-Spiral-Language)@[7d4796eeb0...](https://github.com/mrakgr/The-Spiral-Language/commit/7d4796eeb0ad64d9d7618d6d6b2675e5f4ef4cd3)
#### Saturday 2020-02-08 11:13:54 by Marko Grdinić

"9:40am. Ok, enough chilling. I've been doing that for nearly an hour. It is time to get something done.

9:45am. Let me open the IDE...

```
let test41: SpiralModule =
    {
    name="test40"
    prerequisites=[]
    description="Does the let statement work?"
    code=
    """
inl main _ =
    let f (x : i64) = x
    f 3
    """
    }
```

This just gets me `Box not implemented`.

```
| Op(op,_) -> raise_type_error d <| sprintf "Compiler error: %A not implemented" op
```

This is strange. At least when annotation is given I'd expect it to go through a different channel.

```
    | AnnotTest(do_boxing,ty,expr,on_succ,on_fail) ->
        let a = v expr
        let b = tev d ty
        if do_boxing then ev (push_value_var (box' d (a,b)) d) on_succ
        else if data_to_ty a = b then ev d on_succ else ev d on_fail
```

I mean this thing here.

Actually, do I even need the regular box?

Well...

Actually, I should make `ty` optional here. That way the typechecker will know where it has to put things.

10:10am. I am thinking here.

All this is so complicated.

Just how many different ways of boxing can there be?

If I am going to box, the most sensible thing would be to put the annotation directly in the function. That way, the typechecker will later know that it has to propagate this information and put it in the right place.

10:45am. https://thegradient.pub/independently-reproducible-machine-learning/

Let me read this.

I am still thinking about the whole issue of annotations vs boxing.

11am. Still thinking about it...

11:35am. In the bathroom...on this chair...I am still thinking about it.

11:55am. I can't believe I am completely stuck on this. It is not even closure conversion that is the problem, but how to deal with annotations instead.

I put in let statements haphazardly, saying the typechecker will take care of it, but now it is the time to really think about it.

What I am thinking about now is skipping the closure conversion thing and moving straight onto typechecking. That will clear things up for me.

12pm. Let me stop here. I did not do any programming to speak of despite having a head start.

Damn it, I really did want to make progress on closure conversion this morning too.

Nevermind. Forget that.

That and macros will be done in due time.

What I am going to do now is start the second part of the language. The parts up to now were only there to finally deal with the compilation issues. It is the top down typing that will really be Spiral's wings. It is this what will allow me to fight through the cruel world of computer science.

12:10pm. Ah damn it, now I am reading shitty ML sub threads. Let me have breakfast here.

I hadn't planned on starting typechecking right away so I've been caught flatfooted.

I am going to think about this for a bit and then just get on with it.

I'll do closure conversion while working on part two.

It is important that I get this done. Typechecking via constraint solving is something new even to me, and it will be the first time I will be working on this. And while I am doing this, I will also be ironing out the syntax so that the two pieces integrate nicely.

It is only after I've done this that I can say that the new language is complete.

This will be the real deal. The one true test of skill in PL development.

After I do this, I really will have done it all.

After it is done, all that will remain is for me to fish for the right ML algorithms."

---
## [cashweb/cashd](https://github.com/cashweb/cashd)@[a1f94345f2...](https://github.com/cashweb/cashd/commit/a1f94345f230db6aa7283dc2174c6141dd213eed)
#### Saturday 2020-02-08 15:31:31 by Jonas Schnelli

Merge #13439: rpc: Avoid "duplicate" return value for invalid submitblock

Summary:
f74894480 Only set fNewBlock to true in AcceptBlock when we write to disk (Matt Corallo)
fa6e49731 rpc: Avoid "duplicate" return value for invalid submitblock (MarcoFalke)

Pull request description:

  This is #13395 with one more commit tacked on. MarcoFalke got tired of dealing with the stupidity of fixing a return code with too many rounds of review (not that I blame him). Honestly we should probably have no return whatsoever, but for now, this fixes it (as well as nLastBlockTime for eviction purposes).

  Original description:

  When `submitblock` of an invalid block, the return value should not be `"duplicate"`.

  This is only seen when the header was previously found (denoted by the incorrectly named boolean `fBlockPresent`). Fix this bug by removing `fBlockPresent`.

Tree-SHA512: 0ce3092655d5d904b4c8c5ff7479f73ce387144a738f20472b8af132564005c6db5594ae366e589508f6258506ee7a28b1c7995a83a8328b334f99316006bf2d

Backport of Core PR13439
https://github.com/bitcoin/bitcoin/pull/13439/files

Test Plan:
```
make check
test_runner.py
```

Reviewers: #bitcoin_abc, deadalnix, nakihito

Reviewed By: #bitcoin_abc, deadalnix, nakihito

Differential Revision: https://reviews.bitcoinabc.org/D3856

---
## [petre-symfony/form-symfony-system](https://github.com/petre-symfony/form-symfony-system)@[0e5ac39d99...](https://github.com/petre-symfony/form-symfony-system/commit/0e5ac39d9982467b0ba23ac23c60cc12f0935978)
#### Saturday 2020-02-08 15:49:58 by petrero

24.1.Data Transformer

We built a custom field type called UserSelectTextType and we're already using it for the author field. That's cool, except, thanks to getParent(), it's really just a TextType in disguise!
Internally, TextType basically has no data transformer: it takes whatever value is on the object and tries to print it as the value for the HTML input! For the author field, it means that it's trying to echo that property's value: an entire User object! Thanks to the __toString() method in that class, this prints the first name.
Let's remove that and see what happens. Refresh! Woohoo! A big ol' error:

  Object of class User could not be converted to string

More importantly, even if we put this back, yes, the form would render. But when we submitted it, we would just get a different huge error: the form would try to take the submitted string and pass that to setAuthor().
To fix this, our field needs a data transformer: something that's capable of taking the User object and rendering its email field. And on submit, transforming that email string back into a User object.

Creating the Data Transformer
Here's how it works: in the Form/ directory, create a new DataTransformer/ directory, but, as usual, the location of the new class won't matter. Then add a new class: EmailToUserTransformer.
The only rule for a data transformer is that it needs to implement a DataTransformerInterface. I'll go to the Code -> Generate menu, or Command+N on a Mac, select "Implement Methods" and choose the two from that interface.
I love data transformers! Let's add some debug code in each method so we can see when they're called and what this value looks like. So dd('transform', $value) and dd('reverse transform', $value).
To make UserSelectTextType use this, head back to that class, go to the Code -> Generate menu again, or Command + N on a Mac, and override one more method: buildForm().
Hey! We know this method! This is is the method that we override in our normal form type classes: it's where we add the fields! It turns out that there are a few other things that you can do with this $builder object: one of them is $builder->addModelTransformer(). Pass this a new EmailToUserTransformer().
Let's try it! I'll hit enter on the URL in my browser to re-render the form with a GET request. And... boom! We hit the transform() method! And the value is our User object.
This is awesome! That's the whole point of transform()! This method is called. when the form is rendering: it takes the raw data for a field - in our case the User object that lives on the author property - and our job is to transform that into a representation that can be used for the form field. In other words, the email string.

---
## [petre-symfony/form-symfony-system](https://github.com/petre-symfony/form-symfony-system)@[a078dfdde1...](https://github.com/petre-symfony/form-symfony-system/commit/a078dfdde195c1017b98d3d07cf24e84434277fd)
#### Saturday 2020-02-08 15:49:58 by petrero

20.1.Form Theme Block Naming & Creating our Theme! {Block Prefixes; The Form Rendering Big Picture; Creating our Form Theme}

When Symfony renders the "label" part of a password field type... it should be looking for a password_label block name. And... it is. But... that block doesn't exist! What's going on?
Here's the situation: the label will look the same for probably every field type: there's no difference between how a label should render for a text field versus a choice drop-down. To avoid duplicating the label code over and over again, the block system has a fallback mechanism.

Block Prefixes
Go back to your browser, click on the form icon on the web debug toolbar and select plainPassword. Go check out the "View Variables". Ah, here it is: the very special block_prefixes variable! This is an array that Symfony uses when trying to find which block to use. For example, to render the "widget" for this field, Symfony first looks for a block named _user_registration_form_plainPassword_widget.
This super specific block name will allow us to change how the widget looks for just one field of the form. We'll do this a bit later. If it does not find that block, it next looks for password_widget, then text_widget, and finally form_widget. There is a password_widget block but, when the label is being rendered, there is not a password_label block. Ok, so it next looks for text_label. Let's see if that exists. Nope! Finally, it looks for form_label. Search for that. Got it!
This is the block that used to render every label for every field type.

The Form Rendering Big Picture
Open up register.html.twig: let's back up and make sure this all makes sense. When we call form_widget(registrationForm), that's a shortcut for calling form_row() on each field. That means that the "row" part of each field is rendered. Not surprisingly, the "row" looks exactly the same for all field types. In other words, in bootstrap_4_layout.html.twig, you probably won't find a password_row block, but you will find a form_row block. Keep searching until you find it... there it is!
Ah, I love it! It has some special logic on top, but then! Yes: it renders a div with a form-group class then calls the form_label(), form_widget() and form_help() functions! The reason you don't see form_errors() here is that it's called from inside of form_label() so we can get the correct Bootstrap markup.

Creating our Form Theme
We now know enough to be dangerous! If we could override this form_row block just for the registration form, we could simplify the markup to match what we need. How do we do that? By creating our own form theme... which is just a template that contains these fancy blocks.
If you create a form theme in its own template file - like bootstrap_4_layout.html.twig - you can reuse it across your entire app by adding it to twig.yaml after bootstrap. Or, you can add some code to your Twig template to use a specific form theme template only on certain forms.
But, we actually will not create a separate template for our form theme. Why not? If you only need to customize a single form, there's an easier way. At the top of the template where you form lives, add {% form_theme %}, the name of your form variable - registrationForm - and then _self.

This says:

  Yo form system! I want to use this template as a form theme template for the registrationForm object.

As soon as we do this, when Symfony renders the form, it will first look for form theme blocks right inside of this template. Yep, we could copy that form_row block from Bootstrap, paste it, and start customizing!
Let's do that! But, actually, the Bootstrap form_row block is a bit fancier than I need. Instead, open form_div_layout.html.twig and find the block there. Copy that and, in register.html.twig, paste this anywhere.

---
## [howardt12345/zoom](https://github.com/howardt12345/zoom)@[bc0553b708...](https://github.com/howardt12345/zoom/commit/bc0553b7083449f13c1cc68cda4ab1220044a245)
#### Saturday 2020-02-08 16:33:28 by Ethan Plant

Merge branch 'master' of https://github.com/howardt12345/zoom
Fuck you

---
## [petre-symfony/form-symfony-system](https://github.com/petre-symfony/form-symfony-system)@[8407424a1c...](https://github.com/petre-symfony/form-symfony-system/commit/8407424a1c9fce2076648e78f26a35dd576bbd17)
#### Saturday 2020-02-08 16:45:35 by petrero

26.2.Leveraging Custom Field Options{Adding a finderCallback Option; Investigating the Core Field Types}

Cool! We've now made this class a little bit more flexible. But, that doesn't really help us yet. How can we allow this  to be customized each time we use this field? By creating a brand new field option.
Check this out: we know that invalid_message is already an option in Symfony and we're changing its default value. But, we can invent new options too! Add a new option called finder_callback and give it a default value: a callback that accepts a UserRepository $userRepository argument and the value - which will be a string $email. Inside return the normal $userRepository->findOneBy() with ['email' => $email].
Next, check out the build() method. See this array of $options? That will now include finder_callback, which will either be our default value, or some other callback if it was overridden.
Let's break this onto multiple lines and, for the second argument to EmailToUserTransformer, pass $options['finder_callback'].
Ok! Let's make sure it works. I'll hit enter on the URL to reload the page. Then, change to spacebar2@example.com, submit and... yes! It saves!
The real power of this is that, in ArticleFormType, when we use UserSelectTextType, we can pass a finder_callback option if we need to do a custom query. If we did that, it would override the default value and, when we instantiate EmailToUserTransformer, the second argument would be the callback that we passed from ArticleFormType.

Investigating the Core Field Types
This is how options are used internally by the core Symfony types. Oh, and you probably noticed by now that every field type in Symfony is represented by a normal, PHP class! If you've ever want to know more about how a specific field or option works, just open up the class!
For example, we know that this field is a DateTimeType. Press Shift+Shift and look for DateTimeType - open the one from the Form component. I love it - these classes will look a lot like our own custom field type class! This one has a build() method that adds some transformers. And if you scroll down far enough, cool! Here is the configureOptions() method where all of the valid options are defined for this field.
Want to know how one of these options is used? Copy its name and find out! Search for the with_seconds option. No surprise: it's used in buildForm(). If you looked a little further, you'd see that this is eventually used to configure how the data transformer works.
These core classes are a great way to figure out how to do something advanced or to get inspiration for your own custom field type. Don't' be afraid to dig!
Next: let's hook up some auto-complete JavaScript to this field.

---
## [petre-symfony/form-symfony-system](https://github.com/petre-symfony/form-symfony-system)@[d1a4f5e52a...](https://github.com/petre-symfony/form-symfony-system/commit/d1a4f5e52a3240b056dbda4cfebf0c06c7b9cd4d)
#### Saturday 2020-02-08 16:45:35 by petrero

27.2.Autocomplete JavaScript{Implementing autocomplete.js; Adding the js- Class to the Field; Field Options vs View Variables}

Implementing autocomplete.js
Initial setup done! Head back to their documentation to find where it talks about how to use this with jQuery. It looks kinda simple: select an element, call .autcomplete() on it, then... pass a ton of options that tell it how to fetch and process the autocomplete data.
Cool! Let's do something similar! I'll start with the document.ready() block from jQuery just to make sure the DOM is fully loaded. Now: here is the key moment: how can we write JavaScript that can connect to our custom field? Should we select it by the id? Something else?
I like to select with a class. Find all elements with, how about, some .js-user-autocomplete class. Nothing has this class yet, but our field will soon. Call .autocomplete() on this, pass it that same hint: false and then an array. This looks a bit complex: add a JavaScript object with a source option set to a function() that receives a query argument and a callback cb argument.
Basically, as we're typing in the text field, the library will call this function and pass whatever we've entered into the text box so far as the query argument. Our job is to determine which results match this "query" text and pass those back by calling the cb function.
To start... let's hardcode something and see if it works! Call cb() and pass it an array where each entry is an object with a value key... because that's how the library wants the data to be structured by default.
Thanks to my imaginative code, no matter what we type, foo and bar should be suggested.

Adding the js- Class to the Field
And... we're almost... sorta done! In order for this to be applied to our field, all we need to do is add this class to the author field. No problem! Copy the class name and open UserSelectTextType. Here, we can set a default value for the attr option to an array with class set to js-user-autocomplete.

Field Options vs View Variables
Up until now, if we've wanted to add a class attribute, we've done it from inside of our Twig template. For example, open security/register.html.twig. For the form start tag, we're passing an attr variable with a class key. Or, for the fields, we're adding a placeholder attribute.
attr is one of a few things that can be passed either as a view variable or also as a field option. But, I want to be clear: options and variables are two different things. Go back and open the profiler. Click on, how about, the author field. We know that there is a set of options that we can pass to the field from inside the form class. And then, when you're rendering in your template, there is a different set of view variables. These are two different concepts. However, there is some overlap, like attr.
Behind the scenes, when you pass the attr option, that simply becomes the default value for the attr view variable. The attr option, just like the label and help options - exists just for the added convenience of being able to set these in your form class or in your template.
Anyways, thanks to the code in UserSelectTextType, our field should have this class. Let's try it! Close the profiler, refresh and... ah! I killed my page! The CSS is gone! I always do that! Go back to the template and add the missing parent() call: I don't want to completely replace the CSS from our layout.
Ok, try it again. Much better. And when we type into the field... yes! We get foo and bar no matter what we type. Awesome!
Next, hey: I like foo and bar as much as the next programmer. But we should probably make an AJAX call to fetch a true list of matching email addresses.

---
## [mrakgr/The-Spiral-Language](https://github.com/mrakgr/The-Spiral-Language)@[8ac02d8b0f...](https://github.com/mrakgr/The-Spiral-Language/commit/8ac02d8b0f720f9b6eeff5789bb438cf180fc88b)
#### Saturday 2020-02-08 16:56:31 by Marko Grdinić

"5:10pm. Ok, I've somewhat fortified my mind. I've been in bed all this time thinking. I'd be lying if I said I was thinking about programming only, but going through blocks like these takes time.

Ok, first thing's first.

The part one of the language is nearly done. The things that are missing: union types, closures, macros are minor challenges that if wasn't intending to move to typechecking I would finish swiftly in a day or two. So that is what I mean by nearly done.

5:20pm. Right now I've been approaching this problem from the perspective of extending the work that I've done.

5:25pm. But that is not the right way to go about this.

Instead I need to fully commit to the top-down aspect. I won't be able to do the integration until I master it.

For this kind of planning to be done, it is not enough to have a rough conceptual understanding. My mastery of the subject has to be complete.

5:30pm. So here is what I will do. I will literally abandon the v0.2 stuff that I've done up to now. I can lie as it is for a few months.

Instead what I will do is start a new project, that is focused exclusively on the typechecking aspects of Spiral.

My goal will just be to do the typechecking, and alongside that I will begin work on the VSCode plugin.

When that is done, I will bring in the constraints and the partial evaluator.

5:35pm. It will be much easier to develop the new half in isolation and connect it later rather than do it all simultaneously.

I want to fully dedicate myself mentally to this next part without necessarily burdening myself with thoughts of what the prepass or the partial evaluator should be doing.

5:40pm. It is much earlier than I thought it would be, but the gong of destiny has been struck. It is time to begin the second fateful part of Spiral.

The big lesson from all of this is that even though partial evaluation can be used to do anything, it is not necessarily the best idea to actually do so.

The parallels with deep learning aren't escaping me.

Backprop is a key thing that can potentially do anything, but cannot scale all the way. Naive ways of doing regularization: L2 norm, weight norm, layer norm...aren't enough to deal with its issues. Neither can architectural tricks.

There is definitely something missing before the full picture can be completed.

In case of Spiral, I can see the issues and the problem clearly, but in the case of deep learning only the issues are clear. The neural equivalent of unification is shrouded in absolute darkness.

When the veil gets lifted, I will be able to move on to the next step and fulfill the old promises of the last decade.

5:50pm. Well, I'll take it easy from here.

Typechecking and the plugin sound like a big deal, but compared to the things I've done so far, they should not be too much.

Contextually, it seems partial evaluation is a more advanced subject than typechecking so I should be safe as long as I take it one at a time. Rather than let myself be crushed by the immensity of work I've yet to do, I need to look at the lighter aspects of the work that is to come.

For the first time in my life, I will be writing top-down Spiral code. If that is not something to look forward to, I do not know what is."

---
## [DanOscarsson/mpv](https://github.com/DanOscarsson/mpv)@[b9d351f02a...](https://github.com/DanOscarsson/mpv/commit/b9d351f02a3266b76256a90fc9c51f9d3cbf185d)
#### Saturday 2020-02-08 17:03:53 by wm4

Implement backwards playback

See manpage additions. This is a huge hack. You can bet there are shit
tons of bugs. It's literally forcing square pegs into round holes.
Hopefully, the manpage wall of text makes it clear enough that the whole
shit can easily crash and burn. (Although it shouldn't literally crash.
That would be a bug. It possibly _could_ start a fire by entering some
sort of endless loop, not a literal one, just something where it tries
to do work without making progress.)

(Some obvious bugs I simply ignored for this initial version, but
there's a number of potential bugs I can't even imagine. Normal playback
should remain completely unaffected, though.)

How this works is also described in the manpage. Basically, we demux in
reverse, then we decode in reverse, then we render in reverse.

The decoding part is the simplest: just reorder the decoder output. This
weirdly integrates with the timeline/ordered chapter code, which also
has special requirements on feeding the packets to the decoder in a
non-straightforward way (it doesn't conflict, although a bugmessmass
breaks correct slicing of segments, so EDL/ordered chapter playback is
broken in backward direction).

Backward demuxing is pretty involved. In theory, it could be much
easier: simply iterating the usual demuxer output backward. But this
just doesn't fit into our code, so there's a cthulhu nightmare of shit.
To be specific, each stream (audio, video) is reversed separately. At
least this means we can do backward playback within cached content (for
example, you could play backwards in a live stream; on that note, it
disables prefetching, which would lead to losing new live video, but
this could be avoided).

The fuckmess also meant that I didn't bother trying to support
subtitles. Subtitles are a problem because they're "sparse" streams.
They need to be "passively" demuxed: you don't try to read a subtitle
packet, you demux audio and video, and then look whether there was a
subtitle packet. This means to get subtitles for a time range, you need
to know that you demuxed video and audio over this range, which becomes
pretty messy when you demux audio and video backwards separately.

Backward display is the most weird (and potentially buggy) part. To
avoid that we need to touch a LOT of timing code, we negate all
timestamps. The basic idea is that due to the navigation, all
comparisons and subtractions of timestamps keep working, and you don't
need to touch every single of them to "reverse" them.

E.g.:

    bool before = pts_a < pts_b;

would need to be:

    bool before = forward
        ? pts_a < pts_b
        : pts_a > pts_b;

or:

    bool before = pts_a * dir < pts_b * dir;

or if you, as it's implemented now, just do this after decoding:

    pts_a *= dir;
    pts_b *= dir;

and then in the normal timing/renderer code:

    bool before = pts_a < pts_b;

Consequently, we don't need many changes in the latter code. But some
assumptions inhererently true for forward playback may have been broken
anyway. What is mainly needed is fixing places where values are passed
between positive and negative "domains". For example, seeking and
timestamp user display always uses positive timestamps. The main mess is
that it's not obvious which domain a given variable should or does use.

Well, in my tests with a single file, it suddenly started to work when I
did this. I'm honestly surprised that it did, and that I didn't have to
change a single line in the timing code past decoder (just something
minor to make external/cached text subtitles display). I committed it
immediately while avoiding thinking about it. But there really likely
are subtle problems of all sorts.

As far as I'm aware, gstreamer also supports backward playback. When I
looked at this years ago, I couldn't find a way to actually try this,
and I didn't revisit it now. Back then I also read talk slides from the
person who implemented it, and I'm not sure if and which ideas I might
have taken from it. It's possible that the timestamp reversal is
inspired by it, but I didn't check. (I think it claimed that it could
avoid large changes by changing a sign?)

VapourSynth has some sort of reverse function, which provides a backward
view on a video. The function itself is trivial to implement, as
VapourSynth aims to provide random access to video by frame numbers (so
you just request decreasing frame numbers). From what I remember, it
wasn't exactly fluid, but it worked. It's implemented by creating an
index, and seeking to the target on demand, and a bunch of caching. mpv
could use it, but it would either require using VapourSynth as demuxer
and decoder for everything, or replacing the current file every time
something is supposed to be played backwards.

FFmpeg's libavfilter has reversal filters for audio and video. These
require buffering the entire media data of the file, and don't really
fit into mpv's architecture. It could be used by playing a libavfilter
graph that also demuxes, but that's like VapourSynth but worse.

---
## [DanOscarsson/mpv](https://github.com/DanOscarsson/mpv)@[5b4ae42328...](https://github.com/DanOscarsson/mpv/commit/5b4ae42328b75b2f7683d04736d3c07108b0bcc3)
#### Saturday 2020-02-08 17:03:53 by wm4

demux_raw: fix operation with demuxer cache and backward playback

Raw audio formats can be accessed sample-wise, and logically audio
packets demuxed from it would contain only 1 sample. This is
inefficient, so raw audio demuxers typically "bundle" multiple samples
in one packet.

The problem for the demuxer cache and backward playback is that they
need properly aligned packets to make seeking "deterministic". The
requirement is that if you read some packets, and then seek back, you
eventually see the same packets again. demux_raw basically allowed to
seek into the middle of a previously returned packet, which makes it
impossible to make the transition seamless. (Unless you'd be aware of
the packet data format and cut them to make it seamless, which is too
complex for such a use case.)

Solve this by always aligning seeks to packet boundaries. This reduces
the seek accuracy to the arbitrarily chosen packet size. But you can use
hr-seek to fix this. The gain from not making raw audio an awful special
case pays in exchange for this "stupid" suggestion to use hr-seek.

It appears this also fixes that it could and did seek into the middle of
the frame (not sure if this code was ever tested - it goes back to
removing the code duplication between the former demux_rawaudio.c and
demux_rawvideo.c).

If you really cared, you could introduce a seek flag that controls
whether the seek is aligned or not. Then code which requires
"deterministic" demuxing could set it. But this isn't really useful for
us, and we'd always set the flag anyway, unless maybe the caching were
forced disabled.

libavformat's wav demuxer exhibits the same issue. We can't fix it (it
would require the unpleasant experience of contributing to FFmpeg), so
document this in otions.rst. In theory, this also affects seek range
joining, but the only bad effect should be that cached data is
discarded.

---
## [DanOscarsson/mpv](https://github.com/DanOscarsson/mpv)@[eb951835ff...](https://github.com/DanOscarsson/mpv/commit/eb951835fff36e0a3af63ce08b894b59c03502ef)
#### Saturday 2020-02-08 17:03:53 by wm4

player: send MPV_EVENT_TICK during init for the sake of the osc

The OSC's (osc.lua) event handling is fundamentally broken. It waits for
MPV_EVENT_TICK to update the UI, and MPV_EVENT_TICK has become entirely
meaningless, except as a hack for the OSC. There are many situations
where the OSC doesn't properly update because the TICK event it expects
isn't sent.

Fix one of them: it doesn't update the cache state if the VO window is
forced and --demuxer-cache-wait is used. Make it so that the tick event
is sent even if playback initialization is taking time.

This is still slightly broken, because it works only if the mainloop is
actually run, which depends on random circumstances (such as moving the
mouse over the VO window). The next commit will add another such
circumstance which will make it appear to work, although it's still
conceptually broken. If we "fixed" it and strictly woke up the player
if the idle timer ran out, we'd send tick events all the time, even
if nothing is going on, which we don't want. Fucking shitshow.

---
## [DanOscarsson/mpv](https://github.com/DanOscarsson/mpv)@[62e9a0c5f6...](https://github.com/DanOscarsson/mpv/commit/62e9a0c5f6be63c4cbe6387cbd3419fe19e98b74)
#### Saturday 2020-02-08 17:03:53 by wm4

demux: add shitty start of stream detection

The demuxer cache benefits slightly from knowing where the current file
or stream begins. For example, seeking "left most" when the start is
cached would not trigger a low level seek (which would be followed by
messy range joining when it notices that the newly demuxed packets
overlap with an existing range).

Unfortunately, since multimedia is so crazy (or actually FFmpeg in its
quite imperfect attempt to be able to demux anything), it's hard to tell
where a file starts. There is no feedback whether a specific seek went
to the start of the file. Packets are not tagged with a flag indicating
they were demuxed from the start position. There is no index available
that could be used to cross-check this (even if the file contains a full
and "perfect" index, like mp4). You could go by the timestamps, but who
says streams start at 0? Streams can start somewhere at an extremely
high timestamps (transport streams like to do that), or they could start
at negative times (e.g. files with audio pre-padding will do that), and
maybe some file formats simply allow negative timestamps and could start
at any negative time. Even if the affected file formats don't allow it
in theory, they may in practice. In addition, FFmpeg exports a
start_time field, which may or may not be useful. (mpv's internal mkv
demuxer also exports such a field, but doesn't bother to set it for
efficiency and robustness reasons.)

Anyway, this is all a huge load of crap, so I decided that if the user
performs a seek command to time 0 or earlier, we consider the first
packet demuxed from each stream to be at the start of the file. In
addition, just trust the start_time field. This is the "shitty" part of
this commit.

One common case of negative timestamps is audio pre-padding. Demuxers
normally behave sanely, and will treat 0 as the start of the file, and
the first packets demuxed will have negative timestamps (since they
contain data to discard), which doesn't break our assumptions in this
commit. (Although, unfortunately, do break some other demuxer cache
assumptions, and the first cached range will be shown as starting at a
negative time.)

Implementation-wise, this is quite simple. Just split the existing
initial_state flag into two, since we want to deal with two separate
aspects. In addition, this avoids the refresh seek on track switching
when it happens right after a seek, instead of only after opening the
demuxer.

---
## [petre-symfony/form-symfony-system](https://github.com/petre-symfony/form-symfony-system)@[2149b4c409...](https://github.com/petre-symfony/form-symfony-system/commit/2149b4c409cb13b65eb712973caf8b1507409635)
#### Saturday 2020-02-08 18:14:21 by petrero

29.3.Hooking up the AJAX Autocomplete{Filtering the Users}

Filtering the Users
That's no surprise: our endpoint always returns every user. No worries - this is the easiest part! Go back to the JavaScript. The source function is passed a query argument: that's equal to whatever is typed into the input box at that moment. Let's use that! Add a '?query='+query to the URL.}
Back in AdminUtilityController, to read that, add a second argument, the Request object from HttpFoundation. Then, let's call a new method on UserRepository, how about findAllMatching(). Pass this the ?query= GET parameter by calling $request->query->get('query').
Nice! Copy the method name and then open src/Repository/UserRepository.php. Add the new public function findAllMatching() and give it a string $query argument. Let's also add an optional int $limit = 5 argument, because we probably shouldn't return 1000 users if 1000 users match the query. Advertise that this will return an array of User objects.
Inside, it's pretty simple: return $this->createQueryBuilder('u'), ->andWhere('u.email LIKE :query') and bind that with ->setParameter('query') and, this is a little weird, '%'..'%'.
Finish with ->setMaxResults($limit), ->getQuery() and ->getResult().
Done! Unless I've totally mucked things up, I think we should have a working autocomplete setup! Refresh to get the new JavaScript, type "spac" and... woohoo! Only 5 results! Let's get the web debug toolbar out of the way. I love it!
Next: there's one other important method you can override in your custom form field type class to control how it renders. We'll use it to absolutely make sure our autocomplete field has the HTML attributes it needs, even if we override the attr option when using the field.

---
## [Lomztein/Moduthulhu](https://github.com/Lomztein/Moduthulhu)@[4b9b3e7171...](https://github.com/Lomztein/Moduthulhu/commit/4b9b3e717196c91da71076002e1d1df32bcbd07e)
#### Saturday 2020-02-08 19:28:07 by Marcus L. Jensen

Merge pull request #7 from agesome1/patch-2

Slurs, cause fuck you

---
## [PrestonWeber/WhatsInMyPantryReact](https://github.com/PrestonWeber/WhatsInMyPantryReact)@[b0fb2f580e...](https://github.com/PrestonWeber/WhatsInMyPantryReact/commit/b0fb2f580e3bae7fb35faae41342d26126cf5086)
#### Saturday 2020-02-08 19:40:09 by Erik Beckstrand

I can't fucking figure this goddamn shit fucking out.

---
## [khydesse/dotfiles](https://github.com/khydesse/dotfiles)@[a39f8df11d...](https://github.com/khydesse/dotfiles/commit/a39f8df11d630cdada4a02115bb98236f6db1f8e)
#### Saturday 2020-02-08 21:02:59 by Mohammad Nihad

holy fuck too much to recap...switched to emacs with evilmode, now using bspwm and even using kitty instead of urxvt

---
## [Shadowfire117/CHOMPStation2](https://github.com/Shadowfire117/CHOMPStation2)@[e141872c31...](https://github.com/Shadowfire117/CHOMPStation2/commit/e141872c31ea745903a992de43d0c3162d87b29e)
#### Saturday 2020-02-08 21:22:07 by Shadowfire

Casino port

This is first phase of casino port where I have made my casino spaceship compatible with new chomp codebase. There isnt a connecting port at station yet due to changes being made to main map, but with second phase of casino port there should be one for casino shuttle to move back and forth to transfer visitors.

Non-casino changes
Port of:
purple assistant cap, wah!
wiggler hat, dont know if the sprite works fully yet.
The monocoole, every self respecting technomancer needs this! Also need this for casino rewards.
Snaps, can recommend for lunch, I prefer the licorice flavoured ones!
Space cleaner dispenser, yep any janitors dream, so far its only on casino spaceship.
Ported old modular sofa for station usage, is already on casino, future plans could involve making the modular sofa that can be built from steel be a little more pretty and made from wood as well and also get another overlay/color when added cloth for cushion.

also deleting a .txt file that I didnt get to delete before someone really wanted me to upload wip files so they could work off them, sorry about that but its fixed now!
deleted alienwhitelist and custom_items.txt since github doesnt seem to have those blacklisted

casino port:
Ported the map with the golden goose spacecasino
ported the deluxe edition bar and kitchen gear! Say hello to the good old deluxe dispenser, deluxe food vendor and deluxe drink vendor, perhaps one day they will be constructible by crew!
ported the casino stripper pole, casino roulette, slotmachine, poker/blackjack table, ported the casino wheel of fortune
casino wallet~
casino jukebox! And re implemented the system so the casino songs no longer are on the normal jukebox, sorry folks, hope you didnt like them too much :c
casino visitor and staff manual, might need a bit of revision depending on what event managers wants
Casino chips, gotta gamble with something!
fixed runtime errors from deluxe dispenser trying to add cartridges with reagents that have been renamed on new chomp

Be aware, there will be more casino changes in near future along with some other non-casino changes, including porting of pint metamorphic glass.

---
## [petre-symfony/form-symfony-system](https://github.com/petre-symfony/form-symfony-system)@[82fdc07af1...](https://github.com/petre-symfony/form-symfony-system/commit/82fdc07af12504dcc0593a00e0da20f5e279a9db)
#### Saturday 2020-02-08 23:03:30 by petrero

31.2.Form Type Extension{Registering the Form Type Extension; The form.type_extension Tag & autoconfigure}

Registering the Form Type Extension
The only new method is getExtendedType() - we'll talk about that in a second. To tell Symfony that this form type extension exists and to tell it that we want to extend the TextareaType, we need a little bit of config. This might look confusing at first. Let's code it up, then I'll explain.
Open config/services.yaml. And, at the bottom, we need to give our service a "tag". First, put the form class and below, add tags. The syntax here is a bit ugly: add a dash, open an array and set name to form.type_extension. Then I'll create a new line for my own sanity and add one more option extended_type. We need to set this to the form type class that we want to extend - so TextareaType. Let's cheat real quick: I'll use TextareaType, auto-complete that, copy the class, then delete that. Go paste it in the config. Oh, and I forgot my comma!
As soon as we do this, every time a TextareaType is created in the system, every method on our TextareaSizeExtension will be called. It's almost as if each of these methods actually lives inside of the TextareaType class! If we add some code to buildForm(), it's pretty much identical to opening up the TextareaType class and adding code right there!

The form.type_extension Tag & autoconfigure
Now, two important things. If you're using Symfony 4.2, then you do not need to add any of this code in services.yaml. Whenever you need to "plug into" some part of Symfony, internally, you do that by registering a service and giving it a "tag". The form.type_extension tag says:

  Hey Symfony! This isn't just a normal service! It's a form type extension! So make sure you use it for that!

But these days, you don't see "tags" much in Symfony. The reason is simple: for most things, Symfony looks at the interfaces that your service implements, and adds the correct tags automatically. In Symfony 4.1 and earlier, this does not happen for the FormTypeExtensionInterface. But in Symfony 4.2... it does! So, no config needed... at all.
But then, how does Symfony know which form type we want to extend in Symfony 4.2? The getExtendedType() method! Inside, return TextareaType::class. And yea, we also need to fill in this method in Symfony 4.1... it's a bit redundant, which is why Symfony 4.2 will be so much cooler.

 Tip

Since Symfony 4.2 getExtendedType() method is deprecated in favor of getExtendedTypes() but you still need a dummy implementation of getExtendedType()

---
## [petre-symfony/form-symfony-system](https://github.com/petre-symfony/form-symfony-system)@[3b739f64a7...](https://github.com/petre-symfony/form-symfony-system/commit/3b739f64a726a6c0032fa713f85c0ce8944b1ac7)
#### Saturday 2020-02-08 23:03:30 by petrero

31.5.Form Type Extension{Adding a new Field Option; How CSRF Protection Works}

But, in TextareaSizeExtension, we can invent new options. Do it down in configureOptions(): add $resolver->setDefaults() and invent a new rows option with a default value of 10.
Now, up in buildView(), notice that almost every method is passed the final array of $options for this field. Set the rows attribute to $options['rows'].
Done. The rows will default to 10, but we can override that via a brand, new shiny form field option. Try it! Refresh, inspect the textarea and... yes! The rows attribute is set to 15.

How CSRF Protection Works
This is the power of form type extensions. And these are even used in the core of Symfony to do some cool stuff. For example, remember how every form automatically has an _token CSRF token field? How does Symfony magically add that? The answer: a form type extension. Press Shift+Shift and look for a class called FormTypeCsrfExtension.
Cool! It extends an AbstractTypeExtension class, which implements the same FormTypeExtensionInterface but prevents you from needing to override every method. We also could have used this same class.
Anyways, in buildForm() it adds an "event listener", which activates some code that will validate the _token field when we submit. We'll talk about events in a little while.
In finishView() - which is very similar to buildView() - it adds a few variables to help render that hidden field. And finally, in configureOptions(), it adds some options that allow us to control things. For example, inside the configureOptions() method of any form class - like ArticleFormType - we could set a csrf_protection option to false to disable the CSRF token.
Next: how could we make our form look or act differently based on the data passed to it? Like, how could we make the author field disabled, only on the edit form? Let's find out!

---
## [oshi97/olivershi.io](https://github.com/oshi97/olivershi.io)@[d6af50798d...](https://github.com/oshi97/olivershi.io/commit/d6af50798de5ba76b7fb1aa91d3e78b76277f784)
#### Saturday 2020-02-08 23:51:22 by Oliver Shi

dont import the universe of core-js

optimally speaking the import should only appear when it's used but that makes something that should make my life easier a fucking pain in the ass so this is a compromise I guess

---

# [<](2020-02-07.md) 2020-02-08 [>](2020-02-09.md)

