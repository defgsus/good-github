# [<](2020-06-17.md) 2020-06-18 [>](2020-06-19.md)

2,652,456 events, 1,230,181 push events, 2,006,867 commit messages, 158,256,905 characters


## [seanptmaher/simde](https://github.com/seanptmaher/simde)@[5e751926c3...](https://github.com/seanptmaher/simde/commit/5e751926c323bd8481fb1a15347c43b48d841048)
#### Thursday 2020-06-18 01:12:37 by Sean Maher

Add implementation of reinterpret

this is implemented via memcpy, which, honestly, is a pretty god-awful
way of doing this. However, the way I wrote the file means that if
there's a way to do this better, all that I have to do is swap out
three lines and it generates the code properly.

---
## [NotTacoz/PokemonProject](https://github.com/NotTacoz/PokemonProject)@[6bd4df3c33...](https://github.com/NotTacoz/PokemonProject/commit/6bd4df3c33c484f4031cf09613987a1f350e9db1)
#### Thursday 2020-06-18 01:23:47 by Tacoz

epic types

kill me pls
i seperated the types
just change the class
and it would be gucci
anyway guys i hate my life now
imma go commit die
tyty

---
## [Zowayix/Meow-Launcher](https://github.com/Zowayix/Meow-Launcher)@[e91102c8bc...](https://github.com/Zowayix/Meow-Launcher/commit/e91102c8bc0e064ed6ca8b6fbab27069598f2515)
#### Thursday 2020-06-18 05:25:47 by Megan Leet

Yeah nah hang on that does improve speed but it fucks m3u shit so never mind that until I rework it

---
## [rzero9/mame](https://github.com/rzero9/mame)@[6c368779d0...](https://github.com/rzero9/mame/commit/6c368779d088a3eae501fcd438ba02d199f1a1f7)
#### Thursday 2020-06-18 08:35:45 by r09

fmtowns_cd.xml: 11 new dumps, 6 replacements

- New dumps from redump.org (working):

Akiko - Premium Version
Curse
Gambler - Queen's Cup
Gokuraku Mandala
Iris-tei Serenade
Marionette Mind
Mirage 2 - Torry, Neat & Roan Fairladies in MagicLand
Noushuku Angel 120%
Shamhat - The Holy Circlet (FM Towns Marty version)
Two Shot Diary

- New dumps from redump.org (not working):

True Heart

- Replaced entries with dumps from redump.org:

Alshark
Branmarker 2
Dragon Knight 4
Gunblaze
Lesser Mern
Princess Maker 2

---
## [rzero9/mame](https://github.com/rzero9/mame)@[4cc2ccddaf...](https://github.com/rzero9/mame/commit/4cc2ccddaf4ab88433e6659f6ee64b498be74ede)
#### Thursday 2020-06-18 08:44:42 by r09

fmtowns_cd.xml: 13 new dumps, 13 replacements

- New dumps from redump.org (working):

Akiko - Premium Version
Curse
Gambler - Queen's Cup
Gokuraku Mandala
Iris-tei Serenade
Marionette Mind
Mirage 2 - Torry, Neat & Roan Fairladies in MagicLand
Noushuku Angel 120%
Shamhat - The Holy Circlet (FM Towns Marty version)
Tenshin Ranma
The Manhole (1990-08-01)
Two Shot Diary

- New dumps from redump.org (not working):

True Heart

- Replaced entries with dumps from redump.org:

Alshark
Branmarker 2
Dragon Knight 4
Eimmy to Yobanaide
Evolution
Gunblaze
Igo II
Lesser Mern
Princess Maker 2
Rayxanber
Vastness - Kuukyo no Ikenie-tachi
Youjuu Senki 2 - Reimei no Senshi-tachi
Zenith

---
## [Cezerin2/cezerin2-store](https://github.com/Cezerin2/cezerin2-store)@[ee061e10aa...](https://github.com/Cezerin2/cezerin2-store/commit/ee061e10aa8fb073fcb2db583d812f169ef3c6e3)
#### Thursday 2020-06-18 09:32:28 by Himadu2000

Minor fixes (#101)

* Removing Fragment

* Moving Export

* Update index.js

> I see this. Looks good.
> But my opinion we does not do "refactoring for refactoring", we need more focus to stable release.

Oh yeah thanks, this pull request was intend to improve performance, and to make it easier to my other updates which is coming soon. Which mostly will be typescript fixes. Also congratulations on your promotion.

---
## [nastyatimosha/hitbtc-api](https://github.com/nastyatimosha/hitbtc-api)@[bdc00812de...](https://github.com/nastyatimosha/hitbtc-api/commit/bdc00812de97b2d4249c0304f07ff426533f4b5a)
#### Thursday 2020-06-18 10:20:35 by nastyatimosha

Update CHANGELOG.md

THIS EXCHANGE IS A SCAM!!!! DONT SEND YOUR MONEY TO THIS GARBAGE EXCHANGE!!! THEY BLOCKED MY WITHDRAWALS WITHOUT REASON!!

as you are ignoring my messages.. i am making screenshots and sending them to Coinmarketcap, Coingecko and coinpaprika!! as you ignore me, you are giving me more proofs to they see the scam you are!!!! you blocked my withdrawaks without reason!!! you can see attached to this mail my complains!!

I am sending now complains to Coinparika and Coinmarketcap!! attached to this message you can see the screenshot!! i will make a lot of noice for this SCAM!!

what the hell is this??? why you suspended my withdrawals???? you are a fucking SCAM!!! rippers!!! is my money and you dont have rights to hold or keep my money!!!! i am writting right now a complain to COINMARKETCAP, COINGECKO AND COINPAPRIKA!! I also will write complains in crypto forums as Bitcointalk and Cointelegraph!!! you are rippers!! scam!!!

---
## [mrakgr/The-Spiral-Language](https://github.com/mrakgr/The-Spiral-Language)@[929110744a...](https://github.com/mrakgr/The-Spiral-Language/commit/929110744a6eedf31d6e9cd33fa67cbd41eceadd)
#### Thursday 2020-06-18 11:35:45 by Marko Grdinić

"9:30am. I am up. Let me chill a bit.

9:55am. Tying up some loose ends.

10:30am. Doing Reddit posting. Since I feel like talking how about I resume the review? I left off yesterday at an cliffhanger. Now let me deliver.

///

It is almost the midpoint of 2020. Let me do a review.

It the start of the year I remember being despondent over math. In 2019 I spent a lot of time studying formal proofs, but in the end that turned out to be of limited use. When the time came to actually try out those skills by translating some of the ML paper proofs came, I ended up reaching for randomized testing in favor of dependent types. As time consuming as writing the generator for that CFR paper proof was, it was still much easier to deal with than Agda.

I went through Software Foundations, but not even once have a I done a proof where the proof assistant actually assisted me in getting an understanding of the program. In practice, when I met the harshness of the real world the pretensions of type theory were swept away by the practicality of the lesser styles of programming. I was really hoping that I'd get better math skills out of learning formal proofs, but the kinds of things I got better at weren't actually the kinds of things I'd hoped to get better at.

Back in January I wasn't actually sure what the next step in my journey should be. For a few dark days, I'd honestly considered Python, but that would be a complete defeat as I'd have to abandon the style I had so carefully nurtured for years.

Thought I've fallen far short of my aim with reinforcement learning, Spiral itself was a success. As a language it is innovative, powerful, expressive and efficient. It really is the perfect bridge between high level platforms with GC such as .NET, and low level ones that require manual or no memory allocation such as Cuda. It makes it truly easy to compile to and interoperate with not just one, but a whole stack of languages.

Its virtues cannot be denied. Yet back in January 2019 I was fed up with it as it was so tedious to use. At first I was in love with its power, but once that faded I began to really feel the pinch of how much work it is making me do. The main problem with Spiral in that in removing the restrictions of F# which I based it on and moving from top-down to bottom-up type inference while I gained power, I also lost what made F# so nice to program in.

Therefore, I resolved to get those things that I left behind back. I could not do it back in 2018, but once I started the ideas kept coming to me. Maybe the one year hiatus where I did math and other assorted things helped brew the next version in my subconscious. I'd like to think so. If that is the case, maybe 2019 was not a complete waste of time.

That brings us to 2020. In order to make Spiral as nice as F# to use I need to tap into its main strength - top down type inference. Though top-down (via unification) and bottom-up (via partial evaluation) are fundamentally different, there is also a lot of overlap. And I have an understanding how to integrate the two now. If it were just type inference though, I would have been done by now. I already did a redesign in January and since then the language implementation has just been collecting dust waiting for that to come.

Besides top down type inference, I also want editor support. Learning the prerequisites to that has taken the entirety of my time since the start of February up to now. In fact, I am done just now and after I finish this review I will finally be able to start work on that.

Back in February I set figuring out how to do editor support as my goal. I tried doing sensible things like studying other plugins, studying the language server parts of the VS Code API, studying web frameworks (for insight on how to connect disparate systems), JavaScript, TypeScript along with basic web knowledge...things of that nature. The end result of the first two and a half months of that is that it was a waste of time. The turning point came for me when I remembered the reactive extensions stuff I did in Scala back in 2015.

Basically, since February up to that point, my mentality for lack of insight was that I needed some kind of framework to connect VS Code which is Typescript + Node.js to the eventual Spiral language server which would be written in F#. And it was quite perplexing at how that simple goal was so difficult to attain. It was so difficult that I was essentially wandering through the landscape studying arbitrary things.

Since the turning point, a certain awareness grew on me. I realized that yes, you can for example learn web development by learning JS,TS and picking up some framework. But those things are trivial. To actually be good at web development, you need to be good at managing its complexity. And for that you need to understand concurrency. Not necessarily at the low level, but instead what you need to understand is how to us abstractions like the [reactive extensions](http://introtorx.com/). And as luck would have it, being good at Rx will also make [doing UIs](https://github.com/mrakgr/Lithe-POC) significantly easier. I was amazed at how once I sat down and tried it, doing the MVU pattern came quite easily to me. I was quite astonished that getting the elegance of Elm does not require a specialized language, nor a library like [Fabulous](https://fsprojects.github.io/Fabulous/). A bit of skill at handling reactive combinators is all that was needed and the organization capability it gave me more than made it worth studying it. They are so useful and it is possible to use these skills anywhere.

This gave me the courage to instead of looking for shortcuts, to try studying the VS Code editor directly. Having the confidence that I would not have to code monkey my way through the challenge in front of me I tried seriously studying the samples and this time they work [came to me](https://github.com/mrakgr/vscode-extension-samples). As it turns out, seriously studying the LSP stuff was a huge mistake and it became very quickly clear after I picked the right path that the LSP samples and the library powering them are just a large mass of useless boilerplate.

At this point, chronologically the story was early May. At that point I knew Rx and I knew VS Code so on paper it seemed like I had everything I need to start work on editor support. For the first time I was confident that it could work and so I gave it a try. But I hit a snag.

You'd imagine that it would be easy to do something like connect two different programs on the same computer and have them send messages to each other. On Node, I found the `node-ipc` package, but very quickly on the .NET side I realized things were more complicated. Rather than giving me some kind of message passing library, in the .NET standard library there are low level sockets which act as streams. This to me felt like a really bad idea, and right at the outset I decided that spending my time doing my own network protocols is not how I want to roll. Very quickly, I discovered [ZeroMQ](http://zguide.zeromq.org/). And I spent a few weeks translating the examples from the guide to [F# + NetMQ](https://github.com/mrakgr/Lithe-POC/blob/f34d9c91c9e5966208c1099fe05779cc9516e80f/Lithe%20Avalonia%20Examples/05_NetMQ.fs). I was quite excited to finally break my CLI dependency and Rx really paid off for me here - yeah, I know I seem to be complaining in the comments to that file, but in general the whole thing came out great. Towards the end I just ran out of steam to redo the example properly. The example is a great contribution to the Lithe repo and really showcases F#'s ability to do functional abstractions. From here on out Avalonia will be my UI library of choice.

At this point, the story is close to the present time. After becoming familiar with the distributed computing capabilities of ZeroMQ/NetMQ, I gave editor support another try. I did not actually want to try the whole language right away, instead in v0.2 what Spiral will have is its own config files. Its functionality is isolated from the rest of the language and I wrote [the parser for it](https://github.com/mrakgr/The-Spiral-Language/blob/ae6b4d158de338028d82ee86a746e48852a74d0e/The%20Spiral%20Language%20v0.2/Config.fs) a few months ago. As a little showcase of ZeroMQ in action, here is [the Node client](https://github.com/mrakgr/The-Spiral-Language/blob/ae6b4d158de338028d82ee86a746e48852a74d0e/VS%20Code%20Plugin/src/index.ts) and the [F# server](https://github.com/mrakgr/The-Spiral-Language/blob/ae6b4d158de338028d82ee86a746e48852a74d0e/The%20Spiral%20Language%20v0.2/ConfigServer.fs). The examples are small and isolated enough to study for anybody else considering doing this. If you run the client and the server, you will see that the plugin will activate and the editor will actually show errors in the config file with red underbars where they are relevant. It is quite nice.

Having done that, I was almost ready. Almost. Originally, I thought that I could design the compiler pipeline as an observable and use reactive extensions to power it. But, even though it worked so well for me with GUIs, once I sat down to actually try and prototype it in the small I very quickly saw issues with my original scheme and realized that reactive push concurrency (the kind championed by Rx) is actually a bad fit for my use case. Thankfully, when I study I made sure to do it broadly, so very soon after I realized that my original plan is poor, I realized what would be a good fit for doing editor support for a language.

[Hopac](https://github.com/Hopac/Hopac) is probably the greatest F# library nobody ever heard about. The [CML style concurrency](https://youtu.be/pf4VbP5q3P0) it offers is much more expressive than what what actors would offer and a clear fit for different kinds of needs a language server would require. As an intro, from the CML book I translated some of [the examples to Hopac](https://github.com/mrakgr/The-Spiral-Language/blob/ae6b4d158de338028d82ee86a746e48852a74d0e/The%20Spiral%20Language%20v0.2%20(typechecking)/HopacExample.fs). And I am done with the prototype for [the language server](https://github.com/mrakgr/The-Spiral-Language/blob/ae6b4d158de338028d82ee86a746e48852a74d0e/The%20Spiral%20Language%20v0.2%20(typechecking)/Prototyping.fs).

With this everything is finally set. I have all the skills that I need to not code monkey this part of the process.

I've spent 4.5 months building up the prerequisites to finally start work on this and my reward is that I can now start. I really wish somebody could have just pointed me at ZeroMQ, Rx and Hopac back in February. I really wish that I'd put in more effort into actually understanding Rx back in 2015 rather than brainlessly doing the Scala course exercises. It really would have made a difference not just now, but even back in 2016 when I code monkeyed that poker app and concluded that UIs were not worth it. They are worth it now.

I wish I was crushing the online gambling dens rather than working towards an upgrade to my programming language, but I can at least take solace that this is not like trading. Programming is the most fundamental of all skills in existence. If you are not sure what to pick - you can't go wrong with programming, that is for sure. Not if you do it right.

Ultimately, AI skill will boil down to programming skill with some math sprinkled on the side. And once the required level is attained, investment when it happens sure won't be in the stock market. Back in my trading days I might not have won, but I haven't lost to the market either. I sure made up for that by fucking myself in the usual fashion by figuring out the self improvement loop. Obsoleting something I practiced at for over half a decade gave me some damage.

---

In 2014, I wrote Simulacrum mostly because the concept of the self improvement loop inspired me. It was like a declaration of victory; the proof that I understood it. Afterwards, since nothing is perfect one of the things I wanted the most is to get some criticism on that aspect, but disappointingly that has not come which left the task of advancing the philosophy behind it to me.

I do not have the time to resume Simulacrum itself, but let me in this review advance what was said so many years ago. The issue with that I wrote, is not that it was wrong, but rather that it was not enough. Going from the humanist to transhumanist conception of life and death is mind-bending, but even if one internalizes and accepts the perspective, in the end he will just be left stranded. What is the problem? The are two main criticisms:

First, the self improvement loop as is depicted requires fantastic hardware that does not exist in the current era. Brain cores and mind uploading are prerequisites before one can even start. What can one do on the current era CPUs and GPUs? Not much. And that part really kills me inside. This part was obvious to me or anybody reading the story back then so I won't belabor it.

Second, it is too selfish. It leaves too much utility on the table. This part is not so obvious and requires an explanation. To make my case, as a thought experiment let us once more consider the context where brain cores and mind uploading is ubiquitous. Imagine you are an agent on a brain core. According to the 2014 philosophy, the way forward is clear - make proper use of backups, tweak yourself and gain power. That is the essence of self improvement. Why would you do anything else?

But suppose you were on a brain core and had a hard restriction against tweaking yourself personally. In order words, let us assume that self improvement is off limits for the duration of this thought experiment. Then you have the brain core and are on it, but are in a paradoxical situation where you cannot get any power.

So what can you do in that situation? A lot of programming for one. You can play games on the brain core. Being human level on the brain core means that there is a lot of space to fill, so you the 100 IQ peon can run your favorite family of 2045-era ML algorithms and create a 300 IQ superhuman agent to play it.

What use is that? According to the me of 2014 nothing. The skill and the power belong to the other guy. I mean, that much is clear. It would be obvious that you are not the one playing the game, not the one getting better at it and that the power is not yours personally. That loneliness of the programmer is something you could clearly feel.

If I could put in a word the essence of that feeling it would be - cheating.

From the perspective of power what you are doing is clearly cheating. It is always like this - suppose you have a 100kg boulder that you need to move somewhere. If you pick it up and move it then that proves you are strong. If you use a machine to do it, then you've just moved an item from A to B. It is nothing.

This captures the humanist perspective of power.

It defines the boundary of what is one's own power, and what is merely using other people and machines. It defines what measures one's own self worth and merit, and draws a line between that and the rest.

It is the enemy. It is not worth protecting. The transhumanist perspective on life and death is not enough. The transhumanist perspective on power is needed to make the next step. Because you otherwise end up in a strange situation where you have the full power of the brain core at your disposal, but thanks to a minor restriction cannot make its power your own and can only cheat and 'program' it. And not being able to edit yourself would in fact be a minor restriction assuming you can control everything else. It would not be a big deal to wrap yourself up and insert yourself as a part of the hierarchy along with that superhuman agent. Then you want to route the game inputs to it, and leave the domain of the overall strategy to yourself. You'd have some blank spots in your memory compared to if you were taking the fully integrated approach, but that is fine. The subunits in your own brain do not have full integration, but that is in the end a benefit. It is just proper delegation.

As you dive into programming it always becomes about moving things from A to B and never about your own power. But that is not the fault of programming. The culture and your own instincts are just lying to you. It is the future and these thought experiments that tell the truth.

If you were on the brain core, you'd never let a restriction like this hold you back. As long as there is a way to interact with the core you'd find a way to make its power your own. And then you'd be able to look back and see that in fact whether or not you are on the core makes little difference in the grand scheme of things. The latency and the throughput bottleneck for data is more severe if you inhabit meat space, but there should never be any difference in to whom the power belongs.

With the transhumanist conception of power, there should never be any doubt which was is forward. It should be plain for anybody to see, that even without personal access to the self improvement loop, that having access to other agents cannot be useless.

More broadly, replace **other agents** with **arbitrary programs** and you get to the meat of things.

Just like humanist conception of life and death restricts access to the self improvement loop, so does the humanist conception of power place a boundary between self and technology that acts as a brake on development. Because of that conception, you can never treat programming as a directed effort towards attainment of power, but can only treat it as work or hobby.

Even worse it turns AI development into some sort of a trade with an alien entity rather than a continuous process, and produces mental disease the exibit of which is the AI risk industry. Honestly, I am guilty of this too. I knew that the whole AI friendliness thing was a scam, but I haven't been able to elucidate the proper view against that kind of stupidity. It was recently that I realized that in order to find the perspective all I had to do was not rush towards self improvement, but make an irrational restriction instead.

If it looks like prescience, it was only because the right choices all follow the gradient of power. As I long as I fought that kind of slave morality, it was inevitable that the idea would come to me and release me from my shackles. In 2014 I would have found the concept of self improvement impossible to just let go. But after doing it for 5 years, I think now I have an idea of what programming should be.

Ultimately, programming is all about imagination.

---

Let me talk about current day ML next.

Basically, up to this point, I had the 2015 mentality where my goal was to use deep RL + GPUs to make that single model poker agent. GPUs are honestly massive dissapointment when it comes to RL and are clearly the wrong piece of hardware for that particular task. They can pass muster for supervised learning, but RL has different requirements.

Let me bring up some points in how RL differs from SL.

1) Just adding depth and more parameters does not result in better performance.

2) There are stability issues due to sharp policy moves.

These might be due to...

3) Variance of rewards.

4) State aliasing.

5) Off policy learning.

Regarding that first one, yes, the human brain does unsupervised or self supervised (whatever that is) learning in order to better make use of available data, but that is not the reason why your 2 or 3 layer nets has the stability of nitroglicerine.

In 2018, I spent a lot time looking into natural gradient methods, but in the end they are nothing more than a band aid. In order to get faster learning you want to do frequent updates with high learning rates. That however always comes at the cost of stability and even if you apply KFAC, you'll always need high identity coefficients for the covariance matrices which will degrade the methods towards first order. I've tried all sorts of tricks, but a lot of the things that work in SL, just die in the RL regime.

I've long pined for a method which does credit assignment better than backpropagation - in 2019 that was my main motivation for studying formal proofs and type theory. I still think something should exist, but right now backprop feels as solid as a mountain. I do not want to try tackling it directly anymore.

Once I finish Spiral v0.2 and get my hands on those fresh-of-the-press neurochips, I want to try something different. In January 2019 I came up with that idea of using ensembles for curiosity directed exploration. At that point I was tired of the difficult programming the old Spiral was forcing upon me, so I never tested it. But going in this direction should be worth taking up.

It wasn't necessarily horrible for me not have tested it though.

The GPUs would be just horrible for this sort of thing. Like, I already was not doing any kind batching so that exposed horrible latency issues that GPUs have with games if you use them naively. Adding parallel layers would just have exacerbated those issues. For example with GPUs, training 32 layer nets in parallel would not be that much different from training a single 32x jumbo sized net. That is if you saturate the memory system enough to make fetching from the main memory a bottleneck. This would generally be the case models of realistic size.

However, it should be obvious that with the right hardware, training 32 nets in parallel should take just as much time as training a single one. This is what I want and what I should aim for.

Training an ensemble in an online fashion which the scenario real world ML systems face is the worst case situation for GPUs. GPUs might have been the driver behind the deep learning boom, but they are now the bottleneck that prevent us from doing research into more promising areas.

I was busting my head in 2018 trying to make the nets sufficiently roboust using all sorts of semi-second order methods, but probably the best way to attain that stability is to use an ensemble. What would be a sharp policy moves for a single model network, might be a smooth one for a group of them.

This would also expose all sorts of metalearning opportunities. With a single model all you have is that, but with an ensemble you have a probability distribution. Remember [Reptile](https://openai.com/blog/reptile/)? If you let some nets in an ensemble be static, that would just be linear crossover. Moreover, in offline RL, letting one net be static for use as an target net is already an application of ensembling.

Is is good science. If you do not view your job as being to find the best single model, you can take a more Darwinian approach to things and let the data itself decide. You don't ever want to glue yourself to a single hypothesis. Moreover, I am just about ready to accept that learning is NP Hard. Deep RL is more indicative of how difficult real world learning is than supervised learning. Even when something better than backprop is found, there will never be an algorithm so good as to displace all other approaches regardless of the domain. Diversity will always be a low hanging fruit needing to be picked.

I should be trying out ensembles, ensembles large enough to be a swarm.

Lady Luck won't smile on those who just think. One must act.

The 20s will be a different time from the 10s. I will find my power.

///

1:35pm. Let me have breakfast. Every day I have it later and later."

---
## [KathrinBailey/Skyrat13](https://github.com/KathrinBailey/Skyrat13)@[dc424ab33d...](https://github.com/KathrinBailey/Skyrat13/commit/dc424ab33d3aa0cf9de7de90bfb1f59763690e6e)
#### Thursday 2020-06-18 13:26:40 by KathrinBailey

fixes cocksink

gosh these new sprites are fucking awful.

---
## [LunarWatcher/Taskranger](https://github.com/LunarWatcher/Taskranger)@[0417b602d9...](https://github.com/LunarWatcher/Taskranger/commit/0417b602d9b48b458de6490d0dd0ba97a8be9158)
#### Thursday 2020-06-18 13:52:30 by Olivia Zoe

Fuck you Microsoft. Learn to make some better fucking software

---
## [mrakgr/The-Spiral-Language](https://github.com/mrakgr/The-Spiral-Language)@[d34d44f7ab...](https://github.com/mrakgr/The-Spiral-Language/commit/d34d44f7abe805d701c5282dbb5ef2eba8dc62f5)
#### Thursday 2020-06-18 14:33:04 by Marko Grdinić

"2:20pm. Done with breakfast. Let me read Scarlet's novel for a while. There is not much out so I should catch up quickly.

https://mangadex.org/title/38088/may-i-please-ask-you-just-one-last-thing
Alternative title: The B*tch Who Punches Everybody

I found this a few days ago and it is amazing. The bitch is undeserved - she is a classy lady.

3:05pm. Kengan Omega and then I start.

I need to do at least a little today. Just the review is not enough. I'll be laid up over the weekend so I want to conserve some time.

3:15pm. Done slacking. Let me focus now.

Spiral v0.2 starts here.

4pm. Er, I had to take a 45m break due to a distraction.

4:10pm. It is no use, I am completely distracted.

4:20pm. This is not going to work. In the past two days, my mind has been entirely on the review. Even though it is the time to start, I hadn't spent any time at all charging myself for the task at hand.

4:25pm. I think I'll step away from the screen for a while. Since my thoughts are distrupted to this degree, I need to find my center.

The way things are going, I am not going to be doing any programming today. Instead I should just focus and crystalize the first step in my mind.

To be honest, I am not sure if I want to just plugin the current version of the language in to VS Code as I planned, or whether I want to start the redisign right away. I should settle that mentally.

On paper it does not seem like it is anything important, but trying to do a thing without fully commiting to it is a mistake."

---
## [ananyasaigal001/CPT](https://github.com/ananyasaigal001/CPT)@[24620499d5...](https://github.com/ananyasaigal001/CPT/commit/24620499d54415c0295c8e632edcd5c2001f8dfd)
#### Thursday 2020-06-18 16:40:54 by ananyasaigal001

Choose your own adventure story

The story focuses around how people, society, and social media can force people into depression. It shows why it is important to share your problems, with your loved ones or anyone who can help. Also how the support of family, friends, or teachers can help a person battle with depression. If the person does not get appropriate support and help, sometimes that can lead the person to take extreme steps.The story explores the idea of how many times a person is ready to speak about their depression or give various indications of their pain but we as a society have to learn to listen. It also shows the sad truth of how sometimes getting help can also not help.

---
## [1995parham/dotfiles](https://github.com/1995parham/dotfiles)@[d03d326888...](https://github.com/1995parham/dotfiles/commit/d03d326888a009fe75e7c4dc1dc81cdf1a36b5fc)
#### Thursday 2020-06-18 17:29:38 by Parham Alvani

feat: Fuck you Mr.Trump because of these sanctions

---
## [SunnyRaj84348/android_kernel_xiaomi_msm8917](https://github.com/SunnyRaj84348/android_kernel_xiaomi_msm8917)@[30adf94c1f...](https://github.com/SunnyRaj84348/android_kernel_xiaomi_msm8917/commit/30adf94c1fcce679a50ebc4f597c6865f3d2dafb)
#### Thursday 2020-06-18 17:48:09 by J. Bruce Fields

nfsd: allow fh_want_write to be called twice

[ Upstream commit 0b8f62625dc309651d0efcb6a6247c933acd8b45 ]

A fuzzer recently triggered lockdep warnings about potential sb_writers
deadlocks caused by fh_want_write().

Looks like we aren't careful to pair each fh_want_write() with an
fh_drop_write().

It's not normally a problem since fh_put() will call fh_drop_write() for
us.  And was OK for NFSv3 where we'd do one operation that might call
fh_want_write(), and then put the filehandle.

But an NFSv4 protocol fuzzer can do weird things like call unlink twice
in a compound, and then we get into trouble.

I'm a little worried about this approach of just leaving everything to
fh_put().  But I think there are probably a lot of
fh_want_write()/fh_drop_write() imbalances so for now I think we need it
to be more forgiving.

Signed-off-by: J. Bruce Fields <bfields@redhat.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
Signed-off-by: Lee Jones <lee.jones@linaro.org>
Change-Id: I9bc2a8ae176f4200d060bbe88c82e1ae7cb9449e

---
## [gruppe-adler/grad-civs](https://github.com/gruppe-adler/grad-civs)@[2b047fd09e...](https://github.com/gruppe-adler/grad-civs/commit/2b047fd09ed79c107732fb588f8f919fb851efc4)
#### Thursday 2020-06-18 19:22:37 by Moritz Schmidt

create basic addon structure

add cba include

add 'common' component

create legacy module

wip move functions

add XEH_PREP

copy macros, remove package.json

adjust function name prefix

QFUNC

FUNC

fn => fnc

adjust macro include: component.hpp => script_component.hpp

initialize CBA settings. oh, and stop asserting ACE. we're a mod now. we've got other ways to express our dependencies. Oh yeah baby.

update README: eliminate much of the config and howto part

facepalm

ignore PBOs

wip

ugh, review this change plz

remove LOGTIME macros. use the profiler instead, its far more powerful

fix config getter

GVAR(LOCAL_CIVS)

CBA settings stuff, also: remove GRAD_CIVS_ENABLEDONFOOT etc

remove GRAD_CIVS_STATE_BUSINESS

wip

wip main module

gixup

yo first module gui exists

ugh fix b0rked shit

ugh agh

test test testi test

omg so much wip, everything at once.

move statemachine modifications into extra addon

more modules

mooove shit!

lalala

wip

wipwip. event for statemachines ready

remove from legacy what is already in voyage

wip

fix settings init

fixfix

missing #include, fix ChatTime

fix neighbor cooldown setting

fu fix conigf

CBA settings menu works again, yay

among other things: loadout in extra module

fix event module

some global var fixing

add README for mimikry

mimikry module: player interactions

QEGVAR some  civ interaction events

fixup complete mimikry

dont postInit anything if mod disabled

oops

fixfix

fix

shorten config descriptions

oops

setVehicles

missing includes

fix state machine calls, move mucho into own addon

wip fix statemachine access

move file

hopefully better state access, me thinks

complete gitignore

ficxfix

do init!

facepalmierung

fixfix

fix, add config for corpsemanager mode

Update fnc_initConfig.sqf

spawnOnlyWithPlayers flag

:dancer:

fix

fix module interactions

move vehicle funcs, remove vehicle parameter from civ group spawn

remove static civs & cars functions.

functionality is really nice, but it feels disconnected from how grad-civs works otherwise; especially the static cars have no connection to any other functionality.

I'm removing the (probably broken anyway) feature right now. Might re-add later.

Update README.md

some FUNC -> EFUNC, fix global animaltransport chance, LOCAL_CIVS => localCivs

EFUNCs in patrol addon

resident EFUNCS, chiefly

ugh

oops. scalar setting ofc

Update fnc_addCarCrew.sqf

Update fnc_sm_lifecycle_state_spawn_enter.sqf

Update fnc_civAddLoadout.sqf

sort config categories

fix default config val, fix missing onspawn handler

oops

yay

syntax fix

GVAR/config fix

ups

dont despawn if civs are allowed on empty server

wild. register civ task types

wild

facepalm

fix showWhatTheyThink

---
## [Khushisomani/codes](https://github.com/Khushisomani/codes)@[106f8f242b...](https://github.com/Khushisomani/codes/commit/106f8f242b3bd7823f4461b4a9dd7d294305b6b3)
#### Thursday 2020-06-18 19:52:02 by Khushisomani

Chef and String 

There are N students standing in a row and numbered 1 through N from left to right. You are given a string S with length N, where for each valid i, the i-th character of S is 'x' if the i-th student is a girl or 'y' if this student is a boy. Students standing next to each other in the row are friends.

The students are asked to form pairs for a dance competition. Each pair must consist of a boy and a girl. Two students can only form a pair if they are friends. Each student can only be part of at most one pair. What is the maximum number of pairs that can be formed?

---
## [saqib-ali/hivemined](https://github.com/saqib-ali/hivemined)@[75305b3721...](https://github.com/saqib-ali/hivemined/commit/75305b372117e513cc29b72d3ed4a6e75dcc75b3)
#### Thursday 2020-06-18 23:44:45 by Saqib Ali

Job @ uptodate Ventures (Munich): Data Analyst / D... | JOIN. Job @ uptodate Ventures (Munich): Data Analyst / D... | JOIN. “Laplace’s Demon: A Seminar Series about Bayesian Machine Learning at Scale” and my answers to their questions «  Statistical Modeling, Causal Inference, and Social Science. Data Analyst II – 1000ml – Train &amp; Verify. Actuarial Data Analyst – 1000ml – Train &amp; Verify. ateeca Business Data Analyst | SmartRecruiters. Data Analyst – Claims Data, Electronic Health Records, 0-3 years experience – 1000ml – Train &amp; Verify. Data Analysis Software Developer / Postdoc (m/f/d) - Machine learning / Artificial Intelligence, Garching bei München, Jülich Centre for Neutron Science (JCNS), auf dem Stellenmarkt von jobs.pro-physik.de. “Laplace’s Demon: A Seminar Series about Bayesian Machine Learning at Scale” and my answers to their questions «  Statistical Modeling, Causal Inference, and Social Science. East Tennessee State University Employment Site | Technical Data Analyst to TN State Agencies.

---

# [<](2020-06-17.md) 2020-06-18 [>](2020-06-19.md)

