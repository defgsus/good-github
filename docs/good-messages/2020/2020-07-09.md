# [<](2020-07-08.md) 2020-07-09 [>](2020-07-10.md)

2,491,959 events, 1,225,273 push events, 1,998,731 commit messages, 150,853,443 characters


## [fuglore/PD2-Hyper-Heisting](https://github.com/fuglore/PD2-Hyper-Heisting)@[63e9364136...](https://github.com/fuglore/PD2-Hyper-Heisting/commit/63e93641362de18f9ab93560304580a84fd636c8)
#### Thursday 2020-07-09 00:17:25 by Fuglore

aw yeah baybee fixed some shit i think

- fixed cops surrendering due to broken lonewolf functionality

- fixed various issues with coplogictravel

- fixed coplogicattack being horrible up to a point

---
## [Mielein/AlgoDat-Ass4](https://github.com/Mielein/AlgoDat-Ass4)@[b65f80d6e9...](https://github.com/Mielein/AlgoDat-Ass4/commit/b65f80d6e9f218fa598e9e462b4d88f48b2e7f79)
#### Thursday 2020-07-09 01:44:21 by YoFionn

Ach man, fuck it, das läuft einfach nicht .. fuck you franchesco, ich schick das jetzt ab

---
## [a2aaron/chess](https://github.com/a2aaron/chess)@[faf85c183b...](https://github.com/a2aaron/chess/commit/faf85c183b9a2930d79ad28c52253084b15d03ad)
#### Thursday 2020-07-09 02:06:20 by Aaron Kofsky

Make VStack and HStack more generic so that I can rip out impl Layout from Selector

This Kinda Big commit does four main things

1. Removes the Layout impl from Selector
   This was done because I don't want the Selector to worry about having to
   lay out its buttons--if I did do that, then Selector would start to
   basically be a copy of all the code in VStack/HStack, and it would make
   it hard to do Weirdly Shaped Selector Layouts (Selectors where the buttons
   might be in a grid, or some other fancy shape).

2. Make VStack and HStack take a type parameter for what type its children are
   This was done as a consequence of change #1. A Selector owns a Vec of
   Buttons, and I want to pass those buttons into a VStack or HStack to do
   layout, but I can't simply do something like `selector.buttons.as_mut_slice()`
   because H/VStack's children are `&mut dyn Layout`, and `&mut dyn`s have
   a different internal structure than `&mut` (specifically, `&mut` is just
   a pointer, while `&mut dyn` is a pointer + a pointer to a vtable so that
   the type can be resolved).
   I can easily convert the `Vec<Button>` in `Selector` to something like
   `Iterator<&mut Button>`, but to go from `&mut Button` to `&mut dyn Layout`
   requires an annoying `selector.buttons.iter_mut().map(|b| b as &mut dyn Layout).collect()`.
   Instead, we change VStack and HStack be able to take any `&mut` slice
   of  `Layout`able children. We add a type parameter to Stack called `Child`,
   which defaults to `&mut dyn Layout`. This parameter is `Layout + ?Sized`,
   meaning "Child implements Layout and might be unsized". This lets us
   simply borrow the Selector's button directly.

   Note that we must add `?Sized` to a bunch of impls as, without it, `Child`
   defaults to being `Sized` (hence if we neglect it, then for any unsized
   `Child`, such as `dyn Layout`, we won't be able to have that impl!,)

3. As a result of #2, most `VStack` are now `VStack<&mut dyn Layout>`, however,
   `&mut dyn` pointers do not auto-deref (meaning you can't do stuff like
   my_layoutable.layout() because &mut dyn Layout literally doesn't have that
   function, and normally a &mut Layout would just put enough *s or &s until
   it works). Fortunately, this is easy to fix. We add an impl of `Layout`
   for `&mut dyn T` which just delegates to `T`

4. We also add some macros for V and HStack to make them more easily. Note
   that we have to use a macro here because if we don't, Rust will complain
   that slices passed into a function will not live long enough (this is
   because Rust doesn't know when it's okay to automatically extend the
   lifetime of a temporary object across function calls, but it can figure it
   out for the struct literal syntax).

This Technically is View Controller (no model yet)

---
## [Thai-Morris/fta](https://github.com/Thai-Morris/fta)@[ed49f86457...](https://github.com/Thai-Morris/fta/commit/ed49f864572ae16b06184554d6965121d0660746)
#### Thursday 2020-07-09 03:54:50 by Thai Morris

fucking images folder

damn, I hate the fact I cannot just upload an folder.

---
## [OpenImageIO/oiio](https://github.com/OpenImageIO/oiio)@[a25c31af5b...](https://github.com/OpenImageIO/oiio/commit/a25c31af5b32fa0b6a6a74cd10b0876d9d43b74d)
#### Thursday 2020-07-09 05:17:01 by Larry Gritz

Terminal I/O of images (#2631)

This is a little kooky maybe, but it was something I was playing a couple
years ago, finally inspired by Chris to clean it up and PR it.

This patch adds a "term" format which, instead of writing files,
outputs a preview image to a true color text terminal window.

Is any of this useful? I have no idea. But it's kinda fun.

The quick demo of this is:

    oiiotool myfile.exr -o out.term

It will only do something useful if on a color terminal emulator with
24 bit color capability and Unicode. (I've tested it on the
gnome-terminal on Linux, and iTerm2 on Mac.)

The best quality results are on Mac if you are using iTerm2, it can
additionally do an actual pixel output (iTerm2 has as a nonstandard
feature the ability to send inline images to the terminal). This is
the "iterm2" method, but it's only expected to work on Mac with
iTerm2. It will automatically use this method as the default if you
are running iTerm2.

Next best is (thanks, Chris) is to display two pixels (vertically) in
each character cell, by outputting the Unicode "upper half block"
glyph (\u2508) with the foreground color set to the top pixel's color
and the background color set to the bottom pixel's color. This is the
default if you're not on a Mac running iTerm2. To demo (if you're on
have iTerm2 but want to see this method):

    oiiotool myfile.exr -attrib term:method 24bit -o out.term

But some terminals and fonts don't support unicode, or don't display
this character, or display it with an ugly border. So you can also use
an alternate method:

    oiiotool myfile.exr -attrib term:method 24bit-space -o out.term

where doesn't use the unicode trick but instead outputs a space (' ')
for each 2 vertical pixels, simply setting the background color to the
average of those two pixels.

There's also a "256color" method that just uses the 6x6x6 color space
in the 256 color palette -- which looks horrible -- and an
experimental "dither" which does a half-assed Floyd-Steinberg
dithering, horizontally only, and frankly is not an improvement unless
you squint really hard.

In all cases, the image will automatically be resized to fit in the
terminal, as well as converted to sRGB so it looks kinda ok.

Along the way, I added a new ImageOutput::supports("procedural")
query.  If the existing input supports("procedural") query says
whether the input image is being generated procedurally and doesn't
correspond to an existing file on disk being ead, then the output
supports("procedural") is the opposite -- is the output doing
something procedural that does not correspond to a file being written.
(The specific use is to use this to avoid oiiotool attempting to
rename the file to move it into its final position.)

Signed-off-by: Larry Gritz <lg@larrygritz.com>

---
## [PrismPrince/vue-cli](https://github.com/PrismPrince/vue-cli)@[44b066e2b3...](https://github.com/PrismPrince/vue-cli/commit/44b066e2b373e2bb2aff337df74453fad10f1c66)
#### Thursday 2020-07-09 08:08:26 by Simi Oluwatomi

docs: add hints on aliasing `winpty vue.cmd` (#2666) [ci skip]

Always remembering to use the `winpty vue.cmd create hello-world` syntax to create vue projects is kind of clunky as that is not the default syntax; someone like me will often forget.
Letting users know that they can alias the `winpty vue.cmd` command to something that feels more intuitive is better in my opinion.

---
## [mrakgr/The-Spiral-Language](https://github.com/mrakgr/The-Spiral-Language)@[4f71afec6e...](https://github.com/mrakgr/The-Spiral-Language/commit/4f71afec6e26e0cd3568ae720d06cbb8714a7f68)
#### Thursday 2020-07-09 08:53:39 by Marko Grdinić

"8:50am. Yesterday I forgot to check the VS Code slack channel for any replies. I'll do that in a bit. Right now, let me just chill.

9:35am. Enough slacking. I had a bit of fun, and now let me dive into my purpose. First off let me check the channel.

...Nothing there. Nevermind that. I guess I won't be compiling VS Code. I won't bother checking that channel anymore.

Honestly, the level of involvement from the devs when I ask them questions has been disappointing throughout. But give those 5k unsolved issues, I can understand their need to manage their time.

9:40am. Forget VS Code. Those sort of things will deal with themselves in due time. It is not my job to fix their shit.

What I should do is focus on the task in front of me - the parser.

9:55am. This will really be a boatload of work. It will take me weeks won't it? And even then I won't be done, I will be working on this for a long time.

Forget finishing this in the next week or two. Forget finishing it by the end of the year. This will take as long as it should.

My weakness is always that I want to get things out of the way to move to bigger and better stuff.

This time just sit down and do it properly.

Spiral v0.2 will be my greatest work, and it will also be an admission of my limits as a human.

Even though the real segment that lies underneath is what trully captures the essence of computation more than any type theory, on the surface it will be an exceedingly plain language.

There are such stories of nerds who become normies, and v0.2 is such an event for Spiral. But well, it needs it. The real segment is just too unusable at scale. I want to program in the simplest way possible in my next attempt at grabbing the Singularity. The really big idea of type systems is top-down reasoning about programs. I just cannot oppose it any longer.

This is something that is as pervasive as the air we breathe in today's programming ecosystem, but in a world where Spiral styled partially evaled type inference became the norm, top-down reasoning would have been absolutely radical.

10am. It is a pity, just imagine how much better the language could turn out had I the power of those future brain cores. The will I have now and the desire, they both pale in comparison to the kind of power the future agents will be able to throw around.

I have to work so much just to get a bare sliver of their power.

10:05am. It will be worth it.

Although becoming a normie is a death sentence for a human, I genuinely think that top-down reasoning is worthy of admiration. So a language being *normal* in this context is hardly something to be ashamed of. I really wish I could say the same about being a normal person.

10:15am. I have to find the power to do this one last time. Doing v0.2 will take me long, even after I finish it, I honestly don't thing I'll find the power to do v0.3. That thing would require an entire runtime. Given how long just this is taking me, just where am I going to find the energy to do that.

Nowhere.

I am going to need the power of self improvement for that. There isn't a single human who can give himself to the world forever without getting something back in return.

10:20am. I exceeded many other languages with v0.09. Bottom up reasoning is amazingly powerful. But top-down reasoning is a power too. And I am going to have to tap into it to get me through the next attempt.

I need this power. Without top-down reasoning, I won't be able to win.

v0.09 and v0.1 are a single design point in the language space, and v0.2 will be a different one. I need to stake my claim on it.

10:25am. Probably the greatest achievement in my life is figuring out the principles of self improvement and ownership. If I were to die tomorrow, somebody courageous will read Simulacrum, think that the kind of self improvement I am proposing is a noble aspiration, read the essay on power, and try to attain it in a realistic manner. No matter how crazy they seem, I haven't been able to find any weaknesses in the concepts.

I am solidly sure they are dominant.

The things I did in v0.09 while they haven't taken the world by storm, they do have a transcendental quality as well. A lot of the techniques I've uncovered as well as the overall language implementation is dubious, but you need partial evaluation if not for performance - then for language interop.

If you are really serious about ML to the point of dedicating your life to it, then you should be able to do something like make a ML library from start to finish. That means being able to handle GPU and other kinds of hardware in an elegant fashion.

I want to trivialize this effort. I need to bring out the compositionality of ML to the point where I am doing is not a big deal. I can see here that big frameworks are not needed to do ML. I just need a single well written functional library.

And I must be realistic. Although I am aiming high, I can't realistically say that I am smarter than the guys at Deepmind. Or that I have bigger pockets or bigger computers than them.

All I can do is do the right thing, in order to make their efforts at 'saving' the world as expensive as possible. I must be humble and punish them for their hubris at going against the principles. And if I am to be humble, I should first look to myself.

If I am really serious, I should take all the advantages that I can get.

That means not abandoning my style. But it also means, not abandoning the ability to do top down reasoning in the quest for power.

10:35am. This life that I lead today is my punishment - I should have not gone to school 20 years ago and simply dove into programming. Had I a 14 year head start on programming, just where would I be now? All the hardship that I am going through today is because I lacked the strength of vision and the decisiveness back then. It might be luck of the draw, but rather than looking towards omnipotence, I should have looked at the earth.

10:40am. In this life, I am just revisiting the battles that I've already lost.

My vision and philosophy, and Spiral are gifts I wish I could send to my past self.

I regret him not having them.

But as a gift, v0.09 is not good enough. I need v0.2. And as a consolation, although I won't be able to send it to the past, I will be able to send it to the future.

I want people to benefit from v0.2 whether that be me or somebody following in my footsteps.

10:45am. Let me make the lightning strike twice. For the blessed future where I am not working on a language, but using it to make my own power instead.

Let me make that second great accomplishment in my life, and the third will take care of itself."

---
## [petre-symfony/modern-react-udemy](https://github.com/petre-symfony/modern-react-udemy)@[2933e789bb...](https://github.com/petre-symfony/modern-react-udemy/commit/2933e789bb0c942593eb54752274002bc0e017be)
#### Thursday 2020-07-09 09:07:07 by petrero

301. Using Redux Dev Tools to Inspect the Store 302. Debug Sessions with Redux Dev Tools(Section 22: Redux Dev Tools)

We're all done with authentications side of our application we're now going to start to very quickly

start to work on giving our users the ability to create a new stream by putting this form together right

here.

Now as soon as we start talking about forums and redux we're going to begin covering a new library called

redux form redux farm is a little bit notorious for being just a tiny bit challenging to understand

but the only reason that is challenging to understand is that it's hard to understand what redux form

is doing inside of your redux store.

Now in order to make the process of learning redux form a lot easier I can't tell you about a little

extension that we're going to use to make debugging your redux application a lot easier if you install

this little extension inside your browser and wired up appropriately.

It's going to allow you to take a look at the data inside of your redux store very easily which will

make learning redux form really straightforward.

So we're going to put a link on the screen.

Here it is right here.

So I'm going to copy this link and open up a new browser tab and jump over to it.

OK.

So when I say extension I really do mean an extension.

This is a Chrome extension right here.

You can use this tool either with Chrome as an extension or also with Firefox as well.

This is a browser extension that is going to allow you to very easily debug your redux store.

You can very easily understand that or what data is inside of it.

And it also lets you do a couple of other interesting things very easily.

Let's first figure out how to wire this tool up and I'll show you exactly how you can use it inside

of your application.

And we're going to also use it quite a bit when we start putting redux form together.

So the installation directions for this are down inside the read me of this get have repository it's

all find the installation section right here.

You'll see directions to install this for the Chrome browser or for Firefox.

If you're using any other browser.

Unfortunately there is no support for it.

But I would still really encourage you to make use of chrome or Firefox for the rest of this application

that we're building just because this tool is so incredibly useful.

So to install this with chrome or Firefox you click on the appropriate link so this will take you to

the Chrome store or the Firefox store where you can easily click a button up your on the top right hand

side to install it into your browser.

Once it is installed you're going to see a little kind of I don't know satellites or solar system icon

up here on the toolbar up here.

That's the redux tools icon right there.

So once we get that thing installed we then have to add a tiny bit of code to set up our application

to hook in to these redux stepped tools or that will scroll down a little bit more and we're going to

find the section marked advanced store setup right here.

So essentially all we have to add in is what you see in the green text.

We're going to import a little helper from redux called compose and we're also going to apply the middleware

as well.

We don't have any middleware right now but we will eventually.

So we're going to wire up our application assuming that we're going to have middleware at some point

in time.

OK.

So to Wired this thing up I'm going to go back over to my code editor and find my root index such as

file so inside of here I'm going to find my redux import and I'm going to get apply middleware and this

little composed function as well.

Then right above my store creation right here I'm going to say Konst compose enhancers

equals window dot underscore underscore.

So that is two underscores right there.

Make sure you have two as well.

Redux dev tools extension compose and then underscore underscore

I'll then put down a or statement or or operator and I'll say or compose and then finally on my create

store call right here I'm going to get myself a little bit of space by expanding the call like so I'll

make sure I get a comma after reduce hours and then as a second argument I'll say compose enhancers

apply middleware and I'll close off the call like that.

So we do not yet have any middle where we are going to eventually have redux thunk installed in this

project but we have not installed it just yet.

Nonetheless we can still call applied middleware right now and at least get ready for that call or for

redux thunked to be added.

You can call applied middleware with out any arguments and you're not going to see any error message.

So no issue with this whatsoever.

Eventually we will install redux.

And then we can just throw in dunk like so and that's pretty much it.

All right so going to save this and I'll flip back over to my browser and we'll test out the redux dev

tools.

All right so I get flip back over I'll refresh the page and then once I refreshed the page I should

see that little icon for redux dev tools appear kind of come a light I should see some colors inside

of it.

You'll notice it's slightly green whereas it was kind of gray before.

I can then click on this thing and it's going to expand the dev tools menu right here.

Now something I really recommend you do is click on this kind of middle icon down on the bottom left

hand side that's going to pop these tools out as a separate window like so.

All right.

So let's take a look at this panel right here and get a better idea of what's going on in general.

There are two features that you're going to be using very frequently with these dev tools.

First off if you find this little selector right here of action state diff and test click on states

like so when you click on that that's going to show you the current state inside of a redux store.

So I see that I have my Auth. property coming from the author reducer and that has the is signed in

flag in my user ID as well.

So with this tool I can very easily see all the data that is sitting inside my redux application the

other feature that you're probably going to use very frequently is the left panel over here.

This is a list of all of the different actions that have been dispatched to your redux store.

Now the thing that is really cool about this is that we can very easily kind of jump back in time.

Let me show you what I mean.

I'm going to come back or to my application and I'm going to sign out and then sign back in really quickly.

OK.

So now on the left hand panel over here I see three different actions.

I see a sign in sign out and sign in.

These are the three different actions that have now dispatched inside of my store.

The first action right here was dispatch when I first booted up my application inside the browser.

And then I see the sign out and sign in it from me simply refreshing or to me signing out it's like

clicking sign right there and then signing back in as I did just two seconds ago.

Now the part that is so cool about this is that if you hover over say sign out right here you'll see

this button jump on the right hand side I can click on jump and the state panel over here on the right

hand side is going to change to reflect the state inside of my store.

At that point in time.

So when I had dispatch sign out I now see the state that was inside my store when I had just dispatch

sign out and process that action by all my reducers.

So using this tool we can essentially jump around in the history of your application and get a better

idea of exactly what happened at every point in time.

Now you'll notice if I do a little bit of rearranging here when I click on these different actions or

the jump button for each action I'm not just changing the state that I see down here in this little

pop up window I'm actually changing the state inside of my real redux store.

So if I jump back to say sign in right here you'll notice that the UI changes to reflect the signed

in status.

Well I can now go back to being signed out and that button goes back to saying sign in.

Because now redux thinks I no longer sign into the application.

So as you might guess this tool is an absolute amazing thing to use any time that you're trying to debug

a redux application.

There are even some more features that are even more useful than what we've spoken about so far and

I'll show you some of those other tools and a little bit for right now I want to show you one other

thing that is kind of interesting.

Personally I think it's interesting anyways aside from New browser tab I'm going to navigate to air

b and b dot com and so this is the air in the home page.

I'm going to flip back over to the dev tools over here and then I'll find the drop down on the top right

hand side.

I'm going to select Air B and B.

So at present this might not be true by the time you watch this video but at present European B has

redux dev tools hooked up to their redux store as well and it is publicly visible.

So if you come over here to Air B and B.Com you can actually take a look at your redux dev tools and

you can explore all of the different state that exists inside the redux store that is created by Airbnb.

Yes Aramean uses react and redux internally.

So just for learning sake you can take a look at all the different pieces of state that airband be uses

and could give you a better idea of how you might want to structure your store or your state for a more

complex application.

Now Air B and B is not the only site that does this.

You can find many other sites online that expose redux dev tools as well and you can take a look at

all the data that is stored inside and give you a better idea of how to structure your own application.

Now just so you know if you ever seem to be kind of stuck with your dev tools looking at some other

page or some other product and you want to go back to looking at your redux store you can go back to

the dropdown appear and change it back to react up.

And now I see my piece of state again.

OK.

So like I said we're going to be using Reducto tools quite a bit moving forward and that's going to

make learning the redux format library a lot easier as well.

Now that we understand how this works we'll take a quick pause right here and we'll start working with

redux form in the next video.

302. Debug Sessions with Redux Dev Tools

In this video there's one other very quick thing I want to show you with redux dev tools.

This is not going to be a feature that is immediately super useful for us but we're going to end up

making use of this other feature in redux stepped tools at great length later on inside this course.

So let me tell you what this little feature is inside of our address bar.

We're going to navigate to our application at local host Colin 3000.

But then we're going to put on this little query string right here.

We're going to put on a question mark de-bug underscore session equals and then some random string of

characters.

When you do this redux step tools is going to see that you are trying to start up a debug session a

debug session is where redux dev tools is going to automatically save all of the data inside of your

redux store and persist it across refreshes of your application.

So you'd normally when we refresh our application all the data inside of a redux store falls away and

we lose it entirely.

When you enable this debug session redux step tools is going to make sure that all the data stays around

between refreshes of the page.

So this is incredibly useful when we start doing some advanced feature development and we're going to

see how useful it is later on inside the course.

Let's very quickly check out this little feature and see how it works.

So I'm going to go back to my application and in the address bar I'm going to go to question mark de-bug

underscore session and then some random string of characters.

Like so now once I'm here I'm then going to sign out and then sign back in.

Now when I do so you'll notice I now have a couple of actions that have been dispatched to my store.

I have the initial sign in from when I refreshed the page I have a sign out from when I click the sign

out button and I have another sign in from when I sign back in.

Now here's the magic if I refreshed this page I'm still going to see the same list of actions here.

So redux dev tools has persisted all those actions and all the states across the refresh and we have

not dropped off or lost any data.

What's really great about this is that we can now go back and jump to some previous state just as we

did before by clicking that little jump button where it could jump to the sign in or back to present

which would be the most recent sign in right there.

Like I said this is really useful for debugging.

And we're going to use this at great length later on it inside the course.

One thing I want you to be aware of is that once you're done with a debug session you are going to want

to remove that query string out of your otherwise redux step tools are just going to continuously try

to throw your previous state into your store.

And sometimes you really don't want that.

Particularly if you change some reduce search or return some other form of data like maybe an array

instead of an object.

If you continue running 80 bucks session you'll very quickly start to run into errors because redux

tools is trying to throw data into your stored that is no longer valid.

Now the other thing I want to show you really quickly is sometimes we might want to have some named

debug sessions so maybe I would give this one a name of like logged in like so and then I would make

sure that inside this debug session I am logged in and then maybe I will make another debug session

called logged out like so and then I could sign out here.

So now I have two separate debug sessions that are running one where I am logged in the other where

I am not logged in.

So if I wanted to I can now easily go back to the previous debug session like go into a logged underscore

in and I'm going to essentially retrieve the previous state that I had.

You can actually see over here the previous state from the logged in debug session had me signed in.

Now immediately after I loaded the page the API libraries said oh you're not signed in anymore because

I actually had signed out so it's going to dispatch the sign out action but essentially by creating

these different debug sessions I can have these different kind of checkpoints of state inside of my

application.

That again makes it really easy to develop and debug certain features.

Now just one more time.

Remember any time that you are done with the debug session make sure you take off that query string.

Otherwise you're going to try to throw some data into your store that you probably don't want to throw

in.

So I'm going to go back to local history.

We'll take a pause right here and this time we will actually continue with redux for him in the next

video.

So quick pause and I'll see you in just a minute.

---
## [petre-symfony/modern-react-udemy](https://github.com/petre-symfony/modern-react-udemy)@[1cb48d4529...](https://github.com/petre-symfony/modern-react-udemy/commit/1cb48d4529d04bb7fcadc7dc9f30d0e00507131b)
#### Thursday 2020-07-09 09:07:07 by petrero

308. Customizing Form Fields(Section 23: Handling Forms with Redux Form)

In the last video we hooked up these two field components to the new render input function.

Anytime time that the field component called render input it also passed in a set of properties that

we took and passed along to the text input inside of your screen.

Remember the running theme with redux form is that it's going to do all this stuff for us automatically

and it's up to us just to wire up this last little step right here to take whatever handlers or values

that are provided by redux form and make sure that we actually wire them up to some meaningful input.

Now in this video we're going to continue working on our render input function right here.

So at present we have our inputs with dot.com input when that shows up on the screen.

We get this really ugly input right here like there's no label on there.

They're the two inputs are right next to each other and it's really tough for a user to figure out what's

going on.

So rather than just returning a text input right here we can actually return an entire blob of GSX.

So like a couple of different elements we are not restricted to just returning the one single input

by itself.

So I'm going to again turn this into a multi-line expression.

Sorry for going back and forth.

Remember to clean up the semi-colon on the right hand side of the input and then I'm going to wrap this

with a div that has a class name of field.

And then above it I'm going to put in a label tag because we probably want to tell the user what actual

input this represents.

I remember the render input function is going to be called two times one time by our field or title

and one time by our field for description.

So when we put our label inside of here we need to make sure that we know which field we are currently

going to be working on.

So to get that appropriate fields we can add on or the appropriate title of the field I should say we

can add on an additional Propp to both of these field elements.

So on the first field I'm going to add on a prop of label and for the first one I'll put in her title

and then on the second one I'll put in a label of enter description like so anytime that we add in some

props to our field components right here redux form is going to see that we have passed in some prop

that it doesn't know what to do with.

In other words that field element has no idea what to do with a label prop.

So the field element by default is just going to take that prop and pass it through to the render input

function.

So this is how we can customize the render input function when ever it gets called we can just add on

additional props to the field element.

So now because we passed in this prop that the field component doesn't know about it's going to be passed

in to render input and we can receive that as an additional property on that first argument.

So I can now reference this label property and restructure it out of that object that gets passed in

as the first argument.

And now inside my label right here I can print up label like the cell save this and we'll flip back

over.

And now we can see that we correctly get our label appearing on the screen.

All right cell looks pretty good.

Now I say that it looks pretty good but it doesn't really look perfect.

We really don't want the text to be right next to each input.

So to fix that up we can just add on a quick class name to our form element right here.

So I can put on a class name of UI form like so.

And then once I do that I'll see the nice form appear that looks a lot better right there.

OK.

So this is looking pretty good.

So now we have the ability to show the form in all the different fields that we want and we could put

in some title and description inside of here.

Now the last thing we need to start to think about is how we can submit this form and get some callback

that says hey the form is just submitted so that you and I can try to create a new stream or whatever

it is we are trying to do.

So let's start to figure that out in the next video.

---
## [petre-symfony/modern-react-udemy](https://github.com/petre-symfony/modern-react-udemy)@[451c81ccf8...](https://github.com/petre-symfony/modern-react-udemy/commit/451c81ccf83321377da93989203eb5f67b4a590b)
#### Thursday 2020-07-09 09:07:07 by petrero

299. Fixed Action Types(Section 21: Handling Authentication with React)

In this video we're going to do a quick little refactor to our author's douceur.

You want our two action creators that we just put together.

So if your code is not working right now and if it feels like clicking on that button does absolutely

nothing at all.

You might have a very common little bug throughout this course.

We've been defining actions that have a type property.

And in every case we've always assigned a string directly to that type property when there's a extremely

common error that tons of people make including myself when they're first getting started with redux.

Remember the type property right here whatever string we put in it is very important that we put the

exact string inside of the Type property right here.

And the exact same type spelling or the exact same spelling of that string inside of our case statement

inside very douceur.

It is incredibly common for people to accidentally make a little typo inside that string.

So maybe they say sig in as opposed to sign in.

So if you currently are having a problem inside of your program where it seems like you're clicking

on a button does nothing at all double check those strings for the cases.

And then double check the strings inside of your action creators as well.

It's incredibly possible that you might have made a little typo between the two.

Now I told you at the end the last video that we were going to do a little Reflektor here so I'm going

to show you a little technique that we can use to make sure that we don't make any typos in transcription

between our reducers and our action creators.

So to do this refactor and make sure we don't accidentally make any typos are going to create a new

file inside my actions directory and I'm going to call it types.

J.S. then inside of here we're going to define all of the different types that are used inside of our

action creators and producers.

I'll do so by writing out export Konst sign in equals the string sign in and then I'll do the same thing

for sign out as well.

All right so what are we doing here.

Well essentially inside of one single file we are defining all of the strings that can be used inside

of our action creators in our reducers.

So inside of all the action creators producers we are no longer going to refer to plain strings.

Instead we will import these action types.

These variables of sign in and sign out these variables still reference strings.

But the benefit to using variables right here is that if we ever accidently make a typo in the name

of a variable we're going to very quickly see an error message that says like you know if we type inside

of our douceur Let's go back over there right now if we accidentally reference a variable inside of

fear of something like sign in and then leave off like the end or something like that.

We will very quickly see an error message that says something like unknown variable sig in and that

essentially is assigned to you the developer that you probably made a typo around one of your action

types.

So in reality just about nothing here is changing.

We're still using strings to coordinate our types but those strings are being assigned to variables

just because it is easier to find errors when we make spelling or make mistakes in the spelling of a

variable name.

Now just creating this type's file does absolutely nothing.

We have to actually use these variables inside of our reducers interaction creators so to make use of

these two variables right here.

I'm going to first change into my actions index j as file and then at the top I will import sign in

and sign out from the type's file and then for my two types are my two action creatures inside of here

I will remove the plain string and replace it with sign in.

Now I'll do the same thing for sign out down here as well.

Sign out so now we can do the same process inside of our three douceur I can my authorized use or at

the very top I will import sign in and sign out from up one directory actions types

and then I will replace the string right here with sign in and the string right here with sign out.

So again we're still using strings to coordinate this.

The only difference is that these strings are now assigned to variables.

So if you make a typo in the variable name we will see an error message.

Now I'm going to save both files and I'll flip back over the browser and I'll do a quick little test.

So I clicked sign in with Google and I'm kicked into my waterflow.

So I still see the button change successfully I can click sign out.

And that button changes back to the initial state.

All right.

So looks like everything still works the way it did before.

But now if I accidentally make a typo here let's just get a quick idea of what that would look like.

So if I accidentally misspell that type name right there and I go with sin because I just committed

a sin in misspelling the action type I can say this and then I will very quickly get a nice error message

right here that tells me hey I just did something wrong around my author reducer I probably misspelt

a type so I probably need to go and fix that.

And so I wait.

Go back over.

I would see the line that it was talking about right here and I would say oh OK I made a mistake I made

a misspelling or a typo inside of my type.

So I'll just update it to the correct spelling like so I can save this.

And the error message goes away.

Awesome.

All right so moving forward we're going to be using this kind of type system throughout the rest of

all this application and any other apps so we start to build.

So it's something that we're going to do a lot moving forward just to help us catch possible typos.

All right let's take a quick pause right here.

There's one last thing I want to do around our producer and then we're going to start moving on to our

next big feature.

So quick break and I'll see you in just a minute.

---
## [petre-symfony/modern-react-udemy](https://github.com/petre-symfony/modern-react-udemy)@[7a95cbf22b...](https://github.com/petre-symfony/modern-react-udemy/commit/7a95cbf22b68afb320b870c093a5405de6bf98f9)
#### Thursday 2020-07-09 09:07:07 by petrero

303. Forms with Redux Form{yarn add redux-form --save} 304. Useful Redux Form Examples(Section 23: Handling Forms with Redux Form)

In this video we're going to start working on our create stream form right here.

So the idea is that we're going to enter in some title for a stream.

Any description when we submit it we're going to want to reach out to some API server that we have not

yet put together but we will very shortly and create a new record that says that a given user has created

a stream.

Now in order to put this in we're going to be using a library called redux form redux form is kind of

notorious I guess.

On one hand some people think it's kind of challenging to understand but on the other hand it does a

ton of stuff for you automatically and it makes life pretty darn easy compared to if you try to put

all these different forms together by hand and integrate all that stuff with redux.

So it's kind of a mixed bag depending on your attitude I suppose.

At any rate we're going to figure out exactly how it works.

Now we're going to first begin by installing a redux form into our project.

So I'm going to change on over to my terminal.

I'm going to start my server and I'll do an NPM install dash dash save redux dash form like so and then

I'll just go ahead and let that do its thing while it's going on.

We're going to take a look at a quick diagram or two.

All right.

So I want you to first think about how we've been handling forms throughout this entire course up to

this point in time at this point.

We have always been making use of class based components these class based components have been making

use of component level state.

So we had some states object that recorded the current value of an input element.

We then took that value out of that state object on the component and we essentially pushed it into

that input element inside the dam.

Remember the idea here is was that we wanted to tell the input element what its value was and that we

did not want to store any of our state or our D data inside the dome itself.

Then whenever a user changed that text we would have an on change callback.

The onchange callback would essentially call our set state method and update our component level state.

So we had this little cycle here that just went on over and over and over again.

And the real pinnacle are the cornerstone of it was that our class based component held the real truth

of data inside of our application that state object knew what the true value of that text input was.

So once we start making use of redux this little approach right here is going to change ever so slightly.

Remember that in general with redux we want to hold all of our data inside the redux store.

And so no longer are we going to have class based components that have a ton of state on them that are

going to manage these different input elements.

Instead we're going to store that data inside of our redux store.

And any time a user changes a element we're going to probably call an action creator that's going to

attempt to change that data inside of a redux store.

Now let me show you a quick diagram that can help you understand how a redux form is going to automate

some portions of that flow OK here we go.

So just as before we might have some input element over here on the far right hand side this input element

is going to be assigned a value.

And in onchange handler by our application because we never let the DOM hold information about our app.

Instead our app holds information and then we essentially push it into the DOM.

Now everything on the left hand side is essentially going to be a little bit different.

So we're going to have some redo cert that's going to hold all the states of our different forms inside

of our application.

So that might be the value of some input element or the selection of some dropdown or the current checkboxes

that are checked inside of application.

Essentially all of our foreign data is going to exist inside of our redux store and all that form data

is going to be maintained by a reducer.

Then in order to make sure that we can get the data from that store into our input elements of whatever

type they are we're going to essentially have something like Map state to prop's that's going to take

that foreign data out of the redux store and get it into our component as props.

And then we're going to make sure that you and I take that prop object and all the different values

inside there and pass them into our different input elements as values just as we did before when we

were making use of component level state then any time a user makes a change to an element we're going

to have some callback handler inside of our component that's going to probably an action creator and

try to update the form data inside of a redux store.

And here's the great thing about this entire scenario redux form is essentially going to do all of that

stuff for us because it is so incredibly repetitive.

I bet you can kind of tell at this point in time that every single time that we want to change data

inside of a redux store what do we do we call an action creator.

And any time that you want to get data out of a redux store into a component What do we do.

When we write a map state to prop's function.

So those are two pretty repetitive operations.

And so we can essentially just abstract all that work away from us and have redux form do it for us

automatically.

So essentially redux form is going to have a producer that we are going to wire up to our application.

You and I are not going to write this reducer this is included with the redux form library.

We're going to take that reducer and wired up to our store.

We are not going to write any outstate to prop's function redux form is going to essentially do that

for us automatically.

You and I are not going to write any actual creators redux form is going to do that for us automatically.

The only thing that you and I really have to do is make sure that we eventually get some form information

down into some given input element and make sure that that input element understands that it needs to

call some callback handler.

Provided I can buy redux form anytime that it gets changed.

So this is essentially what is going on behind the scenes.

It is still making use of the entire redux system as you understand it but it's done all for us automatically.

All right.

So let's flip back over toward terminal.

It looks like the installation is complete.

I'm going to start my application back up with NPM start and we're going to take a quick pause right

now when we come back the next video.

I want show you the redux foreign documentation very quickly because it is absolutely outstanding documentation

and I really suspect that you're going to want to reference it at some point in the future for your

own purposes.

And then after that we're going to start to wire up relax form to our application so quick pause and

I'll see you in just a minute.

304. Useful Redux Form Examples

In the last video we started talking about redux form.

I now want to show you some of the documentation around redux farm because like I said I think that

you're probably going to end up wanting to reference this documentation once you start working on your

own projects so we can find the documentation for redux form at redux dash farm.

I'm going to open up a new browser tab and navigate over there right now.

OK.

So here's the documentation.

I'm going to scroll down a little bit.

You'll see that there is some start here API examples and FNQ.

By far the most useful section here is the Examples section.

So I going to check out the examples.

This is a list of different form types that you might want to put into your application.

So there are very simple examples for a simple straightforward form beurre form with some type of validation

that is going to happen.

Client side inside of your app or validation that is only going to occur when the user submits a form.

And even let's say down here initialising the form from the States which would be any time that we want

to make an edit form you and I are going to do that later on.

And then you can also see a very useful one right here.

Probably the most useful example that you will probably want to reference at some point in time depending

upon the type of application you're going to put together is a wizard form.

Let's take a look at that example really quickly wizard form.

Yes I can scroll down a little bit.

So this is the example right here underneath the section that says form.

So if you want to you could put in some value here and then notice how there's a next button.

So I can click next and then I get prompted for some more input.

I'll put that in and you'll see that it keeps on running me through different steps inside of this form

until eventually I get to submit.

So this kind of a wizard form right here is a very common thing that you see in a lot of web applications

where a lot of different information needs to be picked up from a user and you kind of want to display

different questions all in a series.

Kind of like different pages of sorts.

So again I think that you might end up wanting to read about this wizard form approach.

At some point in the future when you start working on your own application.

But again for right now you and I are going to be working on a little more simple straightforward form.

So for the most part we are going to be following forms of the similar nature to this synchronous validation

example right here.

So if you want to do it you can keep this documentation open.

As we work through our example and our forms but absolutely You don't have to are going to essentially

tell you everything that this documentation says so you can always just kind of you know follow along

with me and we'll do essentially the same exact thing that you see in here.

OK.

So again I just want to show you this documentation very quickly because I really expect you're going

to reference this at some point in the future.

Let's now take a quick pause.

When we come back the next section we're going to start to set up redux form inside of our project.

---
## [petre-symfony/modern-react-udemy](https://github.com/petre-symfony/modern-react-udemy)@[66c3c6af3a...](https://github.com/petre-symfony/modern-react-udemy/commit/66c3c6af3a29c332d4c0771125f3e7ab4e30c684)
#### Thursday 2020-07-09 09:07:07 by petrero

310. Validation of Form Inputs(Section 23: Handling Forms with Redux Form)

In the last video we figured out how to hook up an on Smith event handler using redux form.

Now in this video I want to show you something kind of interesting here.

If we load up our form with no inputs whatsoever we can click on submit and we see an empty object over

here.

So this would be a case in which a user is attempting to submit our form entering in any title or description.

Chances are we do not want to allow that.

We probably want to make sure that a user always enters in a title and a description before we allow

them to create a stream.

This process of making sure that the user has entered in some acceptable input is referred to as validation.

We can use validation to check for any type of element in the form so we can make sure that say a title

any description or enter if we had an email input we could make sure that a user entered in an email.

If you have a phone number input we can check to make sure the user entered in a valid phone number.

So any type of validation you can possibly imagine is going to occur during this validation step handling

validation once redux form is simultaneously kind of hard and kind of easy.

It's kind of hard because there's going to be a couple of moving pieces here and a little bit of magic.

But at the same time it's going to be a little bit easy because as long as you learn the pattern doing

the validation is going to be an absolute snap.

OK.

Sort of walk us through this process we're going to take a look at this diagram here.

Now the diagram is a little bit confusing.

So we're not going to go over the entire diagram right away.

Instead we'll go over it part by part and then write out some code for each step inside of here.

OK.

So the first thing to note here is that your form is going to be validated by redux form.

Just about every millisecond of the day you could possibly imagine.

Not really.

But essentially every single time that the form is initially rendered to the screen and every single

time that the user interacts with the form so it interacts with the form can be like selecting input

or typing in a character or selecting out of that input.

Just about every interaction you can imagine that occurs with your form redux form is going to attempt

to validate your inputs.

So at every one of those little events redux form is going to call a function automatically called validate

you and I have to define this validate function validate function is going to be called with all the

current values in the form of validate function is going to be essentially our opportunity to check

to see if the user entered isn't valid or invalid input.

So let's define this validate function really quickly.

I'm going to flip back over to my code editor.

I'm going to go back down to the very bottom of the file.

So this is not a function we are going to define inside of our component class.

Instead of going to define it outside the class right above the export default statement.

So I'll say Konst validate and this thing is going to be called with a form values object form values

is going to contain all the different values that exist inside of our form.

So as we saw just a moment ago when we type in some input here and then submit this form we saw that

we had this form values object right here with a key of the field name title.

Again that is title right there because we specified the name title on the field and we have a key value

pair of description.

Again we see description because we provided a name of description to our second field.

Now we see the appropriate text for each property.

So this exact same object is going to show up inside of our validate function right here.

So now this is going to be our opportunity to actually validate those foreign values.

All right let's flip back over to the diagram and walk to the next step.

So inside of validate we're going to essentially check to see if a user entered in any valid values

for those different inputs.

We're going to do that by inspecting the form values object.

This series of inspections that we're gonna do here to see if a user entered invalid input is going

to be very basic.

Essentially we just have to write out if statements will say if there is no form value is not title

property.

So that would do a check to see if a user entered in a title or not if they did not enter in a title

form values that title would be undefined.

And so the body of the if statement will only Rayyan if the user did not enter a title.

So that's how we're going to do very basic validation.

So after we do a series of statements like that where if a user entered an all valid inputs then all

we're going to do from this validate function is return an empty object.

When we return an empty object that essentially tells redux form that nothing is wrong with our form

and it's completely valid and the user can submit it if they want to.

Now if a user did anything incorrectly then we're going to return an object.

And this is where things get just a little bit complicated.

So we're going to return an object if a user entered in anything incorrectly for each invalid field

that the user entered.

We're going to put a key value pair on an object with the name of the fields that the user entered in

incorrectly and an error message to show to the user.

So for example if the user entered in an invalid title we're going to create and return an objects that

looks like this over here.

It's going to be an object that has a title property and it has a string containing the error message

when redux form sees this object right here that has a key value pair inside of it.

It's going to say oh I see that there is a value inside this object that means that the user must have

done something incorrectly number.

If we return empty object from validate redux form assumes that everything went OK.

So it's only when we put a key value pair into this object that redux form realizes that something just

went a little bit wrong.

All right let's write a little bit of code for this step right here.

So back inside my validate function at the very top of it I'm going to define an object called errs

like so.

So then inside of validate we will have a series of IF statements each IF statement can check a different

form value property.

Now again if a user did not enter in a title I'm going to say heir's title is some error message like

you must enter a title like so then we can write out another statement to make sure that the user entered

a description as well.

So I'll say if there is no form value description property let's say ersatz description equals you must

enter a description.

And then finally after we create that object we need to make sure that we return it after adding on

all the appropriate properties.

So at the bottom of validate I'm going to return errors like so OK.

So that's our validate function right there.

That's all we have to right now to wire this thing up to redux form and handle any error messages that

need to be shown to the user.

Let's take a quick pause right here and we'll handle that process in the next video.

---
## [petre-symfony/modern-react-udemy](https://github.com/petre-symfony/modern-react-udemy)@[801fc94bbf...](https://github.com/petre-symfony/modern-react-udemy/commit/801fc94bbf542323abe9f1596e96e91823831095)
#### Thursday 2020-07-09 09:07:07 by petrero

306.2. Creating Forms(Section 23: Handling Forms with Redux Form)

I'm going to import two helpers or two properties from redux form itself.

The first one is fields with a capital F and then the second is redux ormer with a lowercase are from

redux Dasch form now a set.

These things have different capitalization.

Field has a capital F. redux form is a lowercase are the reason for this is that field is supposed to

be a re-act component.

So this is going to be a component that we are going to eventually show on the screen.

On the other hand redux form right here is a function.

This function is going to essentially have the exact same functionality as the connect function that

used from the re-act redux libron the redux form function is essentially what's going to make sure that

we can call some action creator and get some form data into our component.

And remember that all happens automatically it's the first thing we're going to do is take this redux

form function and hook it up to our component down here at the very bottom again redux form very similar

nature to connect so similar in nature that it even has an identical syntax when we make use of it.

So in front of string creates I'm going to write out redux form.

I'm going to put in one set of parentheses and then put a second set of parentheses around stream create.

Remember the syntax here is that redux form is going to return a function and we immediately call that

function with stream create.

Now we're going to pass redux form right here an object for some configuration unlike the connect function

which takes separate arguments into its redux form instead receives a single object and we put a bunch

of configuration into that object.

At present there is only one piece of configuration we have to put in here.

I'm going to say form and then I'm going to provide a name for this form as a stream string.

The name of this form is going to be generally whatever the purpose of the form is.

You'll see what the purpose of this name is in just a minute.

So for right now I'll just put in and name something like.

Stream creates it can be lowercase capitalized whatever you want it to be.

It really doesn't matter.

OK so now we have hooked up redux form.

This component is now going to be passed.

A ton of props a ton of additional props that it was not being passed before just to get a better handle

on what's going on.

Let's add in a console log statement inside the render method and I'm going to count the log.

Stop props all then flip back over

if you see any errors or warnings like this again you're going to see those errors or warnings every

now and then when you were making use of the Google API stuff.

If you see those errors and warnings totally fine you can ignore them altogether.

All right so I get to refresh the page and then I should see this council aigrette year of my prop's

object.

So this is our prop's object that is going into that form.

Notice how there are a tremendous number of properties on that process object.

Now before we probably only had a handful now we have a tremendous number of props that are showing

up.

Thanks to that redux form helper all the props you see right here are part of the automatic system that's

going to be used to essentially get form values into a element and then get changes back out and update

that redux form reducer.

So it's essentially up to you and me to kind of pick through this list of props right here and find

the different props that are relevant to us and make use of them to actually build out our form.

All right.

So I'm going to flip back over.

---
## [Buildstarted/linksfordevs](https://github.com/Buildstarted/linksfordevs)@[f321d09546...](https://github.com/Buildstarted/linksfordevs/commit/f321d0954638add0f8ecc0e14e403ad6c6fdfc57)
#### Thursday 2020-07-09 09:08:33 by Ben Dornis

Updating: 7/9/2020 9:00:00 AM

 1. Added: How I learned to suck less at Chess
    (https://www.bargava.com/blog/suck-less-at-chess/)
 2. Added: Why I built a new app for practicing keyboard shortcuts
    (https://tkainrad.dev/posts/why-i-built-a-new-app-for-practicing-keyboard-shortcuts/)
 3. Added: 'Jiro dreams of sushi' lessons for SaaS - Blog by Damian Schenkelman
    (https://yenkel.dev/posts/jiro-dreams-of-sushi-lessons-for-saas)
 4. Added: Everything is a Strawman
    (https://matthewsaltz.wordpress.com/2020/07/08/everything-is-a-strawman/)
 5. Added: Jonathan Bergknoff: Terraform Pain Points
    (https://jonathan.bergknoff.com/journal/terraform-pain-points/)
 6. Added: A Few Catchy Philosophy Quotes That Are Often Misinterpreted - Neel Somani
    (https://www.neelsomani.com/blog/catchy-philosophy-quotes-that-are-often-misinterpreted.php)
 7. Added: VC Firms Promised to Help Black Founders. My Experience Shows a Different Reality.
    (https://thebolditalic.com/vcs-have-a-well-known-black-founder-problem-but-really-they-have-just-forgotten-about-people-2e8452029793?gi=227ef7dd8585)
 8. Added: How to write proper Software Documentation?
    (https://larsroettig.dev/how-to-write-proper-software-documentation/)
 9. Added: The saddest "Just Ship It" story ever
    (https://kitze.io/posts/saddest-just-ship-it-story-ever)
10. Added: Moving from TypeScript to Rust / WebAssembly
    (https://nicolodavis.com/blog/typescript-to-rust/)
11. Added: Why you'll probably regret using Tailwind
    (https://johanronsse.be/2020/07/08/why-youll-probably-regret-using-tailwind/)
12. Added: What is an event loop?
    (https://blog.phuaxueyong.com/post/2020-07-08-what-is-event-loop-javascript/)

---
## [petre-symfony/modern-react-udemy](https://github.com/petre-symfony/modern-react-udemy)@[8e9a23063a...](https://github.com/petre-symfony/modern-react-udemy/commit/8e9a23063ae3f6ade856902d3cc052e6f35d6889)
#### Thursday 2020-07-09 09:20:01 by petrero

318.2. Creating a Stream with REST Conventions(Section 24: REST-Based React Apps)

But very frankly we will use a slightly modified syntax.

So let me show you another way that we could write this out.

I want to remove the export default statement right there and I'm going to instead create a new variable

called form wrapped like so.

So the idea here is that we were making a form wrapped version of our stream create component and then

now at the bottom of the file we could put a another export default statement place or connect function

and then pass in form wrapped like so.

So that's how we can very easily stack up additional kind of nasty looking functions like this without

ending up with some crazy syntax.

So now getting back on track here we do not yet have a map state to prop's function but could pass in

null as the first argument and then as a second argument I'll put in my action creator of the stream.

Now finally inside of my component itself or find the on submit function and each time that the user

Smit's the form I'm going to make sure that I call this stop prop's dot stream or I forgot the name

of it.

Great stream there we go.

Reate stream and we will call it with all of our foreign values.

It's now whenever the user tries to estimate the form we're going to validate the inputs if the inputs

are valid we will call on submit on Sammet is going to call our action creator of create stream that's

going to run the Create stream action creator right here and we're going to attempt to make a request

over to our API server and create a new stream and we know that this is going to create a stream because

we are following restful conventions.

We are making a post request to slash streams.

All right.

So going to save all this and then recall that we had stopped our server to do a new install.

Back over here and you know what I'm actually looking at the new install We forgot one little stepper.

I forgot to step here.

We forgot to wire up redux thunk.

Let's do that really quickly.

While we do that let's start our server up as well with NPM start OK so well that goes I'm going to

flip back over to my roots index such as file.

So here's the root index file.

Remember inside here we had already set up the applied middle where we call in anticipation of wiring

up redux thunked So this is going to be really easy at the top.

I'm going to import redux thunk from redux dasht thunk and then I will make sure that I pass that into

the applied middleware call right here redux.

Thank all.

All right let's flip back over to our application.

Here we are.

I see my form on the screen so now I'm going to pull up in my network request log.

I'm going to filter by S.H. H.R. requests and I'll enter in some stream names so how about like my stream

and I'll give it a description or something like this is a great stream and then I'll submit.

All right so we see a little nasty error message here.

But I bet you can guess why we see this one.

Yeah.

Hold traditional.

---
## [maximumdata/bloardtotransformer](https://github.com/maximumdata/bloardtotransformer)@[2743780da7...](https://github.com/maximumdata/bloardtotransformer/commit/2743780da7fbb94b542d6e814611409084db19c5)
#### Thursday 2020-07-09 09:42:16 by Mike Dettmer

this is insane. i havent done front end work in years. all i did was add a p tag and i have to do a whole commit/pull/build cycle for it. front end web development sucks shit

---
## [NetBSD/pkgsrc](https://github.com/NetBSD/pkgsrc)@[286a393923...](https://github.com/NetBSD/pkgsrc/commit/286a39392300e0e9e3ac289703f32933aa309994)
#### Thursday 2020-07-09 09:54:48 by yhardy

lang/ecl: update to ecl-20.4.24

PR 55227

Pkgsrc changes: a newer version (5.2) of texinfo is required to build the documentation.

This updates breaks math/maxima when built with ecl (clisp is the default). Maxima
upstream has already fixed this in a later release.

From the CHANGELOG file:

** Announcement
Dear Community,

After more than three years of development, we are proud to announce a new
ECL release having the version tag `20.4.24`. During that time many
important improvements have been made including bug fixes, stability
enhancements and new features. Changes include but are not limited to:

- package local nicknames support
- atomic operations support
- specialized representations of complex float types
- a port to the iOS platform
- fixes for weak hash tables and weak pointers
- fixes for race conditions in the ECL internals
- hash table extensions (synchronization and custom test functions)
- better MOP conformance and improved meta-stability
- improvements to the manual

For more information please read the file CHANGELOG which is located in the
source code, and browse commits. We'd like to thank all people who made
this release possible by contributions of code, documentation, issue
reports, testing and others. Some of them are listed here (without any
particular order): Paul Ruetz, Karsten Poeck, Vadim Penzin, Roger Sen, Stas
Boukarev, Michael Fox, Erik Bray, Bo Yao, Jeremy Cooper, Florian Margaine,
Fabrizio Fabbri, Tomek Kurcz, Kris Katterjohn, Marcin Kolenda, Zhang Yuguo,
Sébastien Villemot, Moritz Petersen, Marius Gerbershagen and Daniel
Kochmański. We'd also like to thank the company Rigetti Computing for
sponsoring the work on specialized complex float representations.

We have another important announcement we'd like to make. Embeddable
Common-Lisp project has now two maintainers: Daniel Kochmański and Marius
Gerbershagen. After numerous contributions from Marius I've proposed him
this responsibility and to my rejoice he has accepted it. That reflects our
community growth.

This release is available for download in a form of a source code archive
(we do not ship prebuilt binaries):

- [ECL 20.4.24 tarball archive](https://common-lisp.net/project/ecl/static/files/release/ecl-20.4.24.tgz)
- [The ECL Manual](https://common-lisp.net/project/ecl/static/manual/)

Happy Hacking,
The ECL Developers

** Enhancements
- iOS support thanks to the help of P. Ruetz and gitlab user Whimse
- hash-table may now have a custom equivalence predicate
- ~make-load-form-with-slots~ works for structs even if slot names are not interned
- ~ext:weak-pointer-value~ returns two values (value and its presence)
- specialized complex float types based on C99 complex numbers have been
  added, together with corresponding specialized array element types.
- support for atomic operations added with an interface similar to SBCL.
  Currently (SBCL 1.4.12), it differs in the following points:
  - the set of supported places is slightly different
  - ~atomic-incf/decf~ always implement modular arithmetic with respect to
    the width of a fixnum, instead of a width of 64 bits as for some places
    in SBCL.
  - Functions such as ~(cas foo)~ analogous to ~(setf foo)~ are not allowed
    in ECL.
  - The arguments of ~defcas~ are consistent with the short form of
    ~defsetf~ in contrast to SBCL, where they are different.
  - compare-and-swap expansions can be removed with ~remcas~
- experimental support for serializing Lisp objects in compiled files
  directly instead of using the reader for faster loading of .fas files
  (configure option ~--enable-serialization~).
- improvements to C backtrace interface. Compile with CFLAGS+="-rdynamic"
  ./configure ... (Unix) or nmake ECL_USE_DBGHELP=yes ... (MSVC) to take
  full advantage of this feature.
- better handling of fifo files (see man 7 fifo)
- unicode names are always linked for unicode builds (~--with-unicode-names~ removed)
- numerous bytecodes compiler enhancements
- ~ext:run-program~: process streams may be virtual streams (for instance
  ~*standard-output*~ in slime, or a string-output-stream)
- ~ext:run-program~: environ argument defaults to ~:default~, when NIL
  passed empty environment is used
- compiler: when gcc fails ecl prints the failing command output
- ASDF has been updated to 3.1.8.8
- The Boehm-Demers-Weiser garbage collector has been updated to version 7.6.8
- libffi has been updated to version 3.3
- package local nicknames has been implemented (after SBCL)
- hash table extensions are documented in newdoc
- various cleanups performed in the compiler
- compiler is less verbose by default now
- ~ext:run-program~ has been rewritten (almost) from scratch
- improved documentation of operating system interface (newdoc)
- example of parsing arguments in standalone executable (newdoc)
- example of using shared libraries from C world (newdoc)
- reduced =format= directive tables size
- simplified ~atan2~ implementation by using c99 equivalent - now we
  produce correct output for signed zeros, infinities and nans.
- configure script supports new options =--with-libgc-prefix=,
  =--with-libgc-incdir= and =--with-libgc-libdir= (these flags work the
  same as flags for =libffi= and =libgmp=)
** Issues fixed
- issues with type system revealed by sbcl bootstrapping are gone
- classes are not defined at compilation time
- weak hashtables mishandled weak values when keys were present
- gethash on weak hashtables returned the pointer instead of the value
- maphash on weak hashtables mapped over pointers instead of the values
- initarg caches are now invalidated when new methods are defined. Problem
  found and fixed by Alexander Wood.
- ECL allocated too much space in lisp stack. Instead of the specified size
  x in bytes, ECL allocated roughly x^2/p where p is defined in
  LISP_PAGESIZE (2048 by default). If you're setting the value of
  ECL_OPT_LISP_STACK_SIZE, please check whether you really have
  set a high enough value.
- ~block/return-from~ fixed (didn't work across some closure boundaries)
- ~mp:semaphore-signal~ fixed (race when count was > 1)
- Multiple native threads issues fixed
- ASDF systems like foo/base and bar/base doesn't have conflicts in bundles
- interactive input stream in ext:run-program on Windows
- removed race condition between waitpid and sigchld handler on UNIX
- buildsystem parallel builds work (i.e make -j999)
- ECL builds on consoles with unusual encodings on Windows (i.e cp936)
** API changes
- ~LISP~ and ~USER~ package nicknames to ~COMMON-LISP~ and
  ~COMMON-LISP-USER~ are removed
- make-hash-table accepts a new keyword argument ~:hashing-function~
- no-op ~--enable-asmapply~ configure option has been removed
- ~profile~ and ~rt~ contribs are now deprecated and disabled by default
- thread-local variable support has been removed (~--with___thread~)
- deprecated configure option ~--enable-opcode8~ has been removed
- mk-defsystem is not build by default (enable by ~--with-defsystem=yes~)
- asdf:make-build accepts ~:init-name~ argument for libraries
this allows specifying human-memorable initialization function name to call
in C code
- package local nicknames protocol (documented in newdoc)
- make-hash-table accepts ~:synchronize~ flag for thread safe variant. New
  predicate ~ext:hash-table-synchronized-p~ implemented
- make-hash-table ~:weakness~ argument new variant ~:key-or-value~
  implemented
- No more explicit option in ~main.d~ to trap SIGCHLD asynchronously
- Zombie processes are cleaned in ~external-process~ finalizer. If process
  is still referenced in the memory, it's programmer duty to call wait.
- The ECL_OPT_SIGALTSTACK_SIZE option has been removed, because it had no
  effect.
- Non-standard package nicknames (USER for COMMON-LISP-USER and LISP for
  COMMON-LISP) have been removed.

"Okay if you have tested it" from wiz@, tested mostly with math/maxima.

---
## [petre-symfony/modern-react-udemy](https://github.com/petre-symfony/modern-react-udemy)@[43149c6646...](https://github.com/petre-symfony/modern-react-udemy/commit/43149c664693ee59e03ba80d134704c67136aad5)
#### Thursday 2020-07-09 10:14:22 by petrero

320. Bulk Action Creators(Section 24: REST-Based React Apps)

In the last video we finished up our create stream action creator.

So now after we create our new stream our response we get back has the newly created stream model according

to our API with the new ID inserted in there.

And so we are now going to dispatch an action that has a payload of the data that we got back in response.

Now before we move on and start working on reduce or anything like that I want to point something out

about following these restful conventions inside of our application.

Now I took that restful conventions chart right here and I added on a new column that says response.

My response right here.

I mean to indicate what our API server is going to return anytime that we make this type of request

to it.

So if we make a request to slash streams we're going to get back an array or list of records a get for

a single record will return a single record a post two streams will return the record we just created

a PUT will return a single record and a delete to a single record is going to return nothing at all.

So if we are truly following restful conventions then you and I kind of already know exactly what our

responses are going to be from that API server.

So I kind of have a crazy thought here.

Even though we do not have any component to show a list of streams even though we don't have a component

to edit a stream even though we don't have a component to delete a stream.

Even though we don't have any components put together right now because if we follow restful conventions

we know exactly what data we are working with.

I think that we could actually create all of our action creators right now and kind of get the entire

process of writing out these action creators done with right now as opposed to having to always come

back to the actions index not as file and creating each of these different action creators as we work

on each different part of the application.

Again we are only able to do this because we are following restful conventions to a tee.

We're doing exactly what is recommended with them.

So I think that's what we'll try doing.

We're going to try to put together all of our action creators right now an action creator for creating

a stream or fetching a list of streams for getting one for editing and deleting and then we're going

to try to eventually wire these all up to our different components when we eventually create them.

Now it's entirely possible that we might make a mistake here or there but I think that in general this

might actually work out.

All right.

So let's give it a shot.

So we're going to create separate action creators for each of these different operations.

We already did one for creates.

So we're going to essentially make for others.

The first thing we're going to do is create types inside of our type start J.S. file one for each different

operation that we expect to do.

So inside if you're going to write out a couple of different types I'm going to add in export Konst

batch streams as fetch streams.

So this will be the type for whenever we get all of the different streams that exist inside of our API.

I'll do a export Konst fetch stream that singular so there's no it's not deemed stream.

There's no s on there so this is going to be the type that we use any time that we fetch a single record

by itself.

So fetch stream will do a delete stream.

They'll eat.

Sorry my hands are really cold right now making all these typos.

OK we've got delete.

I think we need the update.

So this will be something like maybe edit stream

so edit Stream.

And I think that's about it.

I think we've got all five cases.

So creation fetching a list fetching an individual deleting a record and editing a record.

Now that we've got all these types put together we can import all five of them or the remaining four

I suppose back into our actions index not just file and then create action crater's for each one.

So I'll put the import statement for my types at the top.

I'm going to first give myself a little bit of space here.

I'm making this into a multi-line import statement like so.

And then I'll get all of those other types that we just created.

Now as a quick shortcut here if you are on the code or using Adam right now you can use that command

D or control d hot key to very quickly copy paste all these types over.

So if you want to you can highlight say can strike here and then hit either command or control.

If you are on Windows and that will multi-select conc like so then you can hit right arrow twice to

get the cursor next to all those types and then you can do a little shift select like so to get each

of those different types and then copy all that go back over to the index file and paste them all in

like so.

Now if you're not going use that shortcut totally fine.

Just make sure that you import each of these different types and then get a comma after each one except

for the last one.

Now after you do all that I recommend you save the file flip back over to the browser and just make

sure that you're not getting the error message saying something like Oh this type doesn't exist if you

are seeing an error message saying that some given import does not exist.

It very likely means that you made a typo ok.

Now that we've got all of our types Let's try putting together an action creator for one of our most

basic actions which is to fetch a list of all the different records that we have on that API so underneath

create Stream right here we're going to create a new action creator that we'll call something like fetch

streams.

So this is going to be an arrow function that returns a funk function like so.

And then inside of here we're going to follow our restful conventions.

I can't say it enough so we're going to make a get request to slash streams using our ASIO's instance

Zola's say construct Spawn's is a waste stream start get flash streams and then I'll do a dispatch with

a type of fetch underscore streams and a payload of response data like the.

So it can essentially just repeat this process a couple times over.

I would encourage you to not do a copy paste here just because it's going to increase the probability

of you accidentally forgetting to change like a typo or something like that.

So I would encourage you to type each of these out and triple check to make sure that you've got the

correct function name and the correct type inside of each one as well.

The next one will do is the patch for a single record.

Now notice when we fetch a single record we need to know the idea of the record that we're trying to

fetch.

So we'll create a new action creator called fetch stream.

So no s on here because this is fetching just one stream as opposed to multiple.

And then when we call this action creator we're probably going to want to pass in the idea of the stream

that we are trying to fetch.

So on the initial function right here the actual action creator function I want to make sure I pass

in some ID argument and I'll do my async dispatch and inside of your I'll say Konst response.

So we'll do our streams Dogget And then this time we want to make a request to slash streams slash and

then the ID of the one that we're trying to fetch to do so I'm going to use a yes 20:15 templates string

here.

So put in my back ticks like so and I'll say slash dreams slash dollar sign curly brace ID.

And then I'll do a dispatch type of fetch stream.

So notice here on stream's we have streams so s and s on fecche stream individual one we have Fettes

stream no s and no s on the type there as well.

Then for our payload we'll do a response loop response data like so OK.

Just two more I think just edit and delete.

So let's do our edit stream action creator.

Now this one is going to be a little bit more challenging.

Anytime that we edit a stream or try to update it we need to provide both the ID and the update that

we're trying to make to that stream as arguments to the actual creator.

This is one where Ill make a little bit more sense later on when we start working with this creator

more directly.

But essentially we want to kind of combine the idea of receiving the idea as an argument from fecche

dream with the idea of passing inform values that we used up with create stream as well.

So for it stream I'm going to receive the ID of the record I want to edit along with some form values

that contain the actual updates I want to make to that particular stream.

So then again do an async dispatch.

Got my Konst response streams dot and then in this case we are making a put type request try to make

a point type requests with axially will call streams dot put and then just as before we need to make

sure that we specify the actual ID of the stream that we're trying to edit I'll use a template string

again and I'll do streams slash dollar sign ID and then we need to make sure that we communicate the

updates that we want to make.

So in the body of this put request will specify form values

and then we will again dispatch type edit stream that the payload of response data.

And then finally the very last one is going to be delete.

So were going to make a delete type request to that give an ID.

And in this case we get nothing back.

So our Palit property this time round is going to be just a little bit different.

Its all due in export Konst delete stream.

This will be called with some ID.

I'll get my async dispatch.

I'll do Konst response.

It.

Actually we don't actually need any response in this case because the response is going to be empty

so I'll just leave that off and I'll do an oh wait streams start.

Delete.

So that's how we make a delete request with X-ers.

And then again we need to specify which stream we're trying to delete so I'll put my back ticks in for

a template string and I'll do stream's slash dollar sign.

Really brace ID.

Now in this case and we do our dispatch we're not going to have any payload data property we will have

a payload but we're not going to put the response data on there.

So I'll do a dispatch type delete stream and then this time around I'll put on a payload for the payload.

I'm just going to put in the idea of the stream that we just attempted to delete like so and this is

going to make a lot of sense a lil bit later on when we start to write out our.

OK.

So that's pretty much it.

We were able to write out all of our different action creators because we are following restful conventions

and we know exactly what route we are trying to make a request to what information each request type

needs in terms of like ID and updating with some information.

And we know exactly what the response is going to be in each case and that's the only reason that we

were able to write out these kind of early drafts of each of our action creators.

So really quickly I'm going to save this file and then I'm going to flip on over to my browser and make

sure that I don't have any error messages such as the one that you see right here.

So looks like I have a mistake on line 46 so I'm going to double check that really quick.

Looks like I made a typo in response so I should be response instead.

I'll fix that up that way.

Go back over.

I don't see any error messages besides that.

So if you have any other erimus just extraordinarily likely that you just made a typo.

Please read that error message.

It will tell you the exact line that you made the typo on.

Chances are you made a typo like me or you might have kind of messed up some syntax some of these objects

or something like that.

Now I would encourage you as well to make another double check of all of your types.

So you should see.

Create screen create stream batch streams streams that stream fetch stream and stream edit stream elite

stream delete stream.

All right so this looks great.

So we've just knocked out a ton of work here all in one go.

And this is going to save us a lot of time down the road because I'm not going to be saying to you like

every other video.

Oh yeah let's go put our action creator together.

So let's take a pause right here.

We'll come back the next section and continue working on her at.

---
## [petre-symfony/modern-react-udemy](https://github.com/petre-symfony/modern-react-udemy)@[346ec583c3...](https://github.com/petre-symfony/modern-react-udemy/commit/346ec583c3d6fc64dc50c91d22d193f4adc95dee)
#### Thursday 2020-07-09 10:14:22 by petrero

319. Dispatching Actions After Stream Creation(Section 24: REST-Based React Apps)

In the last video we created our first New Stream we're going to go through the process of creating

one more Stream right here so I can put in a quick title of stream and a description of here's some

stream and I've got my network request Lague open again.

I'm going to submit this and then check out the post requests that we had created.

All right.

So when I inspect this thing I'm going to open up the preview tab and you'll notice that we get back

a response right here of the description the title and the newly assigned ID from the API server.

So at this point we've basically got this new record that reflects stream that we've just created coming

back and the response that we made over to that API.

So when we start to think about that and think about our actual creator back you're inside the actions

index file.

I think that we need to somehow get a handle on the response that comes back from that post request

because it contains the actual saved record of the stream that we just created.

So inside a create stream I'm going to put the weight keyword on there will say cancer response equals

a weight stream's up post.

So now that we have a handle on the stream that just got created we're probably going to want to dispatch

an action with a payload of that stream and then we can eventually create a reducer and pick up that

stream that was created and save it inside there or whatever it is we want to do.

So in order to dispatch an action we first need to have a type.

Remember we now have this idea of these constant type value.

So we define inside of our types file.

So let's open up that type's file rate a new type inside there and then make sure we import it into

this indexed file.

So here is types.

I'm going to create a new type of.

How about create stream and then I'll give this a type of create stream for the actual string value.

OK so that looks good.

So now we'll save this a flip back or two that actions index as file and I will import create stream

at the top.

Now we have everything we need back down inside the Create stream action creator itself.

After we get our response I'm going to dispatch an action with that type of create stream for the payload.

I'm going to make sure that I take response data and return it with the data right here because remember

when we get a response back from ASIO's the response object has a ton of information about the response

but we only care about the information that was returned inside the request.

So that's why we are only returning response to data inside that pallet property.

OK so looks great.

Now the only thing here is we don't have a producer so we can definitely go and create ever douceur

that's going to essentially save the stream that we just created inside of our application level States.

But before we do I want to take a quick pause and then mention something kind of interesting about all

the action creators that you and I are going to end up creating.

So quick pause you know I'll see you in just a minute.

---
## [SmexyKatarina/Everything](https://github.com/SmexyKatarina/Everything)@[cbf3ebadca...](https://github.com/SmexyKatarina/Everything/commit/cbf3ebadca9cb9c1bdd687539a847da3649550a3)
#### Thursday 2020-07-09 10:56:40 by Adam

Removed the useless tree textures from files

God damn it fucken treeeeeeeees

---
## [PhoenixTours/AnaliaSmith](https://github.com/PhoenixTours/AnaliaSmith)@[2eb913d916...](https://github.com/PhoenixTours/AnaliaSmith/commit/2eb913d916dbb6201259f3bb53f6cbcbffb6d2ac)
#### Thursday 2020-07-09 13:02:33 by PhoenixTours

We Shape our Buildings

JB INDUSTRIES:
JB Industries, Established in the year 1966, An ISO 9001:2008 Company in one of the leading producers of Plaster & Wall putty. The company with an overall experience of Four decades and extensive R&D has been contributing to multi-sectoral needs through its product excellence & technology.
The company has its manufacturing Unit at Hisar with a production capacity of 1.5 Mn TPA. The company has a strong presence & network in north India.
OUR CORE VALUES:
QUALITY: We are committed to producing the best quality products to match the best standards at reasonable prices.
ECO-FRIENDLY: We believe in producing quality products keeping in mind to maintain the eco-balance and ours.
TRUST: Over the years our commitment to quality and service we have been able to maintain the trust of ours.
SERVICE: Our commitment to being honest & ethical in all our production, market, financial & operational practices.
JB Plaster Products:
JB Plaster: JB Industry is manufacturing  JB One Coat plaster (VermiGyp) Our products JB Gypsum Building Plaster & JB One Coat Plaster are available in 20/25 Kg HDPE bags.
JB-Wall-Putty: We, J.B.Industries are manufacturing Plaster of Paris in the name of J.B.Plaster from the year1996 at our Hisar (Haryana) Plant. Now in addition to it, we have started manufacturing a product used for holding the structure of False Ceiling called Hex Bolt Expansion sleeve fastener at our Hisar Plant.
JB-Vermigyp: JB Industry is manufacturing JB One Coat plaster (VermiGyp) Our products JB Gypsum Building Plaster & JB One Coat Plaster are available in 20/25 Kg HDPE bags.Our products JB Gypsum Building Plaster & JB One Coat Plaster are available in 20/25 Kg HDPE bags.
JB-Bond: JB Bond is a bonding agent that provides excellent performance to bond Gypsum Plaster /Sand Cement Plaster on smooth low suction internal RCC surfaces and it eliminates hacking roughening and putting wire mesh on the concrete surface. It is specially formulated for ready to use adhesive consisting of organ resins with additives.
JB-Fasteners: We, J.B.Industries are manufacturing Plaster of Paris in the name of J.B.Plaster from the year1996 at our Hisar (Haryana) Plant. Now in addition to it, we have started manufacturing a product used for holding the structure of False Ceiling called Hex Bolt Expansion sleeve fastener at our Hisar Plant.
JB-Screws: J.B. Dry Wall Screw is a specialized Self Tapping Screw. These Screws have a Bugle Head. J.B. Dry Wall Screw can be easily identified by its black finish. This black coloring comes from a phosphate mineral Coating that is applied to these Screws. This coating helps to minimize rusting & corrosion as the Screws are exposed to wet joint compound/Paint.
Research-Development:
Continues Research and development is an integral part of the company’s policy. This has led us to produce one of the best product ranges in the country and meet the needs of the customers. By adopting new technologies & innovation we continue with improvement in existing products and development of new products. 
Our R&D team & latest equipment has helped us to meet global standards. 
With the best equipment and R&D specialists our aim to continue producing new & innovating products & helping the construction industry grow in India

---
## [petre-symfony/modern-react-udemy](https://github.com/petre-symfony/modern-react-udemy)@[64b4f3c325...](https://github.com/petre-symfony/modern-react-udemy/commit/64b4f3c325ca6356a61864b838d2e0dc13ab27cf)
#### Thursday 2020-07-09 16:00:10 by petrero

332 History References(Section 24: REST-Based React Apps)

In last video we spoke about where we are going to trigger some programmatic navigation.

So immediately after we successfully create our Stream we're going to attempt to navigate our user automatically

back to our route route.

Now in this video we're going to talk about how we actually do programmatic navigation.

Now here's the good news and the bad news.

The good news is that programmatic navigation sometimes with re-act writer Dom is really easy but sometimes

it's really not easy at all.

So unfortunately we are in one of the scenarios where it is not super easy to do programmatic navigation.

Let me tell you why.

OK.

So quick diagram here.

Now we've looked at this diagram quite a while ago.

Remember we have a browser router at the very top of our component hierarchy internally internally the

browser router creates this history object.

Remember we spoke about how this history object keeps track of the address in the address bar of your

browser up at the top.

So anytime that address changes the history object is going to communicate the change over to the browser

router.

Now the history object over here is not only about watching the address bar the history object also

has the ability to change the address bar as well.

And that's how we're going to do pro programmatic navigation.

We are going to make use of this history object.

Now the reason that is said had said that sometimes programmatic navigation is easy and sometimes that's

hard is the fact that this history object is created by the browser router.

In other words it is kind of challenging for you and I to write code that can get a handle or a reference

to that history object.

It is more challenging than you might expect.

Let me show you why.

OK.

So here's essentially what goes on in normal operation with re-act router.

Internally the browser router creates this history object then any time that the browser router renders

some component like let's say PAGE ONE Capone right here the browser router passes that history object

as a prop down to your component.

So inside of any component that gets rendered directly by re-act router it's going to receive this history

object.

And so this Complan right here could very easily trigger some navigation inside of it.

Now that's the key word here.

The component could easily trigger navigation inside of it.

But in our case we are not trying to do navigation from a component we are trying to do navigation from

an action creator getting access to this history object inside of a action creator or any non-HD Riak

component essentially is what is a little bit challenging it is hard for us to get a reference to that

history object.

One very simple solution would be to do something like this.

So weve got our history object that gets created by the browser router the browser router communicates

the history object down to our component and then we could say that any time that our component calls

or action creator the component should pass along the history object into the action creator.

And so that's essentially saying that inside of our action Krater right year we would receive not only

our form values but also some history object as well.

Now this is kind of a pain because it means that every single time we want to do programmatic navigation

we would have to write our action creators to be called with a history object and we would make sure

that all of our components called the action creator with the history object as well.

So even though this is possible it is not super ideal.

So were going to use an alternative solution and remember the solution when I show it to you is going

to look a little bit weird.

The reason we are going through the solution is that just getting access to this history object is a

pain.

All right so heres a solution.

Remember I told you that the browser router internally creates the history object and the fact that

the browser router maintains that history object is what makes our life all that challenging.

So essentially we're just going to kind of turn the tables on the browser router.

You and I are going to create the history object instead.

So you and I are going to create a history object inside of a dedicated file inside of our project.

Then any time that you and I want to get access to that history object we're just going to import that

file.

We're going to import the history object very easily because we are maintaining control over the history

object ourselves and we are not allowing re-act router to create the history object itself.

So that's how we get easy control over it.

This history object we created ourselves as opposed to allowing re-act router to create it now is a

little bit of just odds and ends here just fine grained details.

When we create this history object we're going to create a history object that is the corresponding

type to whatever router we had created.

So remember before we had made a browser router whenever you create a browser router internally that

creates an object not just called history it's the browser history object or like the browser flavor

of the history object.

If you watch that optional video many many many videos around a go around browser router and hash router

in memory router.

You'll recall that essentially these different routers.

And now I'm telling you the history object as well just changes what part of the neural that re-act

router looks at to decide where a user is trying to navigate to.

So when I say browser history we are creating a history object that is going to look at everything after

the port or the domain of your address to decide what content to show on the screen because we are now

creating our own history object.

We are no longer going to create a browser router object as the top of our component hierarchy.

Instead we are going to create a create a plain router we create a plain router when we create the history

object ourselves again.

It's not like the worst thing I would think I'm making a little bit more complicated than it needs to

be here.

Essentially when we create a browser router browser router internally decides to create a browser history

so now that we are creating a browser history ourselves we use a generic router.

That's basically it putting in much more simple terms.

Okay enough discussion.

Let's actually get to business here.

Let's take a quick pause and we'll start putting together this custom browser router between browser

history object in the next video.

---
## [petre-symfony/modern-react-udemy](https://github.com/petre-symfony/modern-react-udemy)@[40294d9b65...](https://github.com/petre-symfony/modern-react-udemy/commit/40294d9b657f652bb864bdb8071dcc846be06b07)
#### Thursday 2020-07-09 16:00:10 by petrero

321. Object-Based Reducers 322. Key Interpolation Syntax(Section 24: REST-Based React Apps)

In class video we put together a bunch of different action creators inside of our actions index j s

file.

We did this all in one go just so we didn't have to come back over to this file nonstop throughout the

rest of this application and talk about like the next action creator we had to put together.

Now we're going to take a very similar approach for putting together our reduce or as well.

We're going to start to work on our stream reducer inside this video and we're just going to put the

entire seducer together in one go as opposed to having me kind of spread putting the reducer together

around a couple of different videos throughout the rest of the application.

Now for the producer we're going to put together we're going to do things just a little bit differently

than we have in the past.

So let me show you a couple of diagrams to help you understand exactly what I mean by differently.

All right.

So this right here is a diagram of more or less how we have been creating reducers throughout this course.

Any time that we had a list of records that we wanted to maintain so we could as an option we could

totally have a stream's producer that always returns an array of stream objects.

So each of these little boxes right here represent a separate stream that has been created by a user.

Remember that every stream object is going to have a title and a description assigned by the user.

And it's also going to have an id property and that ID is going to be assigned by that API.

So if we wanted to follow the same convention as we've seen throughout the course we could return an

array that has a list of all these stream objects inside of it.

Like I said this time around we're going to do things a little bit differently.

And the reason that we're going to do this differently is that it's going to make many different operations

around maintaining an array much easier than if we had a array.

OK.

So here's what we're going to do instead.

So we are still going to have a stream producer.

It's going to behave as a reduce or it usually would.

So we're going to add it to the combined reducers call.

But rather than returning an array of streams it is going to return an object that has all the streams

inside of it.

So we're going to return an object instead of an array inside a subject we're going to have a collection

of key value pairs as you would expect inside of an object.

The key for each of these key value pairs is going to be the ID of a stream.

So let's say right here if we had a key of one the value for that would be the stream that has an idea

of 1.

If we have a key of 22 the value b the stream with ID 22 and if we had a key of 37 the value would be

the stream with ID 37.

So in order to kind of access any given stream inside this object we would just have to reference our

streams piece of states out of our redux store and then essentially try to access the appropriate ID

inside there.

And that will give us the stream that we're looking for now besides making accessing records a little

bit easier.

Also modifying or updating data from our streams reducer will be a lot easier as well.

So we looked at this chart right here a while ago.

Now I want you to recall that one of the steps that we looked at was how we replace an element in an

array.

So this case right here of replacing an element in an array would be applied any time that we called

our action creator of edits Stream right here.

So whenever we call edit Stream we are attempting to update a stream on our API.

So we make the request to update the stream.

We then get the updated stream back as the response from the API and then we're going to dispatch an

action of type at it Stream right here with our payload that has the stream inside of it.

And so when we got back this updated stream we would probably want to find the original stream with

the identical ID inside a very douceur and removed the old version of the stream and put in the new

version right here.

So if we wanted to do that with an array based approach we would have to write out some code like you

see right here.

We would have to map over all of our different stream records inside of the reducer.

We would have to find the Stream but the idea that we cared about and then returned the newly updated

stream but if we were making use of a object from Ari douceur the updating process would be much more

straightforward.

We would put down the curly braces to indicate a new object.

We would take all the records out of our old state object and add them in and then we would add in a

new key value pair.

But in this case the key would be the ID of the stream that we just updated.

So let's say if we updated stream with ID 65 we would put in a key of 65 and then the value would be

stream with the ID is 65.

So basically the syntax here of updating our state is going to be so much easier when we are making

use of an object instead of an array.

Now to make this really kind of sink in and help you really understand this I want to write out a little

bit of sample code.

So I want to write out a little sample code to show you how we would update a record inside of an array

if we were using the array based approach and then do the same thing with an object as well.

And you're going to very quickly see that.

Yup.

If we use an object to store all of our records life is going to be much easier.

So I'm going to flip back over to my editor and I'm going to open up a brand new file.

I'm not going to save this file.

This is just some sample code.

So you do not have to write this out.

I just want to very quickly show you how much code we have to write out to update records when we are

making use of an array inside of a reducer All right I'm going to first do the array based approach

so I would have something like stream reducer and I'm going to default my state to be an empty array

because that's the kind of case that we're going to look out for right now.

And then I would switch over my action type I would have a case inside of your of it stream because

it's the only case I want to show you very quickly I'm going to put the default on here just to be complete.

So then inside of here if we fell into the edit stream case chances are our action object right here

would have a payload of the newly updated stream that just came over from our API so we would then need

to look through our state array right here find the old stream with the same ID remove it and replace

it with the new stream and see that action object.

So to do so we would end up with something it looks like this.

I would return States on map.

I would iterate over every string that I have inside of my state array and then I would say something

like if the old stream ID is equal to action payload ID search number x not Paillard right here.

That is the new stream that just came back from our API.

So if the stream that I am iterating over has an ID equal to the stream that was just updated I want

to return the new stream and not the old one.

So I would put in return action payload and then I would also have to handle the else case here.

So if it was not the stream I was looking for I would just return the stream itself.

OK so that is a producer right there that is going to use an array based approach.

And this is how much code we have to write just to find the appropriate record inside of that array

and then replace it.

So this is handling the audit stream case.

So lets take a quick pause right here.

When we come back the next video I'm going to show you the same example but we're going to use an object

based approach instead.

And you're going to very quickly see that it requires way way way less code to update records inside

an object as opposed to this array approach.

So let's take a quick pause right here.

When we come back the next video I'll show you that quick example.

322. Key Interpolation Syntax

Unless video we put together an array based approach for our Stream reducer or handling specifically

at it stream case.

The reason I wrote out the sample code right here was just to show you that to handle replacing a record

inside of an array we have to write out a pretty decent amount of logic.

So we're now going to take a look at a object based approach instead and with this object based approach

we're going to have dramatically less code to write out and there's going to be a couple of other very

big benefits as well.

Now I want to remind you again that the code I'm writing inside this file is all temporary.

I'm going to delete this code in just a little bit.

I just want you to see the code for yourself on the screen.

All right so I got to go down to the bottom the file and I'll write out an object based approach.

So down here I will again create a stream reducer this will have a default state argument but this time

it is going to be an object as opposed to an array.

Then inside of your I will switch over my action type allowed on my default case and I'll also add on

the case of edit stream as well.

So once again I want to imagine how easily we can update a stream when we are using an object.

So to do so I would probably write out something that looks like this.

Let me show you exactly what I would probably do.

I would probably say something like new state is going to be a object.

I'm going to take all the key value pairs out of states and spread them in there with the dot dot dot

syntax.

So all this line right here is doing is creating a brand new object that has all the same key value

pairs as the state object right here.

Now the reason that I have this line of code right here is just to return a new object from my reducer

remember a while ago we took a look at the source code of redux and we saw that if we do not return

a brand new object redux is going to assume that we did not update anything from a producer.

So this line of code right here is just to update that object or just to create a new object.

So now that we have created the new object we want to somehow update the appropriate key value pair

inside of it.

So now in this approach we're going to have the IDs or I mean the keys be the idea of the stream and

then the value will be the stream itself.

So our ID is on that action object and the actual stream itself is on the action object as well.

So I could write out something like new state and I will use the property accessor notation here to

reference action payload.

ID as a reminder action that payload is the stream and the stream object contains the ID of the stream

as it was assigned up by our API.

So this is going to access our state object specifically at some given ID.

And we're going to set that equal to our new stream like so.

And then finally I can return new state OK.

So that's what it would look like with an object based approach.

Now when you look at this it still doesn't look that great.

We still have three lines of code right here just to create a new object assign a property to it overwriting

any existing property there is and then return it.

So at present it's not really a great improvement over our edit stream up here.

We still have some complicated syntax inside there but it turns out that there's a little bit of yes

20:15 syntax that we can use to significantly reduce the amount of code that we have to write right

here.

So I'm going to comment that out I'm going to show you an alternate approach.

This alternate approach is going to do the exact same thing that you see right here but it's going to

do it all in a single line of code.

So I'm going to write out return a new object.

Dot dot dot state.

And then here's where it gets crazy.

I'm going to put in square brackets action.

Payload dot ID I'll close off the square bracket or then put in a colon and then I will assign action

not payload like so.

All right so that's the crazy as 20:15 syntax.

So the code that you see right here is identical to what you see right here.

The syntax you see right here with the square brackets.

This is not creating an array even though it looks like an array.

It is not an array of being created.

This is what is referred to as key.

Interpellation.

So this essentially means we don't know exactly what key we want to add to the object.

We know that the action not payload id property is the key that we want to add but we want to somehow

add it in that key.

Like when this code runs we don't know what the key is ahead of time.

So in other words I can't write out something here like five.

I can't hard code the key because I don't know what the ID of the stream is going to be.

So by using the syntax we are saying look at the action of payload id property look at that idea whatever

the ideas whatever the number or string or value is take that and create a new key using it inside of

this overall object and to that key a sign action not payload.

Like I said this approach right here and this approach right here.

Totally identical.

But the second approach is far more concise.

So now I could delete that commented out stuff and I'm left with just what you see right here.

And so I think that at this point you would agree with me that this code is far more simple and straightforward

than the array based approach appear even though it has that crazy new syntax.

You still are going to eventually understand what is going here.

What is going on here far more easily than if you had to read out that entire map statement in the array

based approach up your.

OK.

Now as one last quick thing just to show you very quickly and make sure that the syntax is very clear.

I want to flip on over to my chrome console and write out a quick example to show you exactly how the

syntax works.

So if you already understand the syntax puzzle that you're right here.

Otherwise stick around.

And we're going to go through a very quick example.

OK.

So to help you understand that syntax I'm going to flip back over to my application and open up my console

and then inside if you're going to create a new object that I'm going to call animal sounds.

So this is going to be an object that has some key value pairs inside of it of the different sounds

that animals make.

So for example a cat goes meow and a dog goes bark.

So going to create that object and then we'll imagine that at some point in time in the future we want

to add in a new key value pair but the keys and the values that we want to add in are already assigned

to some array or some means to some variables.

So let's say that we want to add in a new animal of lion and the sound that it makes is roar.

So now I want to use the animal and sound variables to add in a new key value pair to animal sounds.

So to do so I could write out Crilley brace dot dot dot animal sounds all then do the square bracket

and put in animal clothes off the square bracket.

I'll put in a colon and then sound like so.

So now this is going to say take whatever string animal references and added as a new key to this object.

And for the value use the sound variable.

Now I can run this and I'll see that I get cat meow dog bark lion roar.

All right so that's it.

Now again the syntax here I can't say it enough.

We are not creating an array.

This is not an array.

This is string interpellation or something.

The key interpellation syntax not string interpolation string interpellation different thing.

All right so now we have a better idea of what's going on here we'll take a quick break right here and

when we continue in the next video we're going to start putting together our real stream reducer.

---
## [petre-symfony/modern-react-udemy](https://github.com/petre-symfony/modern-react-udemy)@[a01166592a...](https://github.com/petre-symfony/modern-react-udemy/commit/a01166592afacc8b4dd106b7207dd3170be37ff4)
#### Thursday 2020-07-09 16:00:10 by petrero

329.2. Conditionally Showing Edit and Delete(Section 24: REST-Based React Apps)

Let's add on a little bit of styling now just to make sure that this thing looks a little better than

it currently does.

So I'm going to flip back over to my component.

I'm going to delete the div inside of here and I'm going to put in a multi-line GSX lock instead.

So I'm going to place a div with the class name of right floated content and then inside of there we're

going to eventually turn those edit and delete buttons into links that are going to take the user to

some other page.

Remember that was the entire idea here if you clicked on delete or edit it would take you to either

the edit stream form or the delete stream page.

But for right now we'll just place in some buttons just to have something there and once we actually

put those pages together then we can actually hook up some links or functionality to these buttons some

place a button with the class name of UI button primary

closing button tag.

And I'll give this first button about it and I'll do a class name UI button.

Negative negative is going to make the I did it again negative is going to make the button appear red.

So that's going to be the delete button.

And we probably want that wants to be read just so the user understands hey this is kind of like a dangerous

action that's going to delete some resource.

All right.

Now the other thing that we're going to do here this seem a little bit weird but basically to get semantic

UI to style everything correctly we actually have to move this div right here with the two buttons to

the very start of the div with the class name of item.

In other words we have to call the method not down here at the bottom.

We have to call it before the eye tag right there.

In order for semantic UI to style everything appropriately.

So now I'll say this again it looks like I got my code here a little bit reformatted but it's still

the same it was before.

And then if I flip back over to my application.

Yeah there we go.

So I nicely see edit and delete on the right hand side of the string that I created.

So again if we click on these buttons right now nothing happens.

So we're going to eventually have to wire some functionality to them.

Now the other thing I want to check your really quickly is see what happens when we sign out of the

application if we sign out.

Then my current user ID is not going to be equal to this stream's user ID and so I should not see the

buttons anymore.

Once I sign out of the application so I click on the sign out and as a matter of fact those two buttons

go away.

And now if I sign in as the same user again the buttons come back because I'm now logged in.

And again my user ID is equal to the user ID inside of that third stream.

All right so this looks pretty great.

Now there's one less thing we need to take care of we need to make sure that at the bottom of this page

whenever user is logged in we show the button to allow a user to create a stream.

So let's take care of that really quickly in the next video.

---
## [petre-symfony/modern-react-udemy](https://github.com/petre-symfony/modern-react-udemy)@[83ebf6549a...](https://github.com/petre-symfony/modern-react-udemy/commit/83ebf6549a7cc1343721c210f4a70faf0940dc89)
#### Thursday 2020-07-09 16:00:10 by petrero

323. Handling Fetching, Creating, and Updating(Section 24: REST-Based React Apps)

In the last video we learned about a little bit of new syntax so we can use to dynamically out in new

key value pairs to an object so that we understand all the syntax we're going to start to work on our

real stream reducer to get started.

I'm going to delete this temporary file I created.

I'll then find my reducers directory.

And inside there I'll make a new file called stream reducer.

Yes.

And then inside if your will first begin by importing our actions file or some of the action types file.

So I'm going to import a couple of different types from up one directory actions types.

Now we're going to get a couple of different types like I said we're going to want to handle all these

different stream types.

So create stream.

Fetch.

Fetch streams delete stream and stream as well.

So I'm going to import each of those.

So I'll do a fetch stream.

I'll do a fetch stream's create stream edit stream and delete stream as well.

Then after that I'll add in some boilerplate for a reducer.

So I'm going to export default state which we defaulted to be an empty object.

I'll receive my action and then inside appear we will set up our switch statement so I can switch over

action type and I'll set up my default case with return state right away.

OK so now we want to set up separate case statements to handle each of these different types.

Right here now as a quick reminder each of those different types maps up to a different response we

get back from our API.

So in other words when we see an action with the type of fetch streams specifically with the US that

means that we are getting back an array of records and we are going to want to take that array of records

and merge them all into our state object.

In the case of getting a single record.

So that would be the type of fat stream where in the case of creating a record or updating a record

so that would be create an edit right here.

We are getting back single records so we're going to want to take those single records and merge them

into our redux.

Or just me.

Our state object as well.

And then finally in the case of deleting a record we get back nothing from the API.

And in that case we want to find the appropriate ID inside of our object and remove that key value pair.

So essentially at the end of the day all I'm really saying here is is that we're going to be following

the same kind of conventions around updating and working with an object that we spoke about previously

and side of or sets foot back over the first case we're going to handle is fetch stream singular.

So just one stream.

So I will add in a new case of fetch Stream.

Now again notice there is no s on here we are doing singular fette stream.

So in this case I want to take my entire state object I want to create a new object and take everything

out the existing one and add it in like so.

So again this is what is going to satisfy.

Redux is requirement of always returning a new object.

Then the string that we actually want to add in is going to be on the action payload property.

So we want to make sure that we designate an ID from that action payload as our key and the value will

be the actual stream itself.

So I would use that new syntax.

We just spoke about in the last video.

So put in my square brackets action payload ID and then I'm going to assign that a value of action.

Payload like so.

So take a look at what is happening here.

Anytime that we get a action with tight fed Stream we're going to take our state object take all the

properties or all the key value pairs out of it and add it to the new object.

And then we're going to dynamically add a new key value pair on the fly.

It's going to have a key of the streams ID and a value of the actual stream itself.

And that's pretty much it.

That's all the code we have to write for handling getting a news stream.

So let's now do the same thing for creating a stream.

Remember when we create a stream the response we get back from our API is again going to be a single

record.

So we want to take that single record and add it into our state object.

So I would write out something like this.

I would say case create stream I will return a empty object with dot dot dot state.

And again I will take out of that action Palit property.

The idea of the string that was just created so action payload ID and assign it a value of action payload

and so you'll notice.

Yeah.

They end up being identical because we're just taking whatever payload is inside there and adding it

as a new key value pair on our state object.

So now let's do the same thing for editing or updating a record as well.

So again we get back a single record from our API and I want to take that single record in added into

our state object.

So I can do a case edit stream and it's going to have the same syntax we just saw a moment ago.

So I do return new object dot dot dot state square bracket action.

Payload Id close off the square brackets to get the colon and then action dot payload.

Yup totally identical in all three cases.

So in all three cases we are getting back a single record from our API.

We want to take that record and add it into our state object.

So it ends up being identical for fetching a single stream creating a stream and editing a stream as

well.

OK so this looks pretty great.

Now when we add in a bunch of different records at a in a single go or when we delete a record the syntax

or the steps that we're going to use is just going to be a little bit different.

So let's take a pause right here and we'll figure out how we are going to delete a record and add in

a bunch of records to our state object in a single line of code.

So quick poznań see you in just a minute.

---
## [petre-symfony/modern-react-udemy](https://github.com/petre-symfony/modern-react-udemy)@[8c018971e9...](https://github.com/petre-symfony/modern-react-udemy/commit/8c018971e95036f81115df577eca1e2928263b8d)
#### Thursday 2020-07-09 16:00:10 by petrero

325. Merging Lists of Records(Section 24: REST-Based React Apps)

In the last video we installed load ASH into our project I'm not going to flip back over to my terminal

and start up my development server with NPM start again making sure that I'm inside of my client directory.

All right.

Now once that starts back up we're going to recall that we are now trying to make sure that we can take

an array of streams from our API and merge them all into our state object in one go.

So doing this is going to be just a little bit challenging.

If we had a array for our state object and the producer it would be really straightforward to just kind

of concat the two arrays together.

But since we have an object we have to figure out a clever solution.

So here's what we're going to do.

All right so this diagram is a little bit confusing.

On the left hand side this is an array meant to represent the response so we get back from our API when

we get a list of streams.

So when we get a list of strings from the API they come back in an array and each stream has an ID title

and description property.

Now in order to get these things merged in to our object we're going to use a function from loadout

called map keys.

Map keys is an odd as a function that's going to take an array and then return an object that keys of

this new object are going to be taken from each individual record inside of the array.

So we can call map keys.

We can pass in the list of streams that we got from the API.

And as the second argument we'll put in a string of ID the string of ID right there tells lot ash that

for every one of these objects inside the original array use a key taken from the id property of each

one.

Now I know that sounds really confusing.

Essentially all we're doing here is saying OK create a new object they see right here look at object

number one inside the original array over here.

Look at the id property of that object.

So look at the ID right here whatever that value is in this case 12.

Use it as the key for this entire object.

When it gets added in to the new object over here.

So essentially we create a new key of twelf and then we assign the original object to that key and then

we repeat the process for all the other elements inside of here.

Now I want to give you a very quick code example of this so that you can understand how this works in

isolation.

So I pull open a little playgrounds Ed. here very quickly if you want to follow along you can open it

up in your browser.

That's the address right there.

So then inside of your let's make how about I don't know but an array of color objects.

And I'll say that this is going to be an array that has objects and each object will have maybe a few

I'll say the first one has a hue of green.

The second one has a hue of yellow.

By the way the word Q In English is kind of like a reference to color more or less.

I don't know someone who who's an expert in colors can tell me exactly what he means and will add in

one of blue as well.

So then if we did a underscore map keys we can pass in the colors object and then as a second argument

I'll pass in the string of what object or receive me what property I want to use as the keys from the

original colors array.

So in this case I'll put in Q Like so.

So you can see this is the object that gets that gets generated.

All we did was create an object.

We took each of these objects added them to that object and the key for each one is whatever the hue

property was.

So I see Aquia of green then the value is an object with the hue of green CAQ of milky of yellow with

a hue of yellow and aiki of blue with a hue of blue as well.

So we could imagine the exact same thing but with ID.

If I put an ID idea Id And then I put in like say three five and seven and then update the argument

right here to ID instead.

I now see that I get three points at the object with an idea of 3 5 ID 5 7 ID 7.

So that's what's going on with map keys.

So that's how we're going to take the array of streams we get back from our API and turn them into an

object.

And we're going to take this subject right here that gets generated from map keys and add them into

our state object.

OK.

So let's flip back over to our producer and we'll put this code together.

So back inside my producer and out in a new case at the top of fetch streams now I can't say it enough.

Please make sure you get the Ehsaan there.

I know at least some percentage of people watching this video some number of people are going to put

a s on this one down here and no s up here please make sure you've got streams and then stream.

Singular.

All right so then we're going to put in a return statement.

Now I'll do my underscore actually.

Let's do it the right way we'll put in our new object.

Dot dot dot state.

So we're going to create a new object take a key value pairs out of our current state object and then

we will do a dot dot dot underscore dot map keys action dot payload.

Id like so.

All right so this one looks a little bit different.

Right.

So again we are creating a new object.

We're taking all the current records we have inside of our state object and adding the men were then

calling map keys right here.

We're going to take the list of streams that we just got back from our API and we're going to create

a object out of it using map keys and the keys inside that object are going to be the IDs of the individual

streams themselves.

Now map keys returns a big object and we want to take all the key value pairs from that object and add

them into the new object that gets created.

So that's why I put the dot dot dot up here.

So take whatever big object comes from that keys take all the key value pairs out of it and add it into

the new big overall object.

That's pretty much it.

That's all we have to do for our reducer.

So now the last thing we're going to do is save the file and then going to flip back over to my reducers

index file and I'm going to import that reducer at the top

and then I'll add it as a new property on my combined reducers call.

So I'll say streams is stream reduce or now one thing I want to mention here very quickly you'll notice

I put.

Stream.

Cingular as opposed to like streams plural like so you can do it either way.

You can call it stream reducer or stream producer.

You can change the file name to be to suit as well.

It's totally up to you if you want to be singular or plural.

There is absolutely a great number of reasons to do it.

Either way it's really personal preference.

I would say all right now we'll save this and I'm going to flip back over to my application and I'm

going to essentially just make sure that I do not have any errors.

So if you see an error message at this point please read the error message the error message will tell

you exactly what you did wrong.

Sorry the error message.

And do any fix that it suggests.

And then once you get everything fixed up you should still see our application like so now I can also

open up my redux dev tools over here.

I don't actually see my new key.

You know what I going to make sure I select state right there.

That's why I had diff selected That's why I did not see the appropriate property inside there.

So if I select state I should now see off form and streams and streams should be an object which it

definitely has.

OK this looks great.

We'll take a quick pause right here when we come back the next video we're going to make sure that we

can fetch our list of streams whenever the stream list component is rendered on the screen and once

we get that in we'll then be able to verify that in fact we are successfully fetching streams from our

API and managing them with these streams reducer so quick and I'll see you in just a minute.

---
## [petre-symfony/modern-react-udemy](https://github.com/petre-symfony/modern-react-udemy)@[a1eb1efd95...](https://github.com/petre-symfony/modern-react-udemy/commit/a1eb1efd95f82ed23e4a50b9fb586a6fab90a994)
#### Thursday 2020-07-09 16:00:10 by petrero

327.1. Rendering All Streams(Section 24: REST-Based React Apps)

Now that we are loading up our list of strings into our application we want to make sure that these

get rendered out by the streamlets component.

Now as a quick reminder here's what our mock up is supposed to look like.

So in essence it's just going to be a pretty simple straightforward list very similar to the list that

we've rendered out throughout this course.

So let's just flip back over to our component and we'll get to work right away.

So I gonna flip back over to a stream list.

The first thing we need to do is to make sure that we get our list of streams available as props inside

of our component.

So I'm going to define a map state to prop's function

underneath our class.

Now this is going to receive our state as the argument and then we're going to return an object that

has a stream's property and this needs to contain all the different streams.

Now here's where things get a little bit interesting.

Remember that our lists of streams is actually stored inside of an object.

It looks like this right here.

So we are probably going to want to map over this list of streams and read out some UL or see me some

apply for each element inside there.

Usually what we do is leave the list of streams in this object form inside of our redux store we'll

leave them in this object form because it makes it really easy to update add and delete records.

But when we eventually take these streams and get them into a component through map state to props usually

we will turn that object into an actual array more similar to how we made use of records or lists of

data previously.

Inside this course the reason that we turn into an array before it gets into our component is just to

make sure that it's really easy to map over and run that map function.

Now of course we can use a mapping function with an object by using load ash but just to keep things

all that easy and not have quite such a big dependency on ASH we usually just turn that thing into an

array before it goes into our component.

So we've got our state argument right here the property on there that we care about is streams so states

streams to get a list of just the streams that if you're inside of an array and not have to worry about

the object nature of the thing we're going to call object values and then pass in state streams like

so.

So object of values is a built in javascript function.

It's going to take an object as an argument.

All the different values inside of that object are going to be pulled out and then inserted into an

array.

So that's exactly what object of values does it just turns all the values inside that object into an

array.

So now inside of our component we're going to have a prop called destock Propst dot streams and that's

going to be an array of all of our different streams.

As a quick test let's just out on a quick console log to our render method and a console log out.

This dock props streams like so.

And now if I flip back over I see the undefined right there you know refresh really quickly.

So I still see undefined which means that I'm probably doing something a little bit off.

Oh I never hooked up map stage props.

Yeah that would do it.

All right.

Let's make sure we pass that in as the first argument.

Really quick.

So I'll pass that into the connect function.

That's much better.

And so now I see the array right here it has two elements inside of it because I have two streams.

All right.

---
## [petre-symfony/modern-react-udemy](https://github.com/petre-symfony/modern-react-udemy)@[caf8c5a96d...](https://github.com/petre-symfony/modern-react-udemy/commit/caf8c5a96d9007f5ca7863a972e7c1b944b94e73)
#### Thursday 2020-07-09 16:00:10 by petrero

331. When to Navigate Users(Section 24: REST-Based React Apps)

In the last video we got our create stream button to appear on the screen.

Now I want to go back over to that form right now and I want to point out some really interesting behavior

about our application currently works.

So I'm going to go over to the create form.

I'm going to make sure that I'm signed into the application.

I'm also going to make sure that I have my network request tab open and that I'm sorting by SH requests.

I didn't want to try to create a new stream and when I do so you're going to see some interesting behavior.

So going to enter in a title here that says unexpected behavior.

And I will give it a description of something like.

Didn't expect that.

And then I'm going to click on the submit button.

Now when I do so you'll notice that we get the request right here.

I see the post request and with out a doubt the request was successful.

We created a new stream through our API.

So what does the unexpected behavior here.

Well the unexpected behavior is the fact that the user got no notification.

There's nothing on the screen that says that the stream was successfully created.

So ideally I think that we would probably automatically navigate our user back over to our list of streams

after we have successfully created the stream.

So in other words after we successfully make a request we should then navigate the user back over to

a list of streams.

Now we've kind of already taken a look at navigation but we've been doing a very specific type of navigation.

So throughout this course so far in the last couple of videos as we have been talking about re-act Rotterdam

we've been seeing examples of intentional navigation intentional navigation is it ever a user clicks

on a link component.

That is when a user is trying to go from page a over to page B.

But in this case we're going to do a different type of navigation.

This is referred to as programmatic navigation.

It's when you and I run some code in response to some type of event and that code has the intent of

changing the page that the user is looking at.

So we essentially want to make sure that the user forcibly gets navigated back to localhost 3000 after

they create a stream.

Now doing this programmatic navigation is not the worst thing in the world.

But before we get too deep into programmatic navigation I want to think a little bit about when exactly

we want to navigate the user around.

In other words exactly what instant in time do we want to try to get the user to go back over to localhost

3000 away from this form.

There's actually some interesting considerations around this.

So it's like let's look at a quick diagram or two.

OK.

So here's a possible scenario in which we might handle programmatic navigation in a not so good manner.

So this is a time line diagram so we start up at the very top up here.

So we'll say that a user submits our form.

We then make a request to our back and API to create the stream and then the instant after that we might

attempt to navigate the user to our list of streams.

Now this is not a good approach.

So what I'm showing you right here about approach.

You do not want to do this.

The issue here is that if we navigate the user back over to our list of streams immediately after we

make that request I'm talking about like the next line of code.

Then if some time passed and we eventually got an error back from our API the stream might not get created

but the user has already navigated away from the form and they don't really have a ability or the opportunity

to update the form and try to recreate the stream.

So essentially we don't want to navigate the user away too early.

We only want to attempt to navigate the user away after we get an API response be it a err or a success

message so essentially we want to make sure that our users Smyth's the form we want to make a request

to the back and API.

And then when we eventually get our response from the API only at that point in time are we going to

attempt to either navigate the user back to a list of streams if the stream was graded successfully

or we will show an error message to the user telling them why the creation failed.

Now at present we are only going to be concerned with handling navigation rewin to handle the error

message stuff or the case in which the API returns and air later on inside this application we will

eventually handle error just not quite yet.

It's going to be a separate discussion in its own little section so that you can easily refer back to

it in the future.

OK.

That's pretty much it.

We want to make sure that we only navigate the user after we get a success from our API.

So essentially we want to trigger navigation.

I'm going to open up my actions index DHHS file.

We only want to trigger navigation from our create stream action creator after we get a successful response

back from our API.

Now we can trigger navigation immediately before or after the dispatch right here it doesn't really

matter.

But I think that maybe it might be a little bit more ideal to do the navigation after we dispatch our

action.

So right here essentially we want to do some Parow grammatic navigation to get the user back to the

route route and remembered the route route shows the list of streams to the user.

So that's the idea right here is where we want to do our programmatic navigation.

OK.

So we now kind of understand the circumstances around all this.

Let's take a quick pause right here.

When we come back the next video we're going to learn a little bit more about exactly how we do this

programmatic navigation.

---
## [petre-symfony/modern-react-udemy](https://github.com/petre-symfony/modern-react-udemy)@[a4ef990a9a...](https://github.com/petre-symfony/modern-react-udemy/commit/a4ef990a9ad15872c75c7e2e28af6b1d8281a5db)
#### Thursday 2020-07-09 16:00:10 by petrero

330.2. Linking to Stream Creation(Section 24: REST-Based React Apps)

I still don't personally really like using current user ID to infer whether or not the user is truly

signed in.

The reason for this is that we actually have a property inside of our state object already that is meant

to be used anytime that we want to check to see if a user is signed in or not signed in.

And that is the is signed in property right here.

So again we can use user ID to kind of infer whether or not the user is signed in.

But the real purpose of putting is signed in inside of here is to be used to decide whether or not the

user is signed in Zangana use is signed in to decide whether or not I want to show this create stream

button.

Now in order to get that is signed in property into my component we of course have to add it to our

map state to prop's function.

So going to add in a new property here called is signed in and thats going to come from state DOT off

dot is signed in.

All right.

So now inside of render create I will say if this Propst is signed in so if the user is signed in I

want to show that button and once more we don't really want to show a button per say we want to show

a link.

Remember any time we do navigation between pages we make use of re-act router dorm's link component

and we've already seen usage of that inside of our Hetter up here a little bit for the all streams and

streaming on the left hand side as well.

So inside of here I want to make use of the link tag from re-act Rotterdam.

So I need to make sure that I import link from the re-act writer Dom library at the top so at the top

my file I'm going to import link from re-act router Dom

and now back down inside of render create I can return a multi-line GSX block.

I'm going to put a div on here.

You'll see why in just a second and then inside of it I'm going to place a link and the link is going

to have the text create Stream.

Now in order for a link to show it properly we have to give it a path or a to property to navigate to

any time that the user clicks on it.

So remember in order for a user to see the form that will allow them to create a new stream they have

to navigate to streams slash new so whenever they go there they'll see the appropriate form on the screen.

Any second now.

All right.

There we go.

So I want to make sure that I pass in a property here of slash streams slash new.

And then I'll give it a class name of UIA button primary to make it appear as though it were a button.

Now the other thing really quickly here remember our mockup showed that button on the far right hand

side.

So in order to get this button to appear on the right hand side really easily.

I was going to manually add on a style property to that div.

That's why we put it inside of here and I'll give it a text a line of.

Right.

And that's just going to make the button right here shift on over to the right hand side of the screen.

All right.

Now the last thing we need to do is make sure that we call render create from inside of our render method.

So after my div that renders out the list I will call this dot render create.

Now we can save this flip back over and go back to our list and there it is right there.

So I now see a nice button that says Create stream I can click on that and then create my stream.

All right.

So we're making some good progress here.

Let's take a quick pause.

When I come back the next video we'll continue working on this application.

---
## [petre-symfony/modern-react-udemy](https://github.com/petre-symfony/modern-react-udemy)@[069b823377...](https://github.com/petre-symfony/modern-react-udemy/commit/069b823377e7e313248a048e6a11e74779d694d8)
#### Thursday 2020-07-09 16:00:10 by petrero

336. Manually Changing API Records(Section 24: REST-Based React Apps)

At this point we have created five different streams inside of application.

I just want to give you a quick little note.

When you're using that Jaison server as our API how you can kind of clean up and manually manipulate

some of the different streams that get created.

So over time you might want to kind of delete a bunch of data from the Sun server without having to

manually delete.

And heck we haven't even wired up that delete button just yet.

So we very quickly show you how you can do that.

I'm going to open up my terminal and I'm going to change over to that API directory.

So remember we have the streams folder inside of there is the client and API file folders.

So I to change into API and then inside of your we should see that debugfs on file.

Recall that is what holds all the data inside of our application.

Now inside the API directory I want you to start up your code editor if you have wired up your code

editor to open up from the terminal then go ahead and do so.

Otherwise open up your code editor manually and open up the API directory.

So now inside that API folder all see a couple of different files here.

So I've got the package shot on files and I've got the D-B dot japes on file.

So instead of DBT Jaison you'll see all the different records we have now created.

I've got an idea one two three four and five.

So if you want to make any change changes manually to the data inside of your application you can just

change this file that's it.

So for example if I wanted to delete the last two posts that I created over the last two streams excuse

me I could just manually delete them.

Make sure you clean up the comma on the trailing end as well.

I can then save this file when I change back over to my terminal that is running the API server will

see an automatic reload right here.

So the API server is automatically watching the dbase on file if you change it.

That API server is going to automatically restart.

Now if I go backwards my application I can refresh the page and will see that those two streams disappeared.

All right so that's pretty much it.

That's how we manually change data on the API server.

If you want to over time as we start to create more and more streams as we are testing things you will

eventually see my data on the screen change every now and then.

That's because I am manually deleting streams just to keep this list a little bit manageable so that

you can easily see everything in the video.

OK so now you know how to change your data.

You can close this extra code editor if you want to.

Otherwise you can of course leave it open if you want to change your list of streams over time.

That's really up to you.

I'm going to go ahead and close mine.

All right let's take a quick pause right here and we'll continue in the next section.

---
## [petre-symfony/modern-react-udemy](https://github.com/petre-symfony/modern-react-udemy)@[71b5ba77bc...](https://github.com/petre-symfony/modern-react-udemy/commit/71b5ba77bcfcf2abac97e788ef2fddf36da55aa6)
#### Thursday 2020-07-09 16:00:10 by petrero

328. Associating Streams with Users(Section 24: REST-Based React Apps)

In last video we started putting together our streamlets component.

We got the list of streams to render But remember we want to show some buttons on these individual streams

that say delete and edit these buttons should only be visible if I was the person who created the stream.

So in this example I would have created this stream and so I see delete and edit but I did not create

this stream.

And so I don't see any buttons on the right hand side.

So this kind of goes back to the topic of authentication and that also ties on this entire process of

fetching streams and whatnot.

So it's kind of a good tie up for the authentication and fetching the list of streams part of this application

in order to figure out which stream was created by who we need to actually attach a user ID to our streams

when they get created.

At present the general structure of our stream object looks like this right here.

So we've just got the idea of the stream itself title and description.

And so what I think we need to do is add on a new key value pair to this thing.

I think that when we create a stream object we need to attach a user ID and this will be the ID of whoever

created this thing.

Now the user id is going to be coming from our off piece of state.

Remember that when we went through that process we saw that actual user ID.

Now if I actually open up my state tab over here and let's see I don't have my user ID right now but

if I log in really quickly.

Let me just go to that process.

OK there we go.

I now see my user ID is inside of your.

So you and I want to take this user ID and attach it to our stream object.

When we create it through the stream create form.

So essentially inside of our actions index touchiest file here it is right here we can find our create

stream action creator.

So right now whenever the thing gets called it is past our form values from the form that creates the

stream.

So essentially want to take both that form Ballis object and our users.

User ID and then posts that all off to our streams and point.

So its not going to be up to the API or anything like that to manage the user id or attach the user

ID.

It is up to you and me to make sure that the appropriate user ID gets attached to each stream object.

OK.

So to actually do this we need to somehow get our user ID inside of our action creator as a quick reminder

remember that when we return a function from an action creator which this is right here this is what

we return the function gets called automatically by redux thunk with two arguments.

The first argument is the dispatch function which weve seen several times but it also gets called a

second argument as well.

And that second argument is the get state function that gets state function allows us to reach into

the redux store and pull out some piece of information.

In this case it's going to allow us to pull out the user ID.

So let's try this out inside of create Stream right here.

I'm going to add a set of parentheses around dispatch and then I'll get my get state function as the

second argument.

So then inside the first line of that action Creator I'm going to structure our user ID from calling

get state DOT off so good state is going to return the entire state object.

And I'm going to access the off piece of state on there and just pluck out the user ID if you don't

ever quite remember the structure of our redux store you can always go back over to redux step tools

click on the little state button right there and they'll see here is all of our state.

So we've got the property and the user ideas nested inside there.

All right so now back over here we want to take our user ID and our form values and essentially combine

them together inside of a single object.

So to do so we can use a similar syntax to what we have been doing inside of our inducers.

So I'm going to wrap form values with an object.

I'm going to take all the key value pairs that have form values and add it to that object by adding

in the dot dot dot and then I'm also going to add in user id like so.

So now when we post a news stream to our API we're going to be posting up all the values out of our

form along with the ID of the user who just created that stream as well.

So let's now try creating a new stream.

This change that we are making is not going to be applied retroactively to the streams we've already

created which is actually going to be kind of good.

I'll show you in a little bit how we can manually mess around with some of the data inside of our API.

But for right now it would actually be kind of nice to have some streams that do not have a user ID

and some that do have a user id equal to our ID.

So I'm going to save this and then I'm going to go back over to my application and I'm going to manually

navigate to streams slash new.

And then once over here I'm going to create a news stream so I'll give it a title of like I created

this stream.

And how about a description of this was made by me.

And then I'll click on submit.

Now remember when you go to this process you need to be signed in.

At present we don't really have any guards or checks or anything like that to make sure that you are

signed in before you create a stream.

So if you are not currently signed in.

Make sure you do sign in and then attempt to create a stream a second time.

Now after I clicked on Submit I should be able to go back over to my redux step tools and scroll all

the way down to the bottom of the list of actions right here and I'll see the action of create stream.

Now if I go back to my list of streams by clicking on stream me appear at the top I'll see this stream

was created by me.

So this is the one that I just made right here.

In addition I can open up redux dev tools again.

Click on the state button.

Expand my list of streams and see streams with ID 1 2 and 3 inside of here.

And so here is the one that I just created and I can very plainly see that it has the correct title

description and user ID.

OK so now every time that we create a stream we have the ID of the user who created it.

So now we can use that ID to decide whether or not we want to show these two extra buttons over here

on the right hand side to delete and edit a particular stream.

So lets take a quick pause and then we'll come back in the next video and start to make sure that we

show those two buttons on the end of each stream.

---
## [newstools/2020-vanguard-nigeria](https://github.com/newstools/2020-vanguard-nigeria)@[e15f1318b5...](https://github.com/newstools/2020-vanguard-nigeria/commit/e15f1318b5aa9eb4ed3db928a95d9d7b040b82e3)
#### Thursday 2020-07-09 16:44:39 by NewsTools

Created Text For URL [www.vanguardngr.com/2020/07/interesting-video-female-house-painter-shares-her-experience-on-the-job/]

---
## [petre-symfony/modern-react-udemy](https://github.com/petre-symfony/modern-react-udemy)@[31d90df96f...](https://github.com/petre-symfony/modern-react-udemy/commit/31d90df96fab10f8e26a188298e24a134b2ac14d)
#### Thursday 2020-07-09 17:42:35 by petrero

342.1 Fetching a Stream for Edit Stream(Section 24: REST-Based React Apps)

In-class video we learn that when we use re-act router we need to make sure that every component is

going to fetch its own data because if we don't if we rely upon the user first going to page A and then

over to page B eventually a user is going to go straight to page B and the data that you might expect

to have is not going to actually exist.

All right so now that we've learned that lesson we're going to open up our stream edit component again.

We're going to make sure that this thing starts to fetch its own data.

Now as a quick reminder if we also open up our actions index not J.S. file you'll recall that we have

an action crater called fetch stream and if we call the thing with an ID this action critter will fetch

that particular stream.

So essentially Anytime our stream edit component is mounted on the screen or is rendered to the screen

we want to make sure we call that stream with the idea of the stream that we want to fetch and that's

pretty much it.

So again if we flip back or stream edit Step one is going to be to refactor this thing into a class

based component so we can use the component did mt life cycle method I to remove the can stream at it

and replace it with class stream at it extends re-act component and then going to wrap those two lines

inside of a render method like so I'm going to remove the semi-colon at the very end of the class that

I don't need anymore.

I'll then define a component.

Did mt life cycle method.

And inside there I'm going to call this prop's dot fetch stream.

Singular no s there are just stream because we want to fetch the one stream that we're trying to show

on the screen and then we're going to call that and we need to make sure that we pass in the ID of the

stream that we're trying to fetch.

Remember our prop's object has the match Puranas id property that's the ID coming out of our YOU l up

you're at the top.

So when we call fecche stream I'm going to pass in destock props dot match harams ID.

That's a long one right there.

But that's pretty much what we want to pass in.

All right.

Now let's test this out.

Now it's incredibly likely that we might see an error here.

I don't know you know we'll see what happens but let's just try to save this and see what happens.

All right so I'll flip back over and sure enough quick your message here.

So looks like my render method.

I had a reference to props.

Remember when we make use of a class based component it has to be destock props.

That's better.

So now I'll save again.

I'll flip back over and again I see an error message.

All right.

Looks like I'm going too quickly here.

I need to slow down just a little bit.

So I tried to call fecche dream by never actually wired up that action creator.

So at the top I'll make sure that I import fetch stream from up to directory's actions and then I need

to make sure that I pass off that stream to connect down at the bottom.

I'll get funding now.

So if we go into workouts let's try this one more time.

All right so I can flip back over.

You'll notice I now see two consulates here in the page first loads up.

The reason I see two is because our component renders to the screen one time and we see the console

log from the render method right there.

We then attempt to fetch our stream after we successfully get our stream from the API.

Our component is rendered again and that's why we see the console log appear a second time.

So if you look in the first console log right here we're going to see that stream is undefined.

So that's the first console log where we have not yet gotten our stream.

Then if we expand a second console log I'll see that the stream has now been successfully fetched and

is showing up inside of my component.

Perfect couple errors there my mistake on that but it looks like we got everything working as expected.

So now if we really wanted to complete our little task here we could attempt to say printout this prop

starts Dreamcoat title.

There's just one thing to be aware of here.

Remember when our component is first rendered this Propst dot stream will be undefined.

So if we tried to print out title when we don't have the stream inside of our component we're going

to see that classic error message something like Yeah.

Here it is right here cannot read property of undefined.

So it's something that we need to do inside of here's something we've done many times before.

---
## [petre-symfony/modern-react-udemy](https://github.com/petre-symfony/modern-react-udemy)@[df0c825e71...](https://github.com/petre-symfony/modern-react-udemy/commit/df0c825e71676f0de750dc6a1feb32bea3b0b430)
#### Thursday 2020-07-09 17:42:35 by petrero

340.2. Selecting Records from State 341. Component Isolation with React Router(Section 24: REST-Based React Apps)

So I'm going to go ahead and remove that console log.

I'm going to remove the No.

Well then go into our state object.

We're going to get our list of streams and then remember our streams variable right there are the streams

property refers to an object where the keys of that object are the IDs of all the streams that we've

loaded up.

So we had done that to make sure that writing out a producer was really easy and straightforward.

But there's another benefit as well.

The other benefit is that any time that you want to select a record out of that object by using an ID

or we have to do is use the very familiar bracket notation.

So inside of the streams object we want to find the stream with an ID of three.

So inside those square brackets we're going to reference own props match BRAMs dot ID.

So right here stream's own props dot match dot prams dot Id like so.

So that should select the appropriate stream out of the object that contains all of our streams inside

of our redux store assign that to the stream property inside this object and then return it from map

state to prop's So the final result of all this is that our prop's object should now have a stream property

that contains the stream that our user is trying to edit.

Now before we tried to walk or print out some information about that stream and this div right here.

Let's first do one more conc a log of prop's right here because there's going to be some kind of interesting

unexpected behavior that I want you to see.

So I'm going to add in the console log of props.

I'll then save this and then we will flip back over to our browser and take a look at what happens.

Not going to do a hard refresh here.

There's my console log.

So now I'll expand this.

And when I do so you'll notice that stream's showed up as undefined.

Huh.

Well if stream is undefined that means that we did not successfully pull the appropriate stream out

of our streams object right here.

It means that something is going wrong with that little chunk of code.

But let me show you some really interesting behavior.

I'm going to navigate back to my big list of streams by clicking on you up your.

And then I'm going to click on the Edit button again.

Now as soon as Stream at it loads up we get a second console log here.

Again that's from the console log inside of our component and I'm going to expand the second console

log and when I do so you'll notice that the stream is now appearing correctly.

So it seems like when we first loaded up this page we had no stream.

But then when we started to navigate around a little bit it seemed like the streams suddenly showed

up.

So that's kind of unexpected behavior.

Just to make sure this is really clear let's run through this one more time very quickly.

I'm at stream's at three.

I'm going to refresh the page when I refreshed the page I see my console log again stream is undefined.

But if I now go back to stream me and then click on the Edit button again I see that stream has now

showed up correctly I've got the entire object right there.

All right.

So again this is kind of interesting behavior.

Let's take a pause right here.

When we come back the next section we're going to take a look at a diagram to make sure that you really

understand why we are sometimes seeing stream of undefined.

And then sometimes we are seeing the string with the appropriate value inside of it.

So a quick pause and I'll see you in just a minute.

341. Component Isolation with React Router

In the last video we saw some really interesting behavior around our stream edit component.

So we went through the flow two times but just one more time really quickly.

The first time we showed our stream at it on the screen we got a stream of undefined inside of our props

object.

But after we navigated around a little bit we then saw the appropriate stream value inside there.

So in this video I'm going to tell you why this is happening.

And make sure that it's really clear because it's going to ultimately kind of culminate in making sure

you understand something very important around re-act router.

All right.

So let's get to it.

I've got a really long flow diagram here that's going to walk you through the entire series of steps

and help you understand exactly what is going wrong.

All right so everything begins with the user typing in streams at it 3 to the address bar and hitting

enter or alternatively just hitting the refresh button right here.

While at the you are l of streams at 3.

So either case really when that occurs the user is going to load up our application inside their browser

when the user first loads up our application.

Our redux state object is totally empty.

We do not have any loaded streams whatsoever.

We then tried to show the stream edit component to the user.

And when we do so we're essentially trying to select stream with ID of three from our state object.

But by that point we have not loaded up any streams.

So we see undefined.

So that's what's going wrong here.

When we navigate directly to streams at 3 we have not loaded up any streams into our application.

And so we immediately see zero data inside of our store when we try to pull some data out of it that

doesn't exist.

We get that undefined value.

So why does the application work when we navigate back over to the stream list.

Well it's pretty simple it's essentially solving the issue that we're running into right here.

When we then navigated to the route route we've rendered the streamlets component on the screen and

the streamlet component if we opened it up very quickly here string list.

Remember we've got the component down Mount right here that always calls fetch streams.

So the instant we show stream list on the screen we are fetching a list of all of the different streams

that our application has.

So we fetch the list of streams and that updates our redux store.

We then navigated back over to streams at three and then we attempt to select the stream with idea of

three from the redux store.

But now in this case we have already fetched our data.

So we then see the appropriate stream appear.

So that's the big issue here.

The big issue is that we are trying to make get access to some data that has not yet been loaded up

into our application.

The big lesson the thing I want you to really understand here about re-act router is that anytime that

you are using this kind of ID based selection you are l.

We always have to obey this rule.

We always need to make sure that any component that is going to be shown on a screen is going to be

designed to work by itself or in isolation.

So essentially that means that every component that re-act router does is going to show needs to fetch

its own data.

We really cannot assume that any given component will get access to some data that might have been loaded

up previously inside the application.

We've already seen that that's not the case.

If a user navigates directly to streams at 3 there are no streams to select from.

So our stream edit component needs to load up the appropriate stream it needs to call the action creator

to reach out to the API and fetch the stream with ID 3 so that it can then show it on the screen.

All right so that's pretty much the big lesson here.

We just need to make sure that every component is not going to have some dependency on a user visiting

some other route inside of our application ahead of time because that's our that's never going to be

the case.

Now you might think that was Stephen A user can only get to this page by clicking on the Edit button

right here.

So in this application Yeah you know we always have to see streamlets before we can go to the edit page

but that's not really the case.

If a user comes to this page directly they could easily bookmark the page right.

They could book market and then come back directly to a URL of streams at three and that would completely

bypass the stringless component.

In addition a user might copy this link right here and share it with a friend.

The friend might click on it come to this page and then expect to see the appropriate stream appear.

So it's entirely possible that your users are always going to come directly to a given route inside

your application.

And so every route and every component shown by that route needs to fetch its own data and it cannot

rely upon some other component fetching data ahead of time for it.

OK so now that we understand the issue here let's fix it up.

Let's take a quick pause and when we come back we're going to make sure that stream at it tends to fetch

the stream that it's trying to show.

So that if we navigate directly to this component it will fetch the appropriate stream from our API

put it into the redux store and then select it from that store.

So quick pause and I'll see you in just a minute.

---
## [petre-symfony/modern-react-udemy](https://github.com/petre-symfony/modern-react-udemy)@[43868c89f8...](https://github.com/petre-symfony/modern-react-udemy/commit/43868c89f8eee974725ffa94040b3edd3178a3c9)
#### Thursday 2020-07-09 17:42:35 by petrero

337. URL-Based Selection 338. Wildcard Navigation(Section 24: REST-Based React Apps)

In this video we're going to start talking about the edits stream page.

So I bet you can guess what this page is going to do.

And any time a user comes to the stream page we're going to allow them the opportunity to edit the title

or the description of a already created Stream.

Now in this video in particular we're going to talk about how a user can get to this page and how we're

going to figure out what stream a user is trying to edit.

Now when I say that it doesn't make a lot of sense.

So let me lay out a little scenario here for you.

If you recall when we show the index page we're going to show that delete an edit button next to any

stream that a user has created.

And so at some point in time a user is going to click on this edit button right here when the user clicks

on edit.

They're going to be navigated over to the edit stream page.

And so when we come over to this page we need to know what stream a user is attempting to edit.

In other words we need to kind of communicate which edit button the user clicked on over here to this

component.

This component needs to know what string the user is trying to edit.

Now in order to do this there's two different approaches we can use.

One approach we've seen earlier on inside discourse and another approach we're going to be able to use

only because we are now making use of re-act router Dom.

So let's talk about these two different approaches that we can use to communicate the stream that the

user is trying to edit from clicking on this button over to the edit stream component.

OK.

So option number one would be to use something like a selection reducer and we've already made use of

a selection reducer before we used it.

Inside the first redux app we put together inside this course if you recall we are that song's application

where a user could click on a song and then we had a selection reducer that recorded which song These

are had clicked on.

So as soon as user clicked on a song we updated the data being returned from that reducer.

And that was then shown on the screen to the user so we can make use of a selection we do at this time

around as well.

We could say that as soon as a user clicks on this edit button we would dispatch an action that says

that a user is trying to select or trying to edit this stream right here.

And then we can make sure that we communicated that information to the edit stream page.

So again that is one approach we could use.

Now the second approach we can use is only going to be available because we are now making use of re-act

router Dom.

So the second approach would be called you l based selection.

With this approach were going to essentially make sure that whenever a user clicks on this link right

here as opposed to just throwing them over to some path like streams slash at it they will instead go

to some address or some path that has the ID of the stream that they are trying to edit inside of the

address bar.

So in other words with you are l base selection were going to put the idea of a stream that is being

edited inside the you or l.

Now that's a bit challenging to understand so let's take a look at a quick diagram to help you understand

what I mean by that.

All right so we looked at this diagram a while ago we looked at this when we were talking about navigation

inside of application and we had said that we had a collection of different paths that would route our

user to a bunch of different components.

So I told you that we would use streams flash at it for stream edit stream flashily stream delete and

streams slash show for streams show.

But if we want to use Eurail based selection then we're going to change these paths right here just

a little bit.

Let me show you how these would change if we want to use your L based selection.

And as a quick reminder here the entire idea is that we're trying to communicate what streamlet user

is trying to edit down into this component.

All right so here's how we would change things if we wanted to use you or L base selection.

So notice how we now have streams slash at it slash ID.

We have streams to ID and streams ID as well.

So the common theme between stream added streams show and stream delete is that each of them are operating

on a very single stream with stream as it were trying to edit a very specific stream with stream delete.

We're going to try to delete a very specific stream and with streams show we're trying to show the user

a very specific stream as well.

So because these are all working with very specific records we could use you are l based selection with

each one.

So you'll notice that they all have their pads changed just a little bit.

Each one of them has a final slash and then a colon ID.

Now Culin idea right here specifically with the colon means that ID or that part of the your L is essentially

a variable.

So rather than having like colon ID we are essentially saying that if a user goes to stream's at it

slash anything a user will be going to stream at it.

So we could have a URL like streams edit slash 50.

And that would indicate that the user is trying to edit the stream with the idea of 50.

If a user went to streams at a 5 that would mean that we should show the stream edit component and that

the user is trying to edit the ID or the record with the idea of 85.

Its the same thing with the other Patsi here as well.

If a user goes to stream's slash 92 it means that we should show streams show and the user is trying

to view the record with an ID of 92.

So again any time that you see colon and then some label inside the path that essentially means it has

a variable so because we can put the idea of the record that the user is trying to edit inside the OR

L we can make use of re-act router Dohm to look at the URL and pull off just that portion of the rail

like just that little variable right there.

And so again if it's something like say 17 then we can take that 17 and pass it as a prop into the stream

edit component.

And so then the stream at a component will know that it needs to show the stream 17 and allow a user

to edit specifically the stream with ID 17.

All right.

So that's pretty much the idea.

Again we had two options here.

We could either use a selection reducer or Eurail based selection wherever possible.

We prefer to use your cell based selection because there are a couple of other benefits around it that

are only going to make sense once we start putting the solution together.

So we are going to come back to this topic once we start working on it a little bit more.

And I'm going to point out some other big benefits around using your L based selection.

All right so enough of the high level concepts here.

Let's take a quick pause right here.

When we come back the next section we're going to start updating our routing configuration to make use

of these kind of variables inside of our you are l and we'll figure out how we can access that piece

of information inside of our stream edit component.

So quick pause and I'll see you in just a moment.

338. Wildcard Navigation

In this video we're going to start updating your application to make use of your L based selection to

do so there's two separate things we need to do.

First off we need to make sure that any time that a user clicks on this edit button next to a stream

they go to a route of something like streams flash edit and then the idea of the stream that the user

just clicked on the button for.

After that we need to make sure that we also update our routing information inside of our apt Yes file

to make sure that anytime that a user goes to a URL like streams edits slash ID it shows the stream

edit component.

At present we have wired up our routing rules to say that any time a user goes to stream slash at it

they see the stream edit component.

So word is going to do a little tweak around our routing rules.

So let's first start off by updating our button right here.

The edit stream button.

So I'm going to open up my streams stream list component.

Here it is right here and then going to scroll down a little bit and find render list.

Now you'll recall that inside of Brender list we are calling render admen with each individual stream

and it's up to render admin to return the appropriate buttons.

Let's find the render admen method.

Here it is right here.

So at present we have two button components or two button elements being rendered inside of your.

We no longer want to have button elements we want to have an actual link tag from re-act router dom

so that we can navigate a user to some different page inside of application.

So I'm going to collapse my sidebar here.

Notice how we've already imported the link component from reactor at her dumb language to delete the

edit button right here entirely.

And I'm going to replace it with a link instead.

I'm going to again give it the same text it had before of edit.

I'm going to give it a class name of UI button primary and then I'm going to make sure that also gets

the two property.

Now in this case the two is not going to be some fixed value.

Instead we need to essentially take the idea of the stream and insert it into the two string that we

generate.

So we want to end up with a two prop of streams at it.

And then the idea of the stream that we passed into our render admin function.

So essentially we want to do a little calculation here as opposed to passing in a fixed string.

We're going to use a 2015 template string to do so.

We have to use our curly braces like so then put in my back to X and then I will say slash streams at

it and then I want to put in the ID of the stream that we are iterating over soldier dollar sign clearly

brace stream Id like so now again make sure that you have back Tick's here not single quotes and once

we've got this all put together I'm going to save this file when I do.

You're going to see the code jump here really quickly just to reformat it like the

now issue.

If we flip back over to our application and we hover over that edit button you'll notice the L that

pops up on the bottom left inside says stream's slash at it slash 3.

So if I click on that I want to go to the stream edit component or that page and the information here

is trying to convey or the L is trying to convey that we want to edit the stream with an idea of three.

So now the next thing we need to do is make sure that we update our routing rules inside of my apt.

J.S. file we need to find the route that is defining our stream edit component we need to make sure

that this thing understands that if a user ever goes to streams at it and then some ID we still want

to show stream at it.

So to do so we're going to put on another forward slash at the very end and we'll say Colin Id just

like we saw it in the diagram.

So now if a user goes to streams edit slash anything we're going to show the stream edit component.

Let's save this file and we'll test that out.

So I'm going to save the uptalk just file.

Flip back over.

I'll do a quick refresh just to make sure I got that update and then I'll click on my edit button right

here and when I do so I will see stream edit appear on the screen.

Perfect.

So now we can show stream edits regardless of the ID that we have inside of you or else I can try going

to edit one and all still see the same component on the screen.

I could go to Edit too.

I still see the same thing.

I can even go to edit some really long number like so and I'll still see that component on the screen.

So I remember as soon as he put in Colin and then anything inside the OR l That means that this is going

to be essentially a variable and he could have any value that you want for that part of the URL.

Now one quick thing I want to mention here we did not have to say specifically ID here.

This could have been Kolin anything that you want.

It's essentially the colon that is the magical character here.

The colon is what turns us into a variable of sorts.

OK.

So I'm going to save that.

Now the next thing we need to do is to make sure that any time that a user comes to this page we somehow

get that number out of the Eurail like the three and we communicate that number down into stream at

it so that the stream at a component knows exactly what STREAM it is trying to change.

So let's take a quick pause right here and we'll figure out how to do that in the next video.

---
## [BasadoStudios/Project-1-Mario](https://github.com/BasadoStudios/Project-1-Mario)@[ecdb886dfe...](https://github.com/BasadoStudios/Project-1-Mario/commit/ecdb886dfe9fc58df1b556768869d5331d680994)
#### Thursday 2020-07-09 19:24:14 by jayvgravy

final animations + personal fuck you to rishik sarkar

---
## [k21971/EvilHack](https://github.com/k21971/EvilHack)@[bdaf5a3e1a...](https://github.com/k21971/EvilHack/commit/bdaf5a3e1a3800ea3c8ecd1233f8bb8944d79810)
#### Thursday 2020-07-09 19:45:45 by k21971

Effects of praying/sacrificing as an Infidel.

Moloch doesn't do shiny effects or light soothing colors, or even hand
out blessings (although he will still aid his own follower in their time
of need). The changes in this commit:

* Feedback for various effects due to praying are changed (e.g. instead
of being surrounded by a shimmering glow, for Infidels it's 'an ominous
crimson glow', etc).
* Moloch doesn't do blessings. Successfully praying on an unaligned
altar with potions of water on it as an Infidel produces cursed water
instead of blessed.
* The Infidel player can still have troubles fixed just as any other
role, just that the feedback is different. Cursed objects can still be
uncursed as well (except for armor, but this was already handled in the
initial patch).
* Instead of a wielded weapon being blessed, it's cursed. In vanilla
NetHack this would have zero benefit, but in EvilHack there are some
advantages to having a cursed weapon.
* Altar sacrificing - should the Infidel receive a regular piece of
gear, care has been taken to make sure that object is never made of
silver.

---
## [mlidbom/Composable](https://github.com/mlidbom/Composable)@[54c32d8ccc...](https://github.com/mlidbom/Composable/commit/54c32d8cccfe2e64619452a60693726e7bfe3147)
#### Thursday 2020-07-09 20:17:39 by Magnus Lidbom

All tests working and the code is not too horribly ugly. Seems the extra call to the server is not that bad performance wise either. The select that actually fetches data seems to be much more costly.

---
## [wybczu/404.notrollsallowed.com](https://github.com/wybczu/404.notrollsallowed.com)@[0a846683db...](https://github.com/wybczu/404.notrollsallowed.com/commit/0a846683db5308b2ca9ed87b15cd20516c84ff99)
#### Thursday 2020-07-09 22:46:38 by Łukasz Szczęsny

Smart Hom^WFarm

I will share my plan (not real experience yet - thanks pandemic!) for ways to
make life easier on a (small) farm. I will show you what FOS{H,S} can do for
us in this field.

---
## [newstools/2020-the-guardian-nigeria](https://github.com/newstools/2020-the-guardian-nigeria)@[0dd43f1575...](https://github.com/newstools/2020-the-guardian-nigeria/commit/0dd43f15750f480b185e7df7872fb7747a452c96)
#### Thursday 2020-07-09 23:24:48 by NewsTools

Created Text For URL [guardian.ng/life/3-year-old-girl-starves-to-death-after-her-mum-left-her-to-visit-boyfriend/]

---
## [dankamongmen/dankamongmen](https://github.com/dankamongmen/dankamongmen)@[2e1ad279b0...](https://github.com/dankamongmen/dankamongmen/commit/2e1ad279b0336d742ca44d55f299c0db1d5e4310)
#### Thursday 2020-07-09 23:51:41 by nick black

we are all watching how do you spell jew? a new program produced by tennessee public television station wkpt each week a member of the tennessee state house of representatives is sent back in time to meet a famous jew from history this week rep. jeeter maloney tennessee's youngest state representative is sent back in history to rijnsburg, holland to meet the metaphysical philosopher baruch spinoza Judaism's most notoriously heretical luminary please have some kuchen and coffee spinoza says much obliged, drawls maloney sampling the kuchen, ummmmmmm yum… what did you call these — cookin? kuchen spinoza replies please help yourself to more i wonder how many of these kuchen you could stuff into my mouth maloney wonders out loud that's something upon which i have often speculated spinoza says and as maloney stretches his mouth wide open with both his hands spinoza stuffs three and finally four kuchen in there's a long somewhat uncomfortable silence i'm having a lot of trouble lately with my son jeeter jr., maloney finally says, all he seems to want to do is play video games what are video games? spinoza asks

---

# [<](2020-07-08.md) 2020-07-09 [>](2020-07-10.md)

