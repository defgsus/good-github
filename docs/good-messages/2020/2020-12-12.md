# [<](2020-12-11.md) 2020-12-12 [>](2020-12-13.md)

3,868,170 events, 1,128,395 push events, 1,660,238 commit messages, 121,281,690 characters


## [CoderShubham2000/ESCodeR-2020](https://github.com/CoderShubham2000/ESCodeR-2020)@[7f3a34cef5...](https://github.com/CoderShubham2000/ESCodeR-2020/commit/7f3a34cef5d56083b919a661137e60ad5ff9811e)
#### Saturday 2020-12-12 00:42:24 by Shubham Tribedi

PreMature Microchip

Anish has a knack of making exciting electronics things in his free time. His dream is to make his own microprocessor. He works immensely hard to fulfil his dream. At this point of time his microchip is very much premature and can only do three bit-wise operations.

Left Shift
Right Shift
XOR
But, he has managed to work with numbers of arbitrary bit length as long as the representation is of unsigned integer. Now, being very premature, his processor is very very slow. His friend Vinita has given him 2 unsigned integers.

A, consisting of N bits with an arbitrary initial value.
F, consisting of N bits with the initial value of 2K - 1.
Vinita also constrained Anish with two operations.

Anish can only perform a left/right shift operation on F. Providing, there are exactly K numbers of ‘1’ bits in F.
He also can perform A xor F operation to modify the value of A.
In this situation, Vinita has challenged Anish to generate the maximum number A can contain only using these 2 operations. Though Anish's microchip is very efficient in doing left and right shifts, it’s behaviour is very funky when it comes to XOR operations. To impress Vinita, Anish has to minimise the XOR operations.

Now, your task has to determine what is the minimum required XOR operation needed to fulfil the challenge if possible. Or, say it’s IMPOSSIBLE.

Input Format

First line is number of test independent cases T.

For each test case, each line will contain the binary representation of A and, the value of K.

Constraints

1 ≤ T ≤ 100

2 ≤ K ≤ length of A

2 ≤ length of A ≤ 1000

Output Format

Each line will contain the result for each test case. The output will either be IMPOSSIBLE if the desired outcome can't be achived. Or, an integer denoting minimum number of operations required.

Sample Input 0

2
00010110 3
01010 4
Sample Output 0

3
IMPOSSIBLE
Explanation 0

In case 1, the binary representation of A is 00010110. And, the binary representation of F is 00000111. Then, the following steps are followed :

F left shift 5 : new F = 11100000
A xor F : new A = 11110110
F right shift 5 : new F = 00000111
A xor F : new A = 11110001
F left shift 1 : new F = 00001110
A xor F : new A = 11111111
So, the output is 3.

In case 2, we can't achieve the target of maximizing A using available operations. So, the output is IMPOSSIBLE.

---
## [ko7580/AXOM-FB-HACK](https://github.com/ko7580/AXOM-FB-HACK)@[ddbd01b684...](https://github.com/ko7580/AXOM-FB-HACK/commit/ddbd01b6842ebb04368696f33dd50b3962dfc83b)
#### Saturday 2020-12-12 01:15:49 by ko7580

8888 6678 5555 12345 123456 12345 123456789 password iloveyou princess 1234567 rockyou 12345678 abc123 nicole daniel babygirl monkey lovely jessica 654321 michael ashley qwerty 111111 iloveu 000000 michelle tigger sunshine chocolate password1 soccer anthony friends butterfly purple angel jordan liverpool justin loveme fuckyou 123123 football secret andrea carlos jennifer joshua bubbles 1234567890 superman hannah amanda loveyou pretty basketball andrew angels tweety flower playboy hello elizabeth hottie tinkerbell charlie samantha barbie chelsea lovers teamo jasmine brandon 666666 shadow melissa eminem matthew robert danielle forever family jonathan 987654321 computer whatever dragon vanessa cookie naruto summer sweety spongebob joseph junior softball taylor yellow daniela lauren mickey princesa alexandra alexis jesus estrella miguel william thomas beautiful mylove angela poohbear patrick iloveme sakura adrian alexander destiny christian 121212 sayang america dancer monica richard 112233 princess1 555555 diamond carolina steven rangers louise orange 789456 dancer monica richard 112233 princess1 555555 diamond carolina steven rangers louise orange 789456 999999 shorty 11111 nathan snoopy gabriel hunter cherry killer sandra alejandro buster george brittany alejandra patricia rachel tequiero 7777777 cheese 159753 arsenal dolphin antonio heather david ginger stephanie peanut blink182 sweetie 222222 beauty 987654 victoria honey 00000 fernando pokemon maggie corazon chicken pepper cristina rainbow kisses manuel myspace rebelde angel1 ricardo babygurl heaven 55555 baseball martin greenday november alyssa madison mother 123321 123abc mahalkita batman september december morgan mariposa maria gabriela iloveyou2 bailey jeremy courtney booboo kissme harley ronaldo iloveyou1 precious october inuyasha peaches veronica chris 888888 adriana cutie james banana prince friend jesus1 crystal celtic zxcvbnm edward oliver diana samsung freedom football fuckyou loveyou mylove america imdian indian indianarmy

githou.com

---
## [kwangilkimkenny/Story_Analysis](https://github.com/kwangilkimkenny/Story_Analysis)@[3df3f4c922...](https://github.com/kwangilkimkenny/Story_Analysis/commit/3df3f4c9227b42665cf70ee9a0895ba3389f36bd)
#### Saturday 2020-12-12 01:30:12 by kwangilKyle

테마 전체 분석 코드 (웹용)

#  6개의 질문중 택 1의 경우 한명의 학생데이터와 1000명의 학생 데이터를 비교

# 실행에 필요한 사전 계산파일은 모두 2종류로 csv 1개, pickle 7개임
# 1) actionverbs.csv
# 2) question_one_1000_dataset.pickle ~ question_seven_1000_dataset.pickle



# 입력데이터 :  학생에세이(input_text), 질문 7개중 1개 선택(question_num)
# 실행 함수 :  theme_total_analysis(input_text, question_num)  


#  결과에서 맨 마지막 최종결과만 확인하면 됨   4개의 결과로  return result_final, emo_result, topic_result, topic_result

# 1명의 에세이 결과 계산점수 : [9.45423856180526, 3.97]
# min_ 30
# max_:  123
# div_: 30
# cal_abs 절대값 : 67.54576143819475
# compare7 : 14.409039760300876
# compare6 : 17.29084771236105
# compare5 : 21.613559640451314
# compare4 : 28.818079520601753
# compare3 : 43.22711928090263
# Lacking: 2
# min_ 191
# max_:  764
# div_: 191
# cal_abs 절대값 : 474.03
# compare7 : 80.32833333333333
# compare6 : 96.394
# compare5 : 120.4925
# compare4 : 160.65666666666667
# compare3 : 240.985
# Lacking: 2

# return result_final(Contextual Semantic Search, Narrativity, Overall Theme Rating), emo_result(감정분석워드클라우드 결과 딕셔너리), topic_result(주제추출 워드클라우드 결과 딕셔너리)
# 최종결과 :  ([0, 0, 1.0], {'approval': 7, 'admiration': 3, 'realization': 3, 'amusement': 1, 'confusion': 1, 'excitement': 1, 'annoyance': 1}, {'i': 27, 'filipino': 3, 'expectations': 3, 'way': 3, 'francesca': 3, 'pressure': 3, 'summer': 2, 'tradition': 2, 'expectation': 2, 'piano': 2, 's': 2, 'guitar': 2, 'sound': 2, 'interlochen': 2, 'environment': 2, 'art': 2, 'guitarist': 2, 'jazz': 2, 'one': 2, 'someone': 2, 'presence': 2, 'comfort': 2, 'warmth': 2, "'bloomington": 1, 'city': 1, 'swathes': 1, 'corn': 1, 'envelop': 1, 'roads': 1, 'smell': 1, 'bbq': 1, 'smoke': 1, 'countryside': 1, 'norms': 1, 'force': 1, 'role': 1, 'debussy': 1, 'festival': 1, 'philosophy': 1, 'demand': 1, 'triplet': 1, 'groove': 1, 'intricacies': 1, 'chordal': 1, 'harmony': 1, 'years': 1, 'music': 1, 'novelty': 1, 'methods': 1, 'solos': 1, 'greats': 1, 'experiment': 1, 'approaches': 1, 'route': 1, 'freedom': 1, 'path': 1, 'desires': 1, 'trail': 1, 'arts': 1, 'year': 1, 'growth': 1, 'people': 1, 'kinds': 1, 'regard': 1, 'ideas': 1, 'opportunity': 1, 'limits': 1, 'day': 1, 'camp': 1, 'peer': 1, 'band': 1, 'girl': 1, 'illinois': 1, 'moment': 1, 'endeavors': 1, 'effort': 1, 'background': 1, 'slew': 1, 'differences': 1, 'heights': 1, 'guitars': 1, 'styles': 1, 'others': 1, 'trouble': 1, 'distinction': 1, 'performances': 1, 'glittering': 1, 'lakes': 1, 'pine': 1, 'needles': 1, 'bloomington': 1, 'mistaken': 1, 'times': 1, 'standard': 1, 'language': 1, 'style': 1, 'qualities': 1, 'something': 1, 'pursuit': 1, 'time': 1, 'inspiration': 1, 'precedent': 1, 'spite': 1, 'solace': 1, 'similarities': 1, 'sense': 1, 'life': 1, 'matter': 1, 'm': 1, 'engage': 1, 'influence': 1, 'rewards': 1, 'encounter': 1, 'feeling': 1, 'setting': 1, 'conditions': 1, 'hometown': 1, 'resemblances': 1, 'familiarity': 1, 'balance': 1, 'elements': 1, 'discove': 1, ']': 1}, {'i': 27, 'filipino': 3, 'expectations': 3, 'way': 3, 'francesca': 3, 'pressure': 3, 'summer': 2, 'tradition': 2, 'expectation': 2, 'piano': 2, 's': 2, 'guitar': 2, 'sound': 2, 'interlochen': 2, 'environment': 2, 'art': 2, 'guitarist': 2, 'jazz': 2, 'one': 2, 'someone': 2, 'presence': 2, 'comfort': 2, 'warmth': 2, "'bloomington": 1, 'city': 1, 'swathes': 1, 'corn': 1, 'envelop': 1, 'roads': 1, 'smell': 1, 'bbq': 1, 'smoke': 1, 'countryside': 1, 'norms': 1, 'force': 1, 'role': 1, 'debussy': 1, 'festival': 1, 'philosophy': 1, 'demand': 1, 'triplet': 1, 'groove': 1, 'intricacies': 1, 'chordal': 1, 'harmony': 1, 'years': 1, 'music': 1, 'novelty': 1, 'methods': 1, 'solos': 1, 'greats': 1, 'experiment': 1, 'approaches': 1, 'route': 1, 'freedom': 1, 'path': 1, 'desires': 1, 'trail': 1, 'arts': 1, 'year': 1, 'growth': 1, 'people': 1, 'kinds': 1, 'regard': 1, 'ideas': 1, 'opportunity': 1, 'limits': 1, 'day': 1, 'camp': 1, 'peer': 1, 'band': 1, 'girl': 1, 'illinois': 1, 'moment': 1, 'endeavors': 1, 'effort': 1, 'background': 1, 'slew': 1, 'differences': 1, 'heights': 1, 'guitars': 1, 'styles': 1, 'others': 1, 'trouble': 1, 'distinction': 1, 'performances': 1, 'glittering': 1, 'lakes': 1, 'pine': 1, 'needles': 1, 'bloomington': 1, 'mistaken': 1, 'times': 1, 'standard': 1, 'language': 1, 'style': 1, 'qualities': 1, 'something': 1, 'pursuit': 1, 'time': 1, 'inspiration': 1, 'precedent': 1, 'spite': 1, 'solace': 1, 'similarities': 1, 'sense': 1, 'life': 1, 'matter': 1, 'm': 1, 'engage': 1, 'influence': 1, 'rewards': 1, 'encounter': 1, 'feeling': 1, 'setting': 1, 'conditions': 1, 'hometown': 1, 'resemblances': 1, 'familiarity': 1, 'balance': 1, 'elements': 1, 'discove': 1, ']': 1})

---
## [himanshusoni93/My_Data_Science_Portfolio](https://github.com/himanshusoni93/My_Data_Science_Portfolio)@[b4dad1f958...](https://github.com/himanshusoni93/My_Data_Science_Portfolio/commit/b4dad1f958884608a6d77c4e1d2ce107370eea59)
#### Saturday 2020-12-12 05:37:34 by HIMANSHU SONI

Predict A Doctor's Consultation Fee project

## We have all been in the situation where we go to a doctor in an emergency and find that the consultation fees are too high. As data scientist, we all should do better. What if you have data that record important details about a doctor and you get to build a model to predict the doctor’s consulting fee.? This is the hackathon that lets you do that.

FEATURES:

Qualification: Qualification and degrees held by the doctor

Experience: Experience of the doctor in number of years

Rating: Rating given by patients

Profile: Type of the doctor

Miscellaeous_Info: Extra information about the doctor

Fees: Fees charged by the doctor

Place: Area and the city where the doctor is located.

---
## [Klozz/kernel_xiaomi_sm8250](https://github.com/Klozz/kernel_xiaomi_sm8250)@[a3e110153d...](https://github.com/Klozz/kernel_xiaomi_sm8250/commit/a3e110153d93ba61d8c85b11540959ecfefe99a4)
#### Saturday 2020-12-12 07:22:12 by Christian Brauner

BACKPORT: signal: add pidfd_send_signal() syscall

The kill() syscall operates on process identifiers (pid). After a process
has exited its pid can be reused by another process. If a caller sends a
signal to a reused pid it will end up signaling the wrong process. This
issue has often surfaced and there has been a push to address this problem [1].

This patch uses file descriptors (fd) from proc/<pid> as stable handles on
struct pid. Even if a pid is recycled the handle will not change. The fd
can be used to send signals to the process it refers to.
Thus, the new syscall pidfd_send_signal() is introduced to solve this
problem. Instead of pids it operates on process fds (pidfd).

/* prototype and argument /*
long pidfd_send_signal(int pidfd, int sig, siginfo_t *info, unsigned int flags);

/* syscall number 424 */
The syscall number was chosen to be 424 to align with Arnd's rework in his
y2038 to minimize merge conflicts (cf. [25]).

In addition to the pidfd and signal argument it takes an additional
siginfo_t and flags argument. If the siginfo_t argument is NULL then
pidfd_send_signal() is equivalent to kill(<positive-pid>, <signal>). If it
is not NULL pidfd_send_signal() is equivalent to rt_sigqueueinfo().
The flags argument is added to allow for future extensions of this syscall.
It currently needs to be passed as 0. Failing to do so will cause EINVAL.

/* pidfd_send_signal() replaces multiple pid-based syscalls */
The pidfd_send_signal() syscall currently takes on the job of
rt_sigqueueinfo(2) and parts of the functionality of kill(2), Namely, when a
positive pid is passed to kill(2). It will however be possible to also
replace tgkill(2) and rt_tgsigqueueinfo(2) if this syscall is extended.

/* sending signals to threads (tid) and process groups (pgid) */
Specifically, the pidfd_send_signal() syscall does currently not operate on
process groups or threads. This is left for future extensions.
In order to extend the syscall to allow sending signal to threads and
process groups appropriately named flags (e.g. PIDFD_TYPE_PGID, and
PIDFD_TYPE_TID) should be added. This implies that the flags argument will
determine what is signaled and not the file descriptor itself. Put in other
words, grouping in this api is a property of the flags argument not a
property of the file descriptor (cf. [13]). Clarification for this has been
requested by Eric (cf. [19]).
When appropriate extensions through the flags argument are added then
pidfd_send_signal() can additionally replace the part of kill(2) which
operates on process groups as well as the tgkill(2) and
rt_tgsigqueueinfo(2) syscalls.
How such an extension could be implemented has been very roughly sketched
in [14], [15], and [16]. However, this should not be taken as a commitment
to a particular implementation. There might be better ways to do it.
Right now this is intentionally left out to keep this patchset as simple as
possible (cf. [4]).

/* naming */
The syscall had various names throughout iterations of this patchset:
- procfd_signal()
- procfd_send_signal()
- taskfd_send_signal()
In the last round of reviews it was pointed out that given that if the
flags argument decides the scope of the signal instead of different types
of fds it might make sense to either settle for "procfd_" or "pidfd_" as
prefix. The community was willing to accept either (cf. [17] and [18]).
Given that one developer expressed strong preference for the "pidfd_"
prefix (cf. [13]) and with other developers less opinionated about the name
we should settle for "pidfd_" to avoid further bikeshedding.

The  "_send_signal" suffix was chosen to reflect the fact that the syscall
takes on the job of multiple syscalls. It is therefore intentional that the
name is not reminiscent of neither kill(2) nor rt_sigqueueinfo(2). Not the
fomer because it might imply that pidfd_send_signal() is a replacement for
kill(2), and not the latter because it is a hassle to remember the correct
spelling - especially for non-native speakers - and because it is not
descriptive enough of what the syscall actually does. The name
"pidfd_send_signal" makes it very clear that its job is to send signals.

/* zombies */
Zombies can be signaled just as any other process. No special error will be
reported since a zombie state is an unreliable state (cf. [3]). However,
this can be added as an extension through the @flags argument if the need
ever arises.

/* cross-namespace signals */
The patch currently enforces that the signaler and signalee either are in
the same pid namespace or that the signaler's pid namespace is an ancestor
of the signalee's pid namespace. This is done for the sake of simplicity
and because it is unclear to what values certain members of struct
siginfo_t would need to be set to (cf. [5], [6]).

/* compat syscalls */
It became clear that we would like to avoid adding compat syscalls
(cf. [7]).  The compat syscall handling is now done in kernel/signal.c
itself by adding __copy_siginfo_from_user_generic() which lets us avoid
compat syscalls (cf. [8]). It should be noted that the addition of
__copy_siginfo_from_user_any() is caused by a bug in the original
implementation of rt_sigqueueinfo(2) (cf. 12).
With upcoming rework for syscall handling things might improve
significantly (cf. [11]) and __copy_siginfo_from_user_any() will not gain
any additional callers.

/* testing */
This patch was tested on x64 and x86.

/* userspace usage */
An asciinema recording for the basic functionality can be found under [9].
With this patch a process can be killed via:

 #define _GNU_SOURCE
 #include <errno.h>
 #include <fcntl.h>
 #include <signal.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <sys/stat.h>
 #include <sys/syscall.h>
 #include <sys/types.h>
 #include <unistd.h>

 static inline int do_pidfd_send_signal(int pidfd, int sig, siginfo_t *info,
                                         unsigned int flags)
 {
 #ifdef __NR_pidfd_send_signal
         return syscall(__NR_pidfd_send_signal, pidfd, sig, info, flags);
 #else
         return -ENOSYS;
 #endif
 }

 int main(int argc, char *argv[])
 {
         int fd, ret, saved_errno, sig;

         if (argc < 3)
                 exit(EXIT_FAILURE);

         fd = open(argv[1], O_DIRECTORY | O_CLOEXEC);
         if (fd < 0) {
                 printf("%s - Failed to open \"%s\"\n", strerror(errno), argv[1]);
                 exit(EXIT_FAILURE);
         }

         sig = atoi(argv[2]);

         printf("Sending signal %d to process %s\n", sig, argv[1]);
         ret = do_pidfd_send_signal(fd, sig, NULL, 0);

         saved_errno = errno;
         close(fd);
         errno = saved_errno;

         if (ret < 0) {
                 printf("%s - Failed to send signal %d to process %s\n",
                        strerror(errno), sig, argv[1]);
                 exit(EXIT_FAILURE);
         }

         exit(EXIT_SUCCESS);
 }

/* Q&A
 * Given that it seems the same questions get asked again by people who are
 * late to the party it makes sense to add a Q&A section to the commit
 * message so it's hopefully easier to avoid duplicate threads.
 *
 * For the sake of progress please consider these arguments settled unless
 * there is a new point that desperately needs to be addressed. Please make
 * sure to check the links to the threads in this commit message whether
 * this has not already been covered.
 */
Q-01: (Florian Weimer [20], Andrew Morton [21])
      What happens when the target process has exited?
A-01: Sending the signal will fail with ESRCH (cf. [22]).

Q-02:  (Andrew Morton [21])
       Is the task_struct pinned by the fd?
A-02:  No. A reference to struct pid is kept. struct pid - as far as I
       understand - was created exactly for the reason to not require to
       pin struct task_struct (cf. [22]).

Q-03: (Andrew Morton [21])
      Does the entire procfs directory remain visible? Just one entry
      within it?
A-03: The same thing that happens right now when you hold a file descriptor
      to /proc/<pid> open (cf. [22]).

Q-04: (Andrew Morton [21])
      Does the pid remain reserved?
A-04: No. This patchset guarantees a stable handle not that pids are not
      recycled (cf. [22]).

Q-05: (Andrew Morton [21])
      Do attempts to signal that fd return errors?
A-05: See {Q,A}-01.

Q-06: (Andrew Morton [22])
      Is there a cleaner way of obtaining the fd? Another syscall perhaps.
A-06: Userspace can already trivially retrieve file descriptors from procfs
      so this is something that we will need to support anyway. Hence,
      there's no immediate need to add another syscalls just to make
      pidfd_send_signal() not dependent on the presence of procfs. However,
      adding a syscalls to get such file descriptors is planned for a
      future patchset (cf. [22]).

Q-07: (Andrew Morton [21] and others)
      This fd-for-a-process sounds like a handy thing and people may well
      think up other uses for it in the future, probably unrelated to
      signals. Are the code and the interface designed to permit such
      future applications?
A-07: Yes (cf. [22]).

Q-08: (Andrew Morton [21] and others)
      Now I think about it, why a new syscall? This thing is looking
      rather like an ioctl?
A-08: This has been extensively discussed. It was agreed that a syscall is
      preferred for a variety or reasons. Here are just a few taken from
      prior threads. Syscalls are safer than ioctl()s especially when
      signaling to fds. Processes are a core kernel concept so a syscall
      seems more appropriate. The layout of the syscall with its four
      arguments would require the addition of a custom struct for the
      ioctl() thereby causing at least the same amount or even more
      complexity for userspace than a simple syscall. The new syscall will
      replace multiple other pid-based syscalls (see description above).
      The file-descriptors-for-processes concept introduced with this
      syscall will be extended with other syscalls in the future. See also
      [22], [23] and various other threads already linked in here.

Q-09: (Florian Weimer [24])
      What happens if you use the new interface with an O_PATH descriptor?
A-09:
      pidfds opened as O_PATH fds cannot be used to send signals to a
      process (cf. [2]). Signaling processes through pidfds is the
      equivalent of writing to a file. Thus, this is not an operation that
      operates "purely at the file descriptor level" as required by the
      open(2) manpage. See also [4].

/* References */
[1]:  https://lore.kernel.org/lkml/20181029221037.87724-1-dancol@google.com/
[2]:  https://lore.kernel.org/lkml/874lbtjvtd.fsf@oldenburg2.str.redhat.com/
[3]:  https://lore.kernel.org/lkml/20181204132604.aspfupwjgjx6fhva@brauner.io/
[4]:  https://lore.kernel.org/lkml/20181203180224.fkvw4kajtbvru2ku@brauner.io/
[5]:  https://lore.kernel.org/lkml/20181121213946.GA10795@mail.hallyn.com/
[6]:  https://lore.kernel.org/lkml/20181120103111.etlqp7zop34v6nv4@brauner.io/
[7]:  https://lore.kernel.org/lkml/36323361-90BD-41AF-AB5B-EE0D7BA02C21@amacapital.net/
[8]:  https://lore.kernel.org/lkml/87tvjxp8pc.fsf@xmission.com/
[9]:  https://asciinema.org/a/IQjuCHew6bnq1cr78yuMv16cy
[11]: https://lore.kernel.org/lkml/F53D6D38-3521-4C20-9034-5AF447DF62FF@amacapital.net/
[12]: https://lore.kernel.org/lkml/87zhtjn8ck.fsf@xmission.com/
[13]: https://lore.kernel.org/lkml/871s6u9z6u.fsf@xmission.com/
[14]: https://lore.kernel.org/lkml/20181206231742.xxi4ghn24z4h2qki@brauner.io/
[15]: https://lore.kernel.org/lkml/20181207003124.GA11160@mail.hallyn.com/
[16]: https://lore.kernel.org/lkml/20181207015423.4miorx43l3qhppfz@brauner.io/
[17]: https://lore.kernel.org/lkml/CAGXu5jL8PciZAXvOvCeCU3wKUEB_dU-O3q0tDw4uB_ojMvDEew@mail.gmail.com/
[18]: https://lore.kernel.org/lkml/20181206222746.GB9224@mail.hallyn.com/
[19]: https://lore.kernel.org/lkml/20181208054059.19813-1-christian@brauner.io/
[20]: https://lore.kernel.org/lkml/8736rebl9s.fsf@oldenburg.str.redhat.com/
[21]: https://lore.kernel.org/lkml/20181228152012.dbf0508c2508138efc5f2bbe@linux-foundation.org/
[22]: https://lore.kernel.org/lkml/20181228233725.722tdfgijxcssg76@brauner.io/
[23]: https://lwn.net/Articles/773459/
[24]: https://lore.kernel.org/lkml/8736rebl9s.fsf@oldenburg.str.redhat.com/
[25]: https://lore.kernel.org/lkml/CAK8P3a0ej9NcJM8wXNPbcGUyOUZYX+VLoDFdbenW3s3114oQZw@mail.gmail.com/

Cc: "Eric W. Biederman" <ebiederm@xmission.com>
Cc: Jann Horn <jannh@google.com>
Cc: Andy Lutomirsky <luto@kernel.org>
Cc: Andrew Morton <akpm@linux-foundation.org>
Cc: Oleg Nesterov <oleg@redhat.com>
Cc: Al Viro <viro@zeniv.linux.org.uk>
Cc: Florian Weimer <fweimer@redhat.com>
Signed-off-by: Christian Brauner <christian@brauner.io>
Reviewed-by: Tycho Andersen <tycho@tycho.ws>
Reviewed-by: Kees Cook <keescook@chromium.org>
Reviewed-by: David Howells <dhowells@redhat.com>
Acked-by: Arnd Bergmann <arnd@arndb.de>
Acked-by: Thomas Gleixner <tglx@linutronix.de>
Acked-by: Serge Hallyn <serge@hallyn.com>
Acked-by: Aleksa Sarai <cyphar@cyphar.com>

(cherry picked from commit 3eb39f47934f9d5a3027fe00d906a45fe3a15fad)

Conflicts:
        include/linux/proc_fs.h - trivial manual merge
        include/uapi/asm-generic/unistd.h - trivial manual merge
        kernel/signal.c

(1. manual merges because of 4.19 differences
 2. change prepare_kill_siginfo() to use struct siginfo instead of
kernel_siginfo
 3. change copy_siginfo_from_user_any() to use struct siginfo instead of
kernel_siginfo
 4. change pidfd_send_signal() to use struct siginfo instead of
kernel_siginfo
 5. use copy_from_user() instead of copy_siginfo_from_user() in
copy_siginfo_from_user_any())

Bug: 135608568
Test: test program using syscall(__NR_pidfd_send_signal,..) to send SIGKILL
Change-Id: I24e6298ecf036d1822f3fa6c5286984b4e195c16
Signed-off-by: Suren Baghdasaryan <surenb@google.com>
Signed-off-by: klozz <klozz@TheXPerienceProject.org>

---
## [SS13-Aeon/Nightstation-13](https://github.com/SS13-Aeon/Nightstation-13)@[fb90397da1...](https://github.com/SS13-Aeon/Nightstation-13/commit/fb90397da100cd806210f5352dcf153184833181)
#### Saturday 2020-12-12 07:49:39 by silicons

pass_flags handling refactor + rewrites a part of projectiles for the n-th time (#54924)

Yeah uhh this'll probably need testmerging even after it's done because yeah it's a bit big.
If y'all want me to atomize this into two PRs (pass flags vs projectiles) tell me please. Pass flags would have to go in first though, in that case, as new projectile hit handling will rely on pass_flags_self.
Pass flags:

Pass flags handling now uses an atom variable named pass_flags_self.
If any of these match a pass_flag on a thing trying to pass through, it's allowed through by default.
This makes overriding CanAllowThrough unnecessary for the majority of things. I've however not removed overrides for very.. weird cases, like plastic flaps which uses a prob(60) for letting PASSGLASS things through for god knows why.
LETPASSTHROW is now on pass_flags_self
Projectiles:

Not finalized yet, need to do something to make the system I have in mind have less unneeded overhead + snowflake

Basically, for piercing/phasing/otherwise projectiles that go through things instead of hitting the first dense object, I have them use pass_flags flags for two new variables, projectile_phasing and projectile_piercing. Anything with pass_flags_self in the former gets phased through entirely. Anything in the latter gets hit, and the projectile then goes through. on_hit will also register a piercing hit vs a normal hit (so things like missiles can only explode on a normal hit or otherwise, instead of exploding multiple times. Not needed as missiles qdel(src) right now but it's nice to have for the future).

I still need to decide what to do for hit handling proper, as Bump() is still preferred due to it not being as high-overhead as something like scanning on Moved(). I'm thinking I'll make Moved() only scan for cases where it needs to hit a non-dense object - a prone human the user clicked on, anything special like that. Don't know the exact specifics yet, which is why this is still WIP.

Projectiles now use check_pierce() to determine if it goes through something and hits it, doesn't hit it, or doesn't go through something at all (should delete self after hitting). Will likely make an on_pierce proc to be called post-piercing something so you can have !fun! things like projectiles that go down in damage after piercing something. This will likely deprecate the process_hit proc, or at least make it less awful.

scan_for_hit() is now used to attempt to hit something and will return whether the projectile got deleted or not. It will delete the projectile if the projectile does hit something and fails to pierce through it.

scan_moved_turf() (WIP) will be used for handling moving onto a turf.

permutated has been renamed to impacted. Ricocheting projectiles get it reset, allowing projectiles to pierce and potentially hit something again if it goes back around.

A new unit test has been added checking for projectiles with movement type of PHASING. This is because PHASING completely causes projectiles to break down as projectiles mainly sense collisions through Bump. The small boost in performance from using PHASING instead of having all pass flags active/overriding check_pierce is in my opinion not worth the extra snowflake in scan_moved_turf() I'd have to do to deal with having to check for hits manually rather than Bump()ing things.
Movement types

UNSTOPPABLE renamed to PHASING to better describe what it is, going through and crossing everything but not actually bumping.
Why It's Good For The Game

Better pass flags handling allows for less proc overrides, bitflag checks are far less expensive in general.

Fixes penetrating projectiles like sniper penetrators

This system also allows for better handling of piercing projectiles (see above) without too much snowflake code, as you'd only need to modify on_pierce() if you needed to do special handling like dampening damage per target pierced, and otherwise you could just use the standardized system and just set pass flags to what's needed. If you really need a projectile that pierces almost everything, override check_pierce(), which is still going to be easier than what was done before (even with snowflake handling of UNSTOPPABLE flag process_hit() was extremely ugly, now we don't rely on movement types at all.)

---
## [rHermes/adventofcode](https://github.com/rHermes/adventofcode)@[90cec91a7b...](https://github.com/rHermes/adventofcode/commit/90cec91a7bbd13a74d4c343a0d7d57787ef438e2)
#### Saturday 2020-12-12 09:42:08 by rHermes

20202 Day 12

Slept horribly today, woke up 3 times during the night, so eventually I
gave up and disabled the alarm for 5:30. Got up at 6:25 ish something
and did the task, spent 00:15:55 on part 1 and 00:09:42 on part 2.

The task today was a bit bland for part 1, but it I liked the twist in
part 2. It was much easier than I thought to make it work and I'm quite
proud of the fact that I defined the left and right turn function so
fast and while so sleepy.

I hit a couple of bumps. One was that I didn't remember that with
Manhattan distance you need to take abs of both x and y.

On part 2 I wasted some time thinking I needed to rotate the point, but
I found the left and right turns quite fast. Don't know how I did it
though, but I did :D

Score:
      --------Part 1--------   --------Part 2--------
Day       Time   Rank  Score       Time   Rank  Score
 12   00:46:57   5644      0   00:56:39   3695      0

---
## [EragonpeerGynt/AoC2020](https://github.com/EragonpeerGynt/AoC2020)@[7947d87eab...](https://github.com/EragonpeerGynt/AoC2020/commit/7947d87eab3befaf692d1095946702baf94e0f00)
#### Saturday 2020-12-12 10:12:07 by EragonpeerGynt

D12 solution

I hate my fucking life. I lost far too much time with rotation (tried with math and similar functions. After that I lost a lot of time debugging what is my code doing poorly. Wrong rotation? Wrong distance? Relative position? NO. I fucking forgot to change roatate function to be executed on waypoint and not the ship itslef.

---
## [Inesteem/AdventOfCode](https://github.com/Inesteem/AdventOfCode)@[7786a22d04...](https://github.com/Inesteem/AdventOfCode/commit/7786a22d04304232d65b676e472a4ff35460dea2)
#### Saturday 2020-12-12 10:59:08 by Lucifer

holy shit, got that bullshit star using rust that doesn't allow mutable and immutable references at the same time; I wanted to implement a link listed with the help of a hashmap. Stupid idea, at least in rust :<

---
## [ezekielsilvester22/SEA-TURTLE](https://github.com/ezekielsilvester22/SEA-TURTLE)@[36b97f1aa4...](https://github.com/ezekielsilvester22/SEA-TURTLE/commit/36b97f1aa437cc2b11035593e0b1bc683a401ce2)
#### Saturday 2020-12-12 11:40:16 by Ezekiel Silvester

Update issue templates

My Store started....[March 16/ 2020 Monday Night 8:02 pm]...My greatest Gift Turtle,  i found by the sea side at night where there was light off in my hood where i live and it takes 20 minutes to get to the beach side and everywhere was dark no light  .... When I was a little boy until  this age now, I have never seen a large turtle on the beach before and in my life too, that was my first day. It was my happiest day because I have taken what is mine that beautiful night Amen

---
## [Wertual08/newxim](https://github.com/Wertual08/newxim)@[ce342dfa70...](https://github.com/Wertual08/newxim/commit/ce342dfa70ec28a6d9a0ffc239df91cf76665358)
#### Saturday 2020-12-12 15:15:23 by Wertual08

Fixed ugly stupid shit (just typo while porting to virtual channels support) which blocked the whole network.

---
## [Ladysnake/BLAST](https://github.com/Ladysnake/BLAST)@[81d3fa7207...](https://github.com/Ladysnake/BLAST/commit/81d3fa72070200751298d06a59b7906dcdb46de1)
#### Saturday 2020-12-12 15:32:03 by doctor4t

Fix #6, fix #7, fix #8

This is absolutely horrendous and I shouldn't do this, but even with a custom FACING tracker handler AE2 fucks up my shit, so whatever

---
## [Slmnj/criterion_kernel_hammerhead](https://github.com/Slmnj/criterion_kernel_hammerhead)@[01db0c5e09...](https://github.com/Slmnj/criterion_kernel_hammerhead/commit/01db0c5e09834c10ff85de25aac0e6537db9be65)
#### Saturday 2020-12-12 15:32:06 by Thomas Gleixner

tick: Upstream fixes

 * Addresses the issue of timers being scheduled on offline CPUs.

tick: Don't invoke tick_nohz_stop_sched_tick() if the cpu is offline

commit 5b39939a4 (nohz: Move ts->idle_calls incrementation into strict
idle logic) moved code out of tick_nohz_stop_sched_tick() and missed
to bail out when the cpu is offline. That's causing subsequent
failures as an offline CPU is supposed to die and not to fiddle with
nohz magic.

Return false in can_stop_idle_tick() if the cpu is offline.

Reported-and-tested-by: Jiri Kosina <jkosina@suse.cz>
Reported-and-tested-by: Prarit Bhargava <prarit@redhat.com>
Cc: Frederic Weisbecker <fweisbec@gmail.com>
Cc: Borislav Petkov <bp@alien8.de>
Cc: Tony Luck <tony.luck@intel.com>
Cc: x86@kernel.org
Link: http://lkml.kernel.org/r/alpine.LFD.2.02.1305132138160.2863@ionos
Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

timers: Consolidate base->next_timer update

Another bunch of mindlessly copied code. All callers of
internal_add_timer() except the recascading code updates
base->next_timer.

Move this into internal_add_timer() and let the cascading code call
__internal_add_timer().

Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Cc: Peter Zijlstra <peterz@infradead.org>
Cc: Gilad Ben-Yossef <gilad@benyossef.com>
Cc: Frederic Weisbecker <fweisbec@gmail.com>
Link: http://lkml.kernel.org/r/20120525214819.189946224@linutronix.de

timers: Create detach_if_pending() and use it

Most callers of detach_timer() have the same pattern around
them. Check whether the timer is pending and eventually updating
base->next_timer.

Create detach_if_pending() and replace the duplicated code.

Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Cc: Peter Zijlstra <peterz@infradead.org>
Cc: Gilad Ben-Yossef <gilad@benyossef.com>
Cc: Frederic Weisbecker <fweisbec@gmail.com>
Link: http://lkml.kernel.org/r/20120525214819.131246037@linutronix.de

timers: Add accounting of non deferrable timers

The code in get_next_timer_interrupt() is suboptimal as it has to run
through the cascade to find the next expiring timer. On a completely
idle core we should only do that when there is an active timer
enqueued and base->next_timer does not give us a fast answer.

Add accounting of the active timers to the now consolidated
attach/detach code. I deliberately avoided sanity checks because the
code is fully symetric and any fiddling with timers w/o using the API
functions will lead to cute explosions anyway. ulong is big enough
even on 32bit and if we really run into the situation to have more
than 1<<32 timers enqueued there, then we are definitely not in a
state to go idle and run through that code.

This allows us to fix another shortcoming of get_next_timer_interrupt().

Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Cc: Peter Zijlstra <peterz@infradead.org>
Cc: Gilad Ben-Yossef <gilad@benyossef.com>
Cc: Frederic Weisbecker <fweisbec@gmail.com>
Link: http://lkml.kernel.org/r/20120525214819.236377028@linutronix.de

timers: Improve get_next_timer_interrupt()

Gilad reported at

 http://lkml.kernel.org/r/1336056962-10465-2-git-send-email-gilad@benyossef.com

"Current timer code fails to correctly return a value meaning that
 there is no future timer event, with the result that the timer keeps
 getting re-armed in HZ one shot mode even when we could turn it off,
 generating unneeded interrupts.

 What is happening is that when __next_timer_interrupt() wishes
 to return a value that signifies "there is no future timer
 event", it returns (base->timer_jiffies + NEXT_TIMER_MAX_DELTA).

 However, the code in tick_nohz_stop_sched_tick(), which called
 __next_timer_interrupt() via get_next_timer_interrupt(),
 compares the return value to (last_jiffies + NEXT_TIMER_MAX_DELTA)
 to see if the timer needs to be re-armed.

 base->timer_jiffies != last_jiffies and so tick_nohz_stop_sched_tick()
 interperts the return value as indication that there is a distant
 future event 12 days from now and programs the timer to fire next
 after KTIME_MAX nsecs instead of avoiding to arm it. This ends up
 causing a needless interrupt once every KTIME_MAX nsecs."

Fix this by using the new active timer accounting. This avoids scans
when no active timer is enqueued completely, so we don't have to rely
on base->timer_next and base->timer_jiffies anymore.

Change-Id: I874ee5e5f837a228cebf5e6a084baf520d33cd0f
Reported-by: Gilad Ben-Yossef <gilad@benyossef.com>
Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Cc: Peter Zijlstra <peterz@infradead.org>
Cc: Frederic Weisbecker <fweisbec@gmail.com>
Link: http://lkml.kernel.org/r/20120525214819.317535385@linutronix.de
Signed-off-by: franciscofranco <franciscofranco.1990@gmail.com>

---
## [LineageOS/android_kernel_samsung_msm8974](https://github.com/LineageOS/android_kernel_samsung_msm8974)@[f09070e206...](https://github.com/LineageOS/android_kernel_samsung_msm8974/commit/f09070e206b1b18382a1ef1a998bcff4d2c7b3c5)
#### Saturday 2020-12-12 15:56:00 by Masahiro Yamada

modpost: file2alias: go back to simple devtable lookup

commit ec91e78d378cc5d4b43805a1227d8e04e5dfa17d upstream.

Commit e49ce14150c6 ("modpost: use linker section to generate table.")
was not so cool as we had expected first; it ended up with ugly section
hacks when commit dd2a3acaecd7 ("mod/file2alias: make modpost compile
on darwin again") came in.

Given a certain degree of unknowledge about the link stage of host
programs, I really want to see simple, stupid table lookup so that
this works in the same way regardless of the underlying executable
format.

Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
Acked-by: Mathieu Malaterre <malat@debian.org>
[nc: Omit rpmsg, sdw, fslmc, tbsvc, and typec as they don't exist here
     Add of to avoid backporting two larger patches]
Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
Signed-off-by: Sasha Levin <sashal@kernel.org>
[haggertk: Backport to 3.4. Omit cpu, hdaudio, ipack, mei, mipscdmm,
 rapidio, ulpi]
Signed-off-by: Kevin F. Haggerty <haggertk@lineageos.org>
Change-Id: Ic632eaa7777338109f80c76535e67917f5b9761c

---
## [NotZeetaa/nexus_kernel_lavender](https://github.com/NotZeetaa/nexus_kernel_lavender)@[982a59cf38...](https://github.com/NotZeetaa/nexus_kernel_lavender/commit/982a59cf383a32ceac74a86c84f4d8014f4c0cef)
#### Saturday 2020-12-12 18:12:30 by Peppe289

ZEN: Implement zen-tune v4.20 over v4.4-arm64

4.9:
In a surprising turn of events, while benchmarking and testing
hierarchical scheduling with BFQ + writeback throttling, it turns out
that raising the number of requests in queue _actually_ improves
responsiveness and completely eliminates the random stalls that would
normally occur without hierarchical scheduling.

To make this test more intense, I used the following test:

Rotational disk1: rsync -a /source/of/data /target/to/disk1
Rotational disk2: rsync -a /source/of/data /target/to/disk2

And periodically attempted to write super fast with:
dd if=/dev/zero of=/target/to/disk1/block bs=4096

This wrote 10gb incredibly fast to writeback and I encountered zero
stalls through this entire test of 10-15 minutes.

My suspicion is that with cgroups, BFQ is more able to properly sort
among multiple drives, reducing the chance of a starved process.  This
plus writeback throttling completely eliminate any outstanding bugs with
high writeback ratios, letting the user enjoy low latency writes
(application thinks they're already done), and super high throughput due
to batched writes in writeback.

Please note however, without the following configuration, I cannot
guarantee you will not get stalls:

CONFIG_BLK_CGROUP=y
CONFIG_CGROUP_WRITEBACK=y
CONFIG_IOSCHED_CFQ=y
CONFIG_CFQ_GROUP_IOSCHED=y
CONFIG_IOSCHED_BFQ=y
CONFIG_BFQ_GROUP_IOSCHED=y
CONFIG_DEFAULT_BFQ=y
CONFIG_SCSI_MQ_DEFAULT=n

Special thanks to h2, author of smxi and inxi, for providing evidence
that a configuration specific to Debian did not cause stalls found the
Liquorix kernels under heavy IO load.  This specific configuration
turned out to be hierarchical scheduling on CFQ (thus, BFQ as well).

4.10:
During some personal testing with the Dolphin emulator, MuQSS has
serious problems scaling its frequencies causing poor performance where
boosting the CPU frequencies would have fixed them.  Reducing the
up_threshold to 45 with MuQSS appears to fix the issue, letting the
introduction to "Star Wars: Rogue Leader" run at 100% speed versus about
80% on my test system.

Also, lets refactor the definitions and include some indentation to help
the reader discern what the scope of all the macros are.

4.11:
Increase MICRO_FREQUENCY_UP_THRESHOLD from 95 to 85
Increase MIN_FREQUENCY_UP_THRESHOLD from 11 to 6

These changes should help make using CFS feel a bit more responsive when
working with mostly idle workloads, browsing the web, scrolling through
text, etc.

Increasing the minimum frequency up threshold to 6% may be too
aggressive though.  Will revert this setting if it causes significant
battery drain.

4.12:
Make bfq the default MQ scheduler

Reduce default sampling down factor from 10 to 1

With the world eventually moving to a more laptop heavy configuration,
it's getting more important that we can reduce our frequencies quickly
after performing work.  This is normal with a ton of background
processes that need to perform burst work then sleep.

Since this doesn't really impact performance too much, lets not keep it
part of ZEN_INTERACTIVE.

Some time ago, the minimum frequency up threshold was set to 1 by
default, but the zen configuration was never updated to take advantage
of it.

Remove custom MIN_FREQUENCY_UP_THRESHOLD for MuQSS / ZEN_INTERACTIVE
configurations and make 1 the default for all choices.

4.18:
Prefer bfq-mq when available if zen interactive is enabled

The bfq-mq elevator is typically one major kernel version ahead in
optimizations and bug fixes due to early access patches in the
algodev/bfq-mq github repository.  Since these patches are typically low
risk and almost always improve performance and/or increase stability,
prefer bfq-mq over bfq when available.

Switch from MuQSS to PDS-mq.

4.19:
Switch from PDS-mq back to MuQSS

4.20:
During some experimentation to influence MuQSS into consolidating strong
single threaded workloads to single cores, I found that the up_threshold
just ends up forcing all cores to run at a higher frequency.

Instead, raising up_threshold back to defaults (95 with micro sampling),
and raising the sampling down factor to 5, the individual cores MuQSS
selects (typically the first few), tend to properly stick to their max
speed and because they complete their tasks faster, MuQSS selects them
again to for the earliest eligible deadline, causing a reciprocal cycle
that improves single thread performance.

Completely fair scheduler (CFS), never really had this issue, but we'll
leave sampling down factor high with CONFIG_ZEN_INTERACTIVE since it'll
benefit CFS users that want higher performance anyway.

Raise minimum CFS latency to 4ms to match 250hz configs.
Raise minimum MuQSS latency to 4ms to match 250hz configs.

Use [defer+madvise] as default khugepaged defrag strategy:

For some reason, the default strategy to respond to THP fault fallbacks
is still just madvise, meaning stall if the program wants transparent
hugepages, but don't trigger a background reclaim / compaction if THP
begins to fail allocations.  This creates a snowball affect where we
still use the THP code paths, but we almost always fail once a system
has been active and busy for a while.

The option "defer" was created for interactive systems where THP can
still improve performance.  If we have to fallback to a regular page due
to an allocation failure or anything else, we will trigger a background
reclaim and compaction so future THP attempts succeed and previous
attempts eventually have their smaller pages combined without stalling
running applications.

We still want madvise to stall applications that explicitely want THP,
so defer+madvise _does_ make a ton of sense.  Make it the default for
interactive systems, especially if the kernel maintainer left
transparent hugepages on "always".

Reasoning and details in the original patch: https://lwn.net/Articles/711248/

Add a scheduler even to multi-queue block devices:
We prefer interactivity to throughput and want BFQ if possible.

Signed-off-by: Albert I <kras@raphielgang.org>
Signed-off-by: Udit Karode <udit.karode@gmail.com>

---
## [Evolution-X/frameworks_base](https://github.com/Evolution-X/frameworks_base)@[e53ce08156...](https://github.com/Evolution-X/frameworks_base/commit/e53ce081562322ae212ec22f3a3d0f361241f015)
#### Saturday 2020-12-12 19:05:00 by ezio84

Fix 2tap2wake after Ambient Pulsing on some devices

like taimen and walleye, instead sunfish (and probably newer pixels)
doesn't need this

To apply, override the config_has_weird_dt_sensor bool in the device tree

----
TL;DR
for some reason, on taimen and walleye, after ambient pulsing
gets triggered by adb with the official "com.android.systemui.doze.pulse"
intent or by our custom "wake to ambient" features, the double tap
sensor dies if you follow this steps:
- screen is OFF
- trigger ambient pulsing with a double tap to wake (if custom wake to
  ambient feature is enabled), or the official intent by adb, or with
  music ticker or any other event
- after ambient display shows up, don't touch anything and wait till the
  screen goes OFF again
- double tap to wake, again
- the double tap sensor doesn't work at all and device doesn't wake up

Now, funny thing, after the steps above, if you cover then uncover the
proximity/brightness sensor with the hand, then double tap to wake
again, the wake gesture works as expected.

When covering/uncovering the proximity/brightness sensor, this happens:
11-10 22:02:00.916   967   998 I ASH     : @ 1993.460: ftm4_disable_sensor: disabling sensor [double-tap]
11-10 22:02:02.013   967   998 I ASH     : @ 1994.556: ftm4_enable_sensor: enabling sensor [double-tap]

When you switch screen ON with power button, the doze screen states do
the same: the sensor gets disabled then enabled again if device goes
to DOZE idle state.

Instead, after Ambient pulsing, when the pulsing finishes, the sensor
is still enabled, so the disable/enable event doesn't happen this
time. And that's why, for some reason, it doesn't respond anymore.
----

So, in a nutshell: i've no idea why this sh#t happens lol,
but with a super lazy hacky tricky dirty bloody nooby line change,
we can force the sensor disable/enable event when the device goes
to DOZE state.

Change-Id: I8ce463a6e435e540e3ca93336c5dba7a95771b56
Signed-off-by: Joey Huab <joey@evolution-x.org>

---
## [bengsfort/dungeon-crawler](https://github.com/bengsfort/dungeon-crawler)@[ec6cb270e1...](https://github.com/bengsfort/dungeon-crawler/commit/ec6cb270e1efdc628ca072200776cf1667ac3af4)
#### Saturday 2020-12-12 19:14:44 by Matt Bengston

IT FUCKING WORKS AGAIN HOLY SHIT THANK YOU GOD JEST IS IN AND IT ISNT AS SCUFFED

---
## [gradualgames/lynnslegacy](https://github.com/gradualgames/lynnslegacy)@[4f2c199319...](https://github.com/gradualgames/lynnslegacy/commit/4f2c1993191d67ed8cd03f71d52f1d114f822a95)
#### Saturday 2020-12-12 19:20:09 by Derek Andrews

Moving all update logic into the draw callback. I discovered that when we turned vsync off, updates were looking in correct or not happening at a high enough resolution to make the seconds-elapsed based timing system of the game work properly. Turns out when I found the problem commit, the problem was that we were always looping over the update logic 4 times never just 1, so when I refactored the logic to loop over the update logic just once when vsync was off, it started acting wonky. It was because we were going if love.window.getVSync() then instead of testing for == 1 or == 0. That will evaluate to true in Lua either way, so we were always looping over the logic 4 times with vsync on or off. Now that we fixed the problem with detecting multiple button presses when we iterate over the update more than once by including a call to blit_scene but with drawing operations turned off, we are forced to keep all the update and draw logic totally in tandem. To avoid making this too confusing, I just move everything into the draw callback. It is always called after the update callback anyway. And now, we only enable the actual drawing calls during the last update. This way, we keep the original logic happy with high resolution seconds elapsed updates but we only do the actual drawing operations once per frame. I thought that with vsync off, we would not need to do multiple updates to get the timing resolution to work out, but it appears that we need about 4 with vsync off to make it happy. I do not fully understand why. With vsync off we get over 200 fps, which you would think would provide more than enough resolution from the seconds elapsed timer to work well, so I'm a bit mystified at present why we have arrived at what we have arrived at. However, it is working well with vsync on or off, so I do not intend to dwell longer on this.

---
## [ctm/Bataan-Memorial-Death-March](https://github.com/ctm/Bataan-Memorial-Death-March)@[eda5b9791e...](https://github.com/ctm/Bataan-Memorial-Death-March/commit/eda5b9791e5ac3f83631187402806069c79ea0b5)
#### Saturday 2020-12-12 19:22:50 by Clifford T. Matthews

Includes today's pack "run".  My water bottle issues bit me very hard
today.

There was a fair amount of snow.  I wore my microspikes and was doing
well, although I had to be careful not only for myself but I needed to
make sure I wasn't misleading others, since I took the new La Luz
which is usually not used in the winter.

As I was approaching a particular tree that tends to push me to the
side, one of my Amphipod water bottles came apart.  The caddy is held
to the bottle using tension and I had loosened the strap before
starting my run to the loosest setting.  I did that so that the caddy
wouldn't interfere with my circulation.  However, when these bottles
are cold and there's snow on them, the rubber doesn't really grip well
and my hands were cold enough that I struggled to get it back
together.

So, eventually I gave up and just held the strap until I got to the
metal plate.  Once I got there I chose to put my two water bottles
into my pack, which, of course, required me to take my pack off.
However, my hands were sufficiently cold that I had trouble working
the buckles and then trouble getting the caps off the water bottles.
I wanted the caps off so I could drink most of my remaining calories.

Drinking super-chilled water when I was already cold wasn't
necessarily a good idea.  In fact, it also made me need to pee.
However, my biggest concern was that my fingers were in a combination
of discomfort and feeling larger than normal, meaning I was losing
some of my feeling.  Since I got frostnip on one arthritic knuckle of
my left hand last week in what was possibly warmer weather, I was a
little concerned about frostnip--or worse.

Anyway, between being slowed down simply by breaking trail in the snow
combined with all my water bottle issues, I took much longer than I
expected and had to immediately start playing the 10am vATLARGE poker
tournament before I could even put things away.

---
## [fuglore/PD2-Hyper-Heisting](https://github.com/fuglore/PD2-Hyper-Heisting)@[16bde0e299...](https://github.com/fuglore/PD2-Hyper-Heisting/commit/16bde0e29991c53e1bee334f60dc764a824730d1)
#### Saturday 2020-12-12 19:49:12 by Fuglore

fuck you shield bastard fucking dick

- made frontliners not take followers

---
## [sechvn/cybersec](https://github.com/sechvn/cybersec)@[a356d79dcd...](https://github.com/sechvn/cybersec/commit/a356d79dcd931285aec7d991a8d8a727633635c4)
#### Saturday 2020-12-12 21:21:40 by sechvn

Add files via upload

This is a program that creates a checking and savings account using functions to deposit, transfer, or withdraw funds. There isn't any error handling yet but will be working on improving the code. Thanks goes to Michael my tutor and also my brother Nick G. for encouraging and helping me. My tutor is an amazing teacher who I found through Fiverr. He did a tremendous job in helping me problem solve with code and to think about things differently.

---

# [<](2020-12-11.md) 2020-12-12 [>](2020-12-13.md)

